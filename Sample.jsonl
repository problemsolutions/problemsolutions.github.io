{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.compilers() <response> Returns the default compilers used by Mix.\n\nIt can be used in your `mix.exs` to prepend or\nappend new compilers to Mix:\n\n    def project do\n      [compilers: Mix.compilers() ++ [:foo, :bar]]\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.debug(debug) <response> Sets Mix debug mode."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.debug?() <response> Returns `true` if Mix is in debug mode, `false` otherwise."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.env() <response> Returns the current Mix environment.\n\nThis function should not be used at runtime in application code (as opposed\nto infrastructure and build code like Mix tasks). Mix is a build tool and may\nnot be available after the code is compiled (for example in a release).\n\nTo differentiate the program behavior depending on the environment, it is\nrecommended to use application environment through `Application.get_env/3`.\nProper configuration can be set in config files, often per-environment\n(see the `Config` module for more information)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.env(env) <response> Changes the current Mix environment to `env`.\n\nBe careful when invoking this function as any project\nconfiguration won't be reloaded.\n\nThis function should not be used at runtime in application code\n(see `env/0` for more information)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.install(deps, opts \\\\ []) <response> Installs and starts dependencies.\n\nThe given `deps` should be in the same format as defined in a regular Mix\nproject. See `mix help deps` for more information. As a shortcut, an atom\ncan be given as dependency to mean the latest version. In other words,\nspecifying `:decimal` is the same as `{:decimal, \">= 0.0.0\"}`.\n\nAfter each successful installation, a given set of dependencies is cached\nso starting another VM and calling `Mix.install/2` with the same dependencies\nwill avoid unnecessary downloads and compilations. The location of the cache\ndirectory can be controlled using the `MIX_INSTALL_DIR` environment variable.\n\nThis function can only be called outside of a Mix project and only with the\nsame dependencies in the given VM.\n\n**Note:** this feature is currently experimental and it may change\nin future releases.\n\n## Options\n\n  * `:force` - if `true`, runs with empty install cache. This is useful when you want\n    to update your dependencies or your install got into an inconsistent state.\n    To use this option, you can also set the `MIX_INSTALL_FORCE` environment variable.\n    (Default: `false`)\n\n  * `:verbose` - if `true`, prints additional debugging information\n    (Default: `false`)\n\n  * `:consolidate_protocols` - if `true`, runs protocol\n    consolidation via the `mix compile.protocols` task (Default: `true`)\n\n  * `:elixir` - if set, ensures the current Elixir version matches the given\n    version requirement (Default: `nil`)\n\n  * `:system_env` (since v1.13.0) - a list or a map of system environment variable\n    names with respective values as binaries. The system environment is made part\n    of the `Mix.install/2` cache, so different configurations will lead to different apps\n\n  * `:config` (since v1.13.0) - a keyword list of keyword lists with application\n    configuration to be set before the apps loaded. The configuration is part of\n    the `Mix.install/2` cache, so different configurations will lead to different\n    apps\n\n  * `:config_path` (since v1.14.0) - path to a configuration file. If a `runtime.exs`\n    file exists in the same directory as the given path, it is loaded too.\n\n  * `:lockfile` (since v1.14.0) - path to a lockfile to be used as a basis of\n    dependency resolution.\n\n## Examples\n\nInstalling `:decimal` and `:jason`:\n\n    Mix.install([\n      :decimal,\n      {:jason, \"~> 1.0\"}\n    ])\n\nInstalling `:nx` & `:exla`, and configuring the underlying applications\nand environment variables:\n\n    Mix.install(\n      [:nx, :exla],\n      config: [\n        nx: [default_backend: EXLA]\n      ],\n      system_env: [\n        XLA_TARGET: \"cuda111\"\n      ]\n    )\n\nInstalling a Mix project as a path dependency along with its configuration\nand deps:\n\n    # $ git clone https://github.com/hexpm/hexpm /tmp/hexpm\n    # $ cd /tmp/hexpm && mix setup\n\n    Mix.install(\n      [\n        {:hexpm, path: \"/tmp/hexpm\", env: :dev},\n      ],\n      config_path: \"/tmp/hexpm/config/config.exs\",\n      lockfile: \"/tmp/hexpm/mix.lock\"\n    )\n\n    Hexpm.Repo.query!(\"SELECT COUNT(1) from packages\")\n    #=> ...\n\nThe example above can be simplified by passing the application\nname as an atom for `:config_path` and `:lockfile`:\n\n    Mix.install(\n      [\n        {:hexpm, path: \"/tmp/hexpm\", env: :dev},\n      ],\n      config_path: :hexpm,\n      lockfile: :hexpm\n    )\n\n## Limitations\n\nThere is one limitation to `Mix.install/2`, which is actually an Elixir\nbehaviour. If you are installing a dependency that defines a struct or\nmacro, you cannot use the struct or macro immediately after the install\ncall. For example, this won't work:\n\n    Mix.install([:decimal])\n    %Decimal{} = Decimal.new(42)\n\nThat's because Elixir first expands all structs and all macros, and then\nit executes the code. This means that, by the time Elixir tries to expand\nthe `%Decimal{}` struct, the dependency has not been installed yet.\n\nLuckily this has a straightforward solution, which is move the code to\ninside a module:\n\n    Mix.install([:decimal])\n\n    defmodule Script do\n      def run do\n        %Decimal{} = Decimal.new(42)\n      end\n    end\n\n    Script.run()\n\nThe contents inside `defmodule` will only be expanded and executed\nafter `Mix.install/2` runs, which means that any struct, macros,\nand imports will be correctly handled."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.installed?() <response> Returns whether `Mix.install/2` was called in the current node."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.path_for(atom) <response> The path for local archives or escripts."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.raise(message) <response> Raises a Mix error that is nicely formatted, defaulting to exit status `1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.raise(message, opts) <response> Raises a Mix error that is nicely formatted.\n\n## Options\n\n  * `:exit_status` - defines exit status, defaults to `1`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.shell() <response> Returns the current shell.\n\n`shell/0` can be used as a wrapper for the current shell. It contains\nconveniences for requesting information from the user, printing to the\nshell and so forth. The Mix shell is swappable (see `shell/1`), allowing\ndevelopers to use a test shell that simply sends messages to the current\nprocess instead of performing IO (see `Mix.Shell.Process`).\n\nBy default, this returns `Mix.Shell.IO`.\n\n## Examples\n\n    Mix.shell().info(\"Preparing to do something dangerous...\")\n\n    if Mix.shell().yes?(\"Are you sure?\") do\n      # do something dangerous\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Mix.shell(shell) <response> Sets the current shell.\n\nAs an argument you may pass `Mix.Shell.IO`, `Mix.Shell.Process`,\n`Mix.Shell.Quiet`, or any module that implements the `Mix.Shell`\nbehaviour.\n\nAfter calling this function, `shell` becomes the shell that is\nreturned by `shell/0`.\n\n## Examples\n\n    iex> Mix.shell(Mix.Shell.IO)\n    :ok\n\nYou can use `shell/0` and `shell/1` to temporarily switch shells,\nfor example, if you want to run a Mix Task that normally produces\na lot of output:\n\n    shell = Mix.shell()\n    Mix.shell(Mix.Shell.Quiet)\n\n    try do\n      Mix.Task.run(\"noisy.task\")\n    after\n      Mix.shell(shell)\n    end"}
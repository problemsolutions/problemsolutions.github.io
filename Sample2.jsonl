{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.bare_log(level, message_or_fun, metadata \\\\ []) <response> Logs a message dynamically.\n\nOpposite to `log/3`, `debug/2`, `info/2`, and friends, the arguments\ngiven to `bare_log/3` are always evaluated. However, you can pass\nanonymous functions to `bare_log/3` and they will only be evaluated\nif there is something to be logged."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.compare_levels(left, right) <response> Compares log levels.\n\nReceives two log levels and compares the `left` level\nagainst the `right` level and returns:\n\n  * `:lt` if `left` is less than `right`\n  * `:eq` if `left` and `right` are equal\n  * `:gt` if `left` is greater than `right`\n\n## Examples\n\n    iex> Logger.compare_levels(:debug, :warning)\n    :lt\n    iex> Logger.compare_levels(:error, :info)\n    :gt"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.configure(options) <response> Configures the logger.\n\nSee the \"Runtime Configuration\" section in the `Logger` module\ndocumentation for the available options. The changes done here\nare automatically persisted to the `:logger` application\nenvironment."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.configure_backend(backend, options) <response> Configures the given backend.\n\nThe backend needs to be started and running in order to\nbe configured at runtime."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_all_module_levels() <response> Resets the logging level for all modules to the primary level."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_application_level(appname) <response> Resets logging level for all modules in the given application to the primary level.\n\nEquivalent of:\n\n    appname |> Application.spec(:modules) |> Logger.delete_module_level()"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_module_level(module) <response> Resets the logging level for a given module to the primary level."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_process_level(pid) <response> Resets logging level for the current process to the primary level.\n\nCurrently the only accepted PID is `self()`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.disable(pid) <response> Disables logging for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nEquivalent of:\n\n    put_process_level(pid, :none)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.enable(pid) <response> Enables logging for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nEquivalent of:\n\n    delete_process_level(pid)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.enabled?(pid) <response> Returns whether the logging is enabled for a given process.\n\nCurrently the only accepted PID is `self()`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.flush() <response> Flushes the logger.\n\nThis guarantees all messages sent to `Logger` prior to this call will\nbe processed. This is useful for testing and it should not be called\nin production code."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.get_module_level(mod) <response> Gets logging level for given module.\n\nThe returned value will be the effective value used. If no value\nwas set for a given module, then it will not be present in\nthe returned list."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.get_process_level(pid) <response> Gets logging level for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nThe returned value will be the effective value used. If no value\nwas set for a given process, then `nil` is returned."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.level() <response> Retrieves the `Logger` level.\n\nThe `Logger` level can be changed via `configure/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.metadata() <response> Reads the current process metadata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.metadata(keyword) <response> Alters the current process metadata according to the given keyword list.\n\nThis function will merge the given keyword list into the existing metadata,\nwith the exception of setting a key to `nil`, which will remove that key\nfrom the metadata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.put_application_level(appname, level) <response> Puts logging level for modules in a given application.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the project.\n\nEquivalent of:\n\n    appname |> Application.spec(:modules) |> Logger.put_module_level(level)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.put_module_level(mod, level) <response> Puts logging level for given module.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the project.\n\n## Example\n\n    defmodule Foo do\n      require Logger\n\n      def log, do: Logger.debug(\"foo\")\n    end\n\n    Logger.configure(level: :error)\n    Logger.put_module_level(Foo, :all)\n\n    Foo.log()\n    # This will print the message even if global level is :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.put_process_level(pid, level) <response> Puts logging level for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the running system."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.remove_backend(backend, opts \\\\ []) <response> Removes a backend.\n\n## Options\n\n  * `:flush` - when `true`, guarantees all messages currently sent\n    to `Logger` are processed before the backend is removed"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.remove_translator(translator) <response> Removes a translator."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.reset_metadata(keyword \\\\ []) <response> Resets the current process metadata to the given keyword list."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> A logger for Elixir applications.\n\nIt includes many features:\n\n  * Provides debug, info, warn, and error levels.\n\n  * Supports multiple backends which are automatically\n    supervised when plugged into `Logger`.\n\n  * Formats and truncates messages on the client\n    to avoid clogging `Logger` backends.\n\n  * Alternates between sync and async modes to remain\n    performant when required but also apply backpressure\n    when under stress.\n\n  * Integrates with Erlang's [`:logger`](`:logger`)\n    to convert terms to Elixir syntax.\n\n  * Allows overriding the logging level for a specific module,\n    application or process.\n\nLogging is useful for tracking when an event of interest happens in your\nsystem. For example, it may be helpful to log whenever a user is deleted.\n\n    def delete_user(user) do\n      Logger.info(\"Deleting user from the system: #{inspect(user)}\")\n      # ...\n    end\n\nThe `Logger.info/2` macro emits the provided message at the `:info`\nlevel. Note the arguments given to `info/2` will only be evaluated\nif a message is logged. For instance, if the Logger level is\nset to `:warning`, `:info` messages are never logged and therefore\nthe arguments given above won't even be executed.\n\nThere are additional macros for other levels.\n\nLogger also allows log commands to be removed altogether via the\n`:compile_time_purge_matching` option (see below).\n\nFor dynamically logging messages, see `bare_log/3`. But note that\n`bare_log/3` always evaluates its arguments (unless the argument\nis an anonymous function)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Levels\n\nThe supported levels, ordered by importance, are:\n\n  * `:emergency` - when system is unusable, panics\n  * `:alert` - for alerts, actions that must be taken immediately,\n    ex. corrupted database\n  * `:critical` - for critical conditions\n  * `:error` - for errors\n  * `:warning` - for warnings\n  * `:notice` - for normal, but significant, messages\n  * `:info` - for information of any kind\n  * `:debug` - for debug-related messages\n\nFor example, `:info` takes precedence over `:debug`. If your log\nlevel is set to `:info`, then all `:info`, `:notice` and above will\nbe passed to backends. If your log level is set to `:alert`, only\n`:alert` and `:emergency` will be printed."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Message\n\nLogger can be used for logging both unstructured and structured data.\n\nUnstructured data is a string or a list of strings:\n\n    Logger.info(\"hello world!\")\n    Logger.info([\"hello \", \"world!\"])\n\nStructured data, also known as reports, are keyword lists and maps:\n\n    Logger.info([new_user: user.id, account_type: :admin])\n    Logger.info(%{new_user: user.id, account_type: :admin})\n\nLog functions also accept a zero-arity anonymous function as a message:\n\n    Logger.info(fn -> \"hello world!\" end)\n\nThe anonymous function can return a message or a tuple containing\nthe message and additional metadata (to be described in the next\nsection).\n\nIn all cases, the arguments given to the `Logger` macros are only\nevaluated if required by the current log level. The exception is\nthe `bare_log/3` function, which is the raw mechanism for logging."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Metadata\n\nWhenever a message is logged, additional information can be given\nvia metadata. Each log operation, such as `Logger.info/2`, allows\nmetadata to be given as an argument.\n\nFurthermore, metadata can be set per process with `Logger.metadata/1`.\n\nSome metadata, however, is always added automatically by Logger\nwhenever possible. Those are:\n\n  * `:application` - the current application\n\n  * `:mfa` - the current module, function and arity\n\n  * `:file` - the current file\n\n  * `:line` - the current line\n\n  * `:pid` - the current process identifier\n\n  * `:initial_call` - the initial call that started the process\n\n  * `:registered_name` - the process registered name as an atom\n\n  * `:domain` - a list of domains for the logged message. For example,\n    all Elixir reports default to `[:elixir]`. Erlang reports may start\n    with `[:otp]` or `[:sasl]`\n\n  * `:crash_reason` - a two-element tuple with the throw/error/exit reason\n    as first argument and the stacktrace as second. A throw will always be\n    `{:nocatch, term}`. An error is always an `Exception` struct. All other\n    entries are exits. The console backend ignores this metadata by default\n    but it can be useful to other backends, such as the ones that report\n    errors to third-party services\n\nNote that all metadata is optional and may not always be available.\nThe `:mfa`, `:file`, `:line`, and similar metadata are automatically\nincluded when using `Logger` macros. `Logger.bare_log/3` does not include\nany metadata beyond the `:pid` by default. Other metadata, such as\n`:crash_reason`, `:initial_call`, and `:registered_name` are available\nonly inside behaviours such as GenServer, Supervisor, and others.\n\nFor example, you might wish to include a custom `:error_code` metadata in\nyour logs:\n\n    Logger.error(\"We have a problem\", [error_code: :pc_load_letter])\n\nIn your app's logger configuration, you would need to include the\n`:error_code` key and you would need to include `$metadata` as part of\nyour log format template:\n\n    config :logger, :console,\n     format: \"[$level] $message $metadata\\n\",\n     metadata: [:error_code, :file]\n\nYour logs might then receive lines like this:\n\n    [error] We have a problem error_code=pc_load_letter file=lib/app.ex"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Configuration\n\n`Logger` supports a wide range of configurations.\n\nThis configuration is split in three categories:\n\n  * Application configuration - must be set before the `:logger`\n    application is started\n\n  * Runtime configuration - can be set before the `:logger`\n    application is started, but may be changed during runtime\n\n  * Erlang configuration - options that handle integration with\n    Erlang's logging facilities"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Application configuration\n\nThe following configuration must be set via config files (such as\n`config/config.exs`) before the `:logger` application is started.\n\n  * `:backends` - the backends to be used. Defaults to `[:console]`.\n    See the \"Backends\" section for more information.\n\n  * `:compile_time_application` - sets the `:application` metadata value\n    to the configured value at compilation time. This configuration is\n    automatically set by Mix and made available as metadata when logging.\n\n  * `:compile_time_purge_matching` - purges *at compilation time* all calls\n    that match the given conditions. This means that `Logger` calls with\n    level lower than this option will be completely removed at compile time,\n    accruing no overhead at runtime. This configuration expects a list of\n    keyword lists. Each keyword list contains a metadata key and the matching\n    value that should be purged. Some special keys are supported:\n\n      * `:level_lower_than` - purges all messages with a lower logger level\n      * `:module` - purges all messages with the matching module\n      * `:function` - purges all messages with the \"function/arity\"\n\n    Remember that if you want to purge log calls from a dependency, the\n    dependency must be recompiled.\n\n  * `:start_options` - passes start options to Logger's main process, such\n    as `:spawn_opt` and `:hibernate_after`. All options in `t:GenServer.option/0`\n    are accepted, except `:name`.\n\nFor example, to configure the `:backends` and purge all calls that happen\nat compile time with level lower than `:info` in a `config/config.exs` file:\n\n    config :logger,\n      backends: [:console],\n      compile_time_purge_matching: [\n        [level_lower_than: :info]\n      ]\n\nIf you want to purge all log calls from an application named `:foo` and only\nkeep errors from `Bar.foo/3`, you can set up two different matches:\n\n    config :logger,\n      compile_time_purge_matching: [\n        [application: :foo],\n        [module: Bar, function: \"foo/3\", level_lower_than: :error]\n      ]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Runtime Configuration\n\nAll configuration below can be set via config files (such as\n`config/config.exs`) but also changed dynamically during runtime via\n`Logger.configure/1`.\n\n  * `:level` - the logging level. Attempting to log any message\n    with severity less than the configured level will simply\n    cause the message to be ignored. Keep in mind that each backend\n    may have its specific level, too. In addition to levels mentioned\n    above it also supports 2 \"meta-levels\":\n\n      - `:all` - all messages will be logged, conceptually identical to\n        `:debug`\n      - `:none` - no messages will be logged at all\n\n  * `:utc_log` - when `true`, uses UTC in logs. By default it uses\n    local time (i.e., it defaults to `false`).\n\n  * `:truncate` - the maximum message size to be logged (in bytes).\n    Defaults to 8192 bytes. Note this configuration is approximate.\n    Truncated messages will have `\" (truncated)\"` at the end.\n    The atom `:infinity` can be passed to disable this behavior.\n\n  * `:sync_threshold` - if the `Logger` manager has more than\n    `:sync_threshold` messages in its queue, `Logger` will change\n    to *sync mode*, to apply backpressure to the clients.\n    `Logger` will return to *async mode* once the number of messages\n    in the queue is reduced to one below the `sync_threshold`.\n    Defaults to 20 messages. `:sync_threshold` can be set to `0` to\n    force *sync mode*.\n\n  * `:discard_threshold` - if the `Logger` manager has more than\n    `:discard_threshold` messages in its queue, `Logger` will change\n    to *discard mode* and messages will be discarded directly in the\n    clients. `Logger` will return to *sync mode* once the number of\n    messages in the queue is reduced to one below the `discard_threshold`.\n    Defaults to 500 messages.\n\n  * `:discard_threshold_periodic_check` - a periodic check that\n    checks and reports if logger is discarding messages. It logs a warning\n    message whenever the system is (or continues) in discard mode and\n    it logs a warning message whenever if the system was discarding messages\n    but stopped doing so after the previous check. By default it runs\n    every `30_000` milliseconds.\n\n  * `:translator_inspect_opts` - when translating OTP reports and\n    errors, the last message and state must be inspected in the\n    error reports. This configuration allow developers to change\n    how much and how the data should be inspected.\n\nFor example, to configure the `:level` and `:truncate` options in a\n`config/config.exs` file:\n\n    config :logger,\n      level: :warning,\n      truncate: 4096"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Erlang/OTP integration\n\nFrom Elixir v1.10, Elixir's Logger is fully integrated with Erlang's\nlogger. They share the same `Logger.level/0`, any metadata set with\n`Logger.metadata/1` applies to both, and so on.\n\nElixir also supports formatting Erlang reports using Elixir syntax.\nThis can be controlled with two configurations:\n\n  * `:handle_otp_reports` - redirects OTP reports to `Logger` so\n    they are formatted in Elixir terms. This effectively disables\n    Erlang standard logger. Defaults to `true`.\n\n  * `:handle_sasl_reports` - redirects supervisor, crash and\n    progress reports to `Logger` so they are formatted in Elixir\n    terms. Your application must guarantee `:sasl` is started before\n    `:logger`. This means you may see some initial reports written\n    in Erlang syntax until the Logger application kicks in.\n    Defaults to `false`. This option only has an effect if\n    `:handle_otp_reports` is true.\n\nFor example, to configure `Logger` to redirect all Erlang messages using a\n`config/config.exs` file:\n\n    config :logger,\n      handle_otp_reports: true,\n      handle_sasl_reports: true\n\nFurthermore, `Logger` allows messages sent by Erlang to be translated\ninto an Elixir format via translators. Translators can be added at any\ntime with the `add_translator/1` and `remove_translator/1` APIs. Check\n`Logger.Translator` for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Backends\n\n`Logger` supports different backends where log messages are written to.\n\nThe available backends by default are:\n\n  * `:console` - logs messages to the console (enabled by default).\n    `:console` is simply a shortcut for `Logger.Backends.Console`\n    (see its documentation for more information)\n\nDevelopers may also implement their own backends, an option that\nis explored in more detail below.\n\nThe initial backends are loaded via the `:backends` configuration,\nwhich must be set before the `:logger` application is started.\nHowever, by the time the Logger application starts, the code for your\nown and third-party backends may not yet be available. For this reason,\nit is preferred to add and remove backends via `add_backend/2` and\n`remove_backend/2` functions. This is often done in your\n`c:Application.start/2` callback:\n\n    @impl true\n    def start(_type, _args) do\n      Logger.add_backend(MyCustomBackend)\n\nThe backend can be configured either on the `add_backend/2` call:\n\n    @impl true\n    def start(_type, _args) do\n      Logger.add_backend(MyCustomBackend, some_config: ...)\n\nOr in your config files:\n\n    config :logger, MyCustomBackend,\n      some_config: ..."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Elixir custom backends\n\nAny developer can create their own `Logger` backend. Since `Logger`\nis an event manager powered by `:gen_event`, writing a new backend\nis a matter of creating an event handler, as described in the\n[`:gen_event`](`:gen_event`) documentation.\n\nFrom now on, we will be using the term \"event handler\" to refer\nto your custom backend, as we head into implementation details.\n\nOnce the `:logger` application starts, it installs all event handlers\nlisted under the `:backends` configuration into the `Logger` event\nmanager. The event manager and all added event handlers are automatically\nsupervised by `Logger`.\n\nNote that if a backend fails to start by returning `{:error, :ignore}`\nfrom its `init/1` callback, then it's not added to the backends but\nnothing fails. If a backend fails to start by returning `{:error, reason}`\nfrom its `init/1` callback, the `:logger` application will fail to start.\n\nOnce initialized, the handler should be designed to handle the\nfollowing events:\n\n  * `{level, group_leader, {Logger, message, timestamp, metadata}}` where:\n    * `level` is one of `:debug`, `:info`, `:warn`, or `:error`, as previously\n      described (for compatibility with pre 1.10 backends the `:notice` will\n      be translated to `:info` and all messages above `:error` will be translated\n      to `:error`)\n    * `group_leader` is the group leader of the process which logged the message\n    * `{Logger, message, timestamp, metadata}` is a tuple containing information\n      about the logged message:\n      * the first element is always the atom `Logger`\n      * `message` is the actual message (as chardata)\n      * `timestamp` is the timestamp for when the message was logged, as a\n        `{{year, month, day}, {hour, minute, second, millisecond}}` tuple\n      * `metadata` is a keyword list of metadata used when logging the message\n\n  * `:flush`\n\nIt is recommended that handlers ignore messages where the group\nleader is in a different node than the one where the handler is\ninstalled. For example:\n\n    def handle_event({_level, gl, {Logger, _, _, _}}, state)\n        when node(gl) != node() do\n      {:ok, state}\n    end\n\nIn the case of the event `:flush` handlers should flush any pending\ndata. This event is triggered by `Logger.flush/0`.\n\nFurthermore, backends can be configured via the `configure_backend/2`\nfunction which requires event handlers to handle calls of the\nfollowing format:\n\n    {:configure, options}\n\nwhere `options` is a keyword list. The result of the call is the result\nreturned by `configure_backend/2`. The recommended return value for\nsuccessful configuration is `:ok`. For example:\n\n    def handle_call({:configure, options}, state) do\n      new_state = reconfigure_state(state, options)\n      {:ok, :ok, new_state}\n    end\n\nIt is recommended that backends support at least the following configuration\noptions:\n\n  * `:level` - the logging level for that backend\n  * `:format` - the logging format for that backend\n  * `:metadata` - the metadata to include in that backend\n\nCheck the `Logger.Backends.Console` implementation in Elixir's codebase\nfor examples on how to handle the recommendations in this section and\nhow to process the existing options."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Erlang/OTP handlers\n\nWhile Elixir Logger provides backends, Erlang/OTP logger provides handlers.\nThey represent the same concept: the ability to integrate into the logging\nsystem to handle each logged message/event.\n\nHowever, implementation-wise, they have the following differences:\n\n  * Elixir backends run in a separate process which comes with overload\n    protection. However, because this process is a single GenEvent, any\n    long running action should be avoided, as it can lead to bottlenecks\n    in the system\n\n  * Erlang handlers run in the same process as the process logging the\n    message/event. This gives developers more flexibility but they should\n    avoid performing any long running action in such handlers, as it may\n    slow down the action being executed considerably. At the moment, there\n    is no built-in overload protection for Erlang handlers, so it is your\n    responsibility to implement it\n\nThe good news is that developers can use third-party implementations of\nboth Elixir backends and Erlang handlers. We have already covered Elixir\nbackends, so let's see how to add Erlang/OTP handlers.\n\nErlang/OTP handlers must be listed under your own application:\n\n    config :my_app, :logger, [\n      {:handler, :name_of_the_handler, ACustomHandler, configuration = %{}}\n    ]\n\nAnd then, explicitly attached in your `c:Application.start/2` callback:\n\n    :logger.add_handlers(:my_app)\n\nNote we do not recommend configuring Erlang/OTP's logger directly under\nthe `:kernel` application in your `config/config.exs`, like this:\n\n    # Not recommended:\n    config :kernel, :logger, ...\n\nThis is because by the time Elixir starts, Erlang's kernel has already\nbeen started, which means the configuration above would have no effect."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.App.stop() <response> Stops the application without sending messages to error logger."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.child_spec(init_arg) <response> Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.start_link(_) <response> Starts the backend supervisor."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.translate_backend(other) <response> Translates the shortcut backend name into its handler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.unwatch(backend) <response> Removes the given `backend`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.watch(backend) <response> Watches the given `backend`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Backends.Console.Elixir.Logger.Backends.Console <response> A logger backend that logs messages by printing them to the console."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Backends.Console.Elixir.Logger.Backends.Console <response> Options\n\n  * `:level` - the level to be logged by this backend.\n    Note that messages are filtered by the general\n    `:level` configuration for the `:logger` application first.\n\n  * `:format` - the format message used to print logs.\n    Defaults to: `\"\\n$time $metadata[$level] $message\\n\"`.\n    It may also be a `{module, function}` tuple that is invoked\n    with the log level, the message, the current timestamp and\n    the metadata and must return `t:IO.chardata/0`. See\n    `Logger.Formatter`.\n\n  * `:metadata` - the metadata to be printed by `$metadata`.\n    Defaults to an empty list (no metadata).\n    Setting `:metadata` to `:all` prints all metadata. See\n    the \"Metadata\" section for more information.\n\n  * `:colors` - a keyword list of coloring options.\n\n  * `:device` - the device to log error messages to. Defaults to\n    `:user` but can be changed to something else such as `:standard_error`.\n\n  * `:max_buffer` - maximum events to buffer while waiting\n    for a confirmation from the IO device (default: 32).\n    Once the buffer is full, the backend will block until\n    a confirmation is received.\n\nThe supported keys in the `:colors` keyword list are:\n\n  * `:enabled` - boolean value that allows for switching the\n    coloring on and off. Defaults to: `IO.ANSI.enabled?/0`\n\n  * `:debug` - color for debug messages. Defaults to: `:cyan`\n\n  * `:info` - color for info and notice messages. Defaults to: `:normal`\n\n  * `:warning` - color for warning messages. Defaults to: `:yellow`\n\n  * `:error` - color for error and higher messages. Defaults to: `:red`\n\nSee the `IO.ANSI` module for a list of colors and attributes.\n\nHere is an example of how to configure the `:console` backend in a\n`config/config.exs` file:\n\n    config :logger, :console,\n      format: \"\\n$time $metadata[$level] $message\\n\",\n      metadata: [:user_id]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Filter.filter_elixir_domain(map, extra) <response> Filter messages logged via `Logger` module when not logging OTP reports."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Filter.process_level(map, extra) <response> Filter out logs if current process opted out of certain levels."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Filter.silence_logger_exit(arg1, extra) <response> A filter that waits until Logger exits and then removes itself."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.compile(pattern) <response> Compiles a format string into a data structure that `format/5` can handle.\n\nCheck the module doc for documentation on the valid parameters that\nwill be interpolated in the pattern. If you pass `nil` as the pattern,\nthe pattern defaults to:\n\n    \"\\n$time $metadata[$level] $message\\n\"\n\nIf you want to customize formatting through a custom formatter, you can\npass a `{module, function}` tuple as the `pattern`.\n\n    iex> Logger.Formatter.compile(\"$time $metadata [$level] $message\\n\")\n    [:time, \" \", :metadata, \" [\", :level, \"] \", :message, \"\\n\"]\n\n    iex> Logger.Formatter.compile({MyLoggerFormatter, :format})\n    {MyLoggerFormatter, :format}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.format(pattern_or_function, level, message, timestamp, metadata) <response> Takes a compiled format and injects the level, timestamp, message, and\nmetadata keyword list and returns a properly formatted string.\n\nIf `pattern_or_function` is a `{module, function_name}` tuple,\nthen `module.function_name(level, message, timestamp, metadata)` is\ninvoked to get the message. See `Logger.Backends.Console` for more\ninformation on this.\n\n## Examples\n\n    iex> pattern = Logger.Formatter.compile(\"[$level] $message\")\n    iex> timestamp = {{1977, 01, 28}, {13, 29, 00, 000}}\n    iex> formatted = Logger.Formatter.format(pattern, :info, \"hello\", timestamp, [])\n    iex> IO.chardata_to_string(formatted)\n    \"[info] hello\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.format_date(arg) <response> Formats date as chardata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.format_time(arg) <response> Formats time as chardata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.prune(binary) <response> Prunes invalid Unicode code points from lists and invalid UTF-8 bytes.\n\nTypically called after formatting when the data cannot be printed."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Conveniences for formatting data for logs.\n\nThis module allows developers to specify a `{module, function}`\nor a string that serves as template for log messages."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Formatting string\n\nThe log messages can be controlled by a formatting string.\nHere is an example of how to configure the `:console` backend\nin a `config/config.exs` file:\n\nFor example:\n\n    config :logger, :console,\n      format: \"$time $metadata[$level] $message\\n\"\n\nThe above will print error messages as:\n\n    18:43:12.439 user_id=13 [error] Hello\\n\n\nThe valid parameters you can use are:\n\n  * `$time`     - the time the log message was sent\n  * `$date`     - the date the log message was sent\n  * `$message`  - the log message\n  * `$level`    - the log level\n  * `$node`     - the node that prints the message\n  * `$metadata` - user controlled data presented in `\"key=val key2=val2 \"` format\n\nBackends typically allow developers to supply such control\nstrings via configuration files. This module provides `compile/1`,\nwhich compiles the string into a format for fast operations at\nruntime and `format/5` to format the compiled pattern into an\nactual IO data."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Formatting function\n\nYou can also customize the format of your log messages to a\n`{module, function}` tuple if you wish to provide your own\nformat function. Here is an example of how to configure the\n`:console` backend in a `config/config.exs` file:\n\n    config :logger, :console,\n      format: {MyConsoleLogger, :format}\n\nAnd here is an example of how you can define `MyConsoleLogger.format/4`\nfrom the above configuration:\n\n    defmodule MyConsoleLogger do\n      @spec format(atom, term, Logger.Formatter.time(), keyword()) :: IO.chardata()\n      def format(level, message, timestamp, metadata) do\n        # Custom formatting logic that must return chardata.\n        # ...\n      end\n    end\n\n**The `format/4` function must not fail**. If it does, it will bring\nthat particular logger instance down, causing your system to temporarily\nlose log messages. If necessary, wrap the function in a `rescue` and\nlog a default message instead:\n\n    defmodule MyConsoleLogger do\n      def format(level, message, timestamp, metadata) do\n        # Custom formatting logic\n      rescue\n        _ -> \"could not format: #{inspect({level, message, metadata})}\"\n      end\n    end\n\nThe `{module, function}` will be invoked with four arguments:\n\n  * the log level: an atom (`t:atom/0`)\n  * the message: this is usually `t:IO.chardata/0`, but in some cases it\n    may contain invalid data. Since the formatting function must\n    *never* fail, you need to prepare for the message being anything\n  * the current timestamp: a term of type `t:Logger.Formatter.time/0`\n  * the metadata: a keyword list (`t:keyword/0`)\n\nThe `{module, function}` must return a term of type `t:IO.chardata/0`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Metadata\n\nMetadata to be sent to the logger can be read and written with\nthe `Logger.metadata/0` and `Logger.metadata/1` functions. For example,\nyou can set `Logger.metadata([user_id: 13])` to add user_id metadata\nto the current process. The user can configure the backend to choose\nwhich metadata it wants to print and it will replace the `$metadata`\nvalue."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Translator.translate(min_level, level, kind, message) <response> Built-in translation function."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Translator.Elixir.Logger.Translator <response> Default translation for Erlang log messages.\n\nLogger allows developers to rewrite log messages provided by\nOTP applications into a format more compatible with Elixir\nlog messages by providing a translator.\n\nA translator is simply a tuple containing a module and a function\nthat can be added and removed via the `Logger.add_translator/1` and\n`Logger.remove_translator/1` functions and is invoked for every Erlang\nmessage above the minimum log level with four arguments:\n\n  * `min_level` - the current Logger level\n  * `level` - the level of the message being translated\n  * `kind` - if the message is a `:report` or `:format`\n  * `message` - the message to format. If it is `:report`, it is a tuple\n    with `{report_type, report_data}`, if it is `:format`, it is a\n    tuple with `{format_message, format_args}`.\n\nThe function must return:\n\n  * `{:ok, chardata, metadata}` - if the message translation with its metadata\n  * `{:ok, chardata}` - the translated message\n  * `:skip` - if the message is not meant to be translated nor logged\n  * `:none` - if there is no translation, which triggers the next translator\n\nSee the function `translate/4` in this module for an example implementation\nand the default messages translated by Logger."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.scan_inspect(format, args, truncate, opts \\\\ %Inspect.Opts{}) <response> Receives a format string and arguments, scans them, and then replace `~p`,\n`~P`, `~w` and `~W` by its inspected variants.\n\nFor information about format scanning and how to consume them,\ncheck `:io_lib.scan_format/2`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.timestamp(timestamp \\\\ :os.system_time(:microsecond), utc_log?) <response> Returns a timestamp that includes milliseconds."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.truncate(chardata, n) <response> Truncates a `chardata` into `n` bytes.\n\nThere is a chance we truncate in the middle of a grapheme\ncluster but we never truncate in the middle of a binary\ncode point. For this reason, truncation is not exact."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Watcher.child_spec(init_arg) <response> Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Watcher.start_link(tuple) <response> Starts a watcher server.\n\nThis is useful when there is a need to start a handler\noutside of the handler supervision tree."}

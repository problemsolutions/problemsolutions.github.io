{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.chunk_every(enum, count, step, leftover \\\\ []) <response> Streams the enumerable in chunks, containing `count` elements each,\nwhere each new chunk starts `step` elements into the enumerable.\n\n`step` is optional and, if not passed, defaults to `count`, i.e.\nchunks do not overlap.\n\nIf the last chunk does not have `count` elements to fill the chunk,\nelements are taken from `leftover` to fill in the chunk. If `leftover`\ndoes not have enough elements to fill the chunk, then a partial chunk\nis returned with less than `count` elements.\n\nIf `:discard` is given in `leftover`, the last chunk is discarded\nunless it has exactly `count` elements.\n\n## Examples\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list()\n    [[1, 2], [3, 4], [5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list()\n    [[1, 2, 3], [4, 5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0])) |> Enum.to_list()\n    [[1, 2, 3], [4, 0, 0]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.chunk_while(enum, acc, chunk_fun, after_fun) <response> Chunks the `enum` with fine grained control when every chunk is emitted.\n\n`chunk_fun` receives the current element and the accumulator and\nmust return `{:cont, element, acc}` to emit the given chunk and\ncontinue with accumulator or `{:cont, acc}` to not emit any chunk\nand continue with the return accumulator.\n\n`after_fun` is invoked when iteration is done and must also return\n`{:cont, element, acc}` or `{:cont, acc}`.\n\n## Examples\n\n    iex> chunk_fun = fn element, acc ->\n    ...>   if rem(element, 2) == 0 do\n    ...>     {:cont, Enum.reverse([element | acc]), []}\n    ...>   else\n    ...>     {:cont, [element | acc]}\n    ...>   end\n    ...> end\n    iex> after_fun = fn\n    ...>   [] -> {:cont, []}\n    ...>   acc -> {:cont, Enum.reverse(acc), []}\n    ...> end\n    iex> stream = Stream.chunk_while(1..10, [], chunk_fun, after_fun)\n    iex> Enum.to_list(stream)\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.concat(enumerables) <response> Creates a stream that enumerates each enumerable in an enumerable.\n\n## Examples\n\n    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.concat(first, second) <response> Creates a stream that enumerates the first argument, followed by the second.\n\n## Examples\n\n    iex> stream = Stream.concat(1..3, 4..6)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> stream1 = Stream.cycle([1, 2, 3])\n    iex> stream2 = Stream.cycle([4, 5, 6])\n    iex> stream = Stream.concat(stream1, stream2)\n    iex> Enum.take(stream, 6)\n    [1, 2, 3, 1, 2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.cycle(enumerable) <response> Creates a stream that cycles through the given enumerable,\ninfinitely.\n\n## Examples\n\n    iex> stream = Stream.cycle([1, 2, 3])\n    iex> Enum.take(stream, 5)\n    [1, 2, 3, 1, 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.dedup(enum) <response> Creates a stream that only emits elements if they are different from the last emitted element.\n\nThis function only ever needs to store the last emitted element.\n\nElements are compared using `===/2`.\n\n## Examples\n\n    iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3, 2, 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.dedup_by(enum, fun) <response> Creates a stream that only emits elements if the result of calling `fun` on the element is\ndifferent from the (stored) result of calling `fun` on the last emitted element.\n\n## Examples\n\n    iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}, {1, :x}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.drop(enum, n) <response> Lazily drops the next `n` elements from the enumerable.\n\nIf a negative `n` is given, it will drop the last `n` elements from\nthe collection. Note that the mechanism by which this is implemented\nwill delay the emission of any element until `n` additional elements have\nbeen emitted by the enum.\n\n## Examples\n\n    iex> stream = Stream.drop(1..10, 5)\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]\n\n    iex> stream = Stream.drop(1..10, -5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.drop_every(enum, nth) <response> Creates a stream that drops every `nth` element from the enumerable.\n\nThe first element is always dropped, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.drop_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.drop_every(1..1000, 1)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.drop_every([1, 2, 3, 4, 5], 0)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.drop_while(enum, fun) <response> Lazily drops elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.duplicate(value, n) <response> Duplicates the given element `n` times in a stream.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty stream is returned.\n\n## Examples\n\n    iex> stream = Stream.duplicate(\"hello\", 0)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.duplicate(\"hi\", 1)\n    iex> Enum.to_list(stream)\n    [\"hi\"]\n\n    iex> stream = Stream.duplicate(\"bye\", 2)\n    iex> Enum.to_list(stream)\n    [\"bye\", \"bye\"]\n\n    iex> stream = Stream.duplicate([1, 2], 3)\n    iex> Enum.to_list(stream)\n    [[1, 2], [1, 2], [1, 2]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.each(enum, fun) <response> Executes the given function for each element.\n\nThe values in the stream do not change, therefore this\nfunction is useful for adding side effects (like printing)\nto a stream. See `map/2` if producing a different stream\nis desired.\n\n## Examples\n\n    iex> stream = Stream.each([1, 2, 3], fn x -> send(self(), x) end)\n    iex> Enum.to_list(stream)\n    iex> receive do: (x when is_integer(x) -> x)\n    1\n    iex> receive do: (x when is_integer(x) -> x)\n    2\n    iex> receive do: (x when is_integer(x) -> x)\n    3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.filter(enum, fun) <response> Creates a stream that filters elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.flat_map(enum, mapper) <response> Maps the given `fun` over `enumerable` and flattens the result.\n\nThis function returns a new stream built by appending the result of invoking `fun`\non each element of `enumerable` together.\n\n## Examples\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [x, x * 2] end)\n    iex> Enum.to_list(stream)\n    [1, 2, 2, 4, 3, 6]\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [[x]] end)\n    iex> Enum.to_list(stream)\n    [[1], [2], [3]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.intersperse(enumerable, intersperse_element) <response> Lazily intersperses `intersperse_element` between each element of the enumeration.\n\n## Examples\n\n    iex> Stream.intersperse([1, 2, 3], 0) |> Enum.to_list()\n    [1, 0, 2, 0, 3]\n\n    iex> Stream.intersperse([1], 0) |> Enum.to_list()\n    [1]\n\n    iex> Stream.intersperse([], 0) |> Enum.to_list()\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.interval(n) <response> Creates a stream that emits a value after the given period `n`\nin milliseconds.\n\nThe values emitted are an increasing counter starting at `0`.\nThis operation will block the caller by the given interval\nevery time a new element is streamed.\n\nDo not use this function to generate a sequence of numbers.\nIf blocking the caller process is not necessary, use\n`Stream.iterate(0, & &1 + 1)` instead.\n\n## Examples\n\n    iex> Stream.interval(10) |> Enum.take(10)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.into(enum, collectable, transform \\\\ fn x -> x end) <response> Injects the stream values into the given collectable as a side-effect.\n\nThis function is often used with `run/1` since any evaluation\nis delayed until the stream is executed. See `run/1` for an example."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.iterate(start_value, next_fun) <response> Emits a sequence of values, starting with `start_value`. Successive\nvalues are generated by calling `next_fun` on the previous value.\n\n## Examples\n\n    iex> Stream.iterate(0, &(&1 + 1)) |> Enum.take(5)\n    [0, 1, 2, 3, 4]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.map(enum, fun) <response> Creates a stream that will apply the given function on\nenumeration.\n\n## Examples\n\n    iex> stream = Stream.map([1, 2, 3], fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.map_every(enum, nth, fun) <response> Creates a stream that will apply the given function on\nevery `nth` element from the enumerable.\n\nThe first element is always passed to the given function.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.map_every(1..10, 2, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n\n    iex> stream = Stream.map_every([1, 2, 3, 4, 5], 1, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.map_every(1..5, 0, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.reject(enum, fun) <response> Creates a stream that will reject elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [1, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.repeatedly(generator_fun) <response> Returns a stream generated by calling `generator_fun` repeatedly.\n\n## Examples\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Stream.repeatedly(&:rand.uniform/0) |> Enum.take(3)\n    [0.5455598952593053, 0.6039309974353404, 0.6684893034823949]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.resource(start_fun, next_fun, after_fun) <response> Emits a sequence of values for the given resource.\n\nSimilar to `transform/3` but the initial accumulated value is\ncomputed lazily via `start_fun` and executes an `after_fun` at\nthe end of enumeration (both in cases of success and failure).\n\nSuccessive values are generated by calling `next_fun` with the\nprevious accumulator (the initial value being the result returned\nby `start_fun`) and it must return a tuple containing a list\nof elements to be emitted and the next accumulator. The enumeration\nfinishes if it returns `{:halt, acc}`.\n\nAs the name says, this function is useful to stream values from\nresources.\n\n## Examples\n\n    Stream.resource(\n      fn -> File.open!(\"sample\") end,\n      fn file ->\n        case IO.read(file, :line) do\n          data when is_binary(data) -> {[data], file}\n          _ -> {:halt, file}\n        end\n      end,\n      fn file -> File.close(file) end\n    )\n\n    iex> Stream.resource(\n    ...>  fn ->\n    ...>    {:ok, pid} = StringIO.open(\"string\")\n    ...>    pid\n    ...>  end,\n    ...>  fn pid ->\n    ...>    case IO.getn(pid, \"\", 1) do\n    ...>      :eof -> {:halt, pid}\n    ...>      char -> {[char], pid}\n    ...>    end\n    ...>  end,\n    ...>  fn pid -> StringIO.close(pid) end\n    ...> ) |> Enum.to_list()\n    [\"s\", \"t\", \"r\", \"i\", \"n\", \"g\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.run(stream) <response> Runs the given stream.\n\nThis is useful when a stream needs to be run, for side effects,\nand there is no interest in its return result.\n\n## Examples\n\nOpen up a file, replace all `#` by `%` and stream to another file\nwithout loading the whole file in memory:\n\n    File.stream!(\"/path/to/file\")\n    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n    |> Stream.into(File.stream!(\"/path/to/other/file\"))\n    |> Stream.run()\n\nNo computation will be done until we call one of the `Enum` functions\nor `run/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.scan(enum, fun) <response> Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the first element in the enumerable\nas the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.scan(enum, acc, fun) <response> Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the given `acc` as the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.take(enum, count) <response> Lazily takes the next `count` elements from the enumerable and stops\nenumeration.\n\nIf a negative `count` is given, the last `count` values will be taken.\nFor such, the collection is fully enumerated keeping up to `2 * count`\nelements in memory. Once the end of the collection is reached,\nthe last `count` elements will be executed. Therefore, using\na negative `count` on an infinite collection will never return.\n\n## Examples\n\n    iex> stream = Stream.take(1..100, 5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take(1..100, -5)\n    iex> Enum.to_list(stream)\n    [96, 97, 98, 99, 100]\n\n    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 1, 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.take_every(enum, nth) <response> Creates a stream that takes every `nth` element from the enumerable.\n\nThe first element is always included, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.take_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [1, 3, 5, 7, 9]\n\n    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take_every(1..1000, 0)\n    iex> Enum.to_list(stream)\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.take_while(enum, fun) <response> Lazily takes elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.timer(n) <response> Creates a stream that emits a single value after `n` milliseconds.\n\nThe value emitted is `0`. This operation will block the caller by\nthe given time until the element is streamed.\n\n## Examples\n\n    iex> Stream.timer(10) |> Enum.to_list()\n    [0]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.transform(enum, acc, reducer) <response> Transforms an existing stream.\n\nIt expects an accumulator and a function that receives two arguments,\nthe stream element and the updated accumulator. It must return a tuple,\nwhere the first element is a new stream (often a list) or the atom `:halt`,\nand the second element is the accumulator to be used by the next element.\n\nNote: this function is equivalent to `Enum.flat_map_reduce/3`, except this\nfunction does not return the accumulator once the stream is processed.\n\n## Examples\n\n`Stream.transform/3` is useful as it can be used as the basis to implement\nmany of the functions defined in this module. For example, we can implement\n`Stream.take(enum, n)` as follows:\n\n    iex> enum = 1001..9999\n    iex> n = 3\n    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n    ...> end)\n    iex> Enum.to_list(stream)\n    [1001, 1002, 1003]\n\n`Stream.transform/5` further generalizes this function to allow wrapping\naround resources."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.transform(enum, start_fun, reducer, after_fun) <response> Similar to `Stream.transform/5`, except `last_fun` is not supplied.\n\nThis function can be seen as a combination of `Stream.resource/3` with\n`Stream.transform/3`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.transform(enum, start_fun, reducer, last_fun, after_fun) <response> Transforms an existing stream with function-based start, last, and after\ncallbacks.\n\nOnce transformation starts, `start_fun` is invoked to compute the initial\naccumulator. Then, for each element in the enumerable, the `reducer` function\nis invoked with the element and the accumulator, returning new elements and a\nnew accumulator, as in `transform/3`.\n\nOnce the collection is done, `last_fun` is invoked with the accumulator to\nemit any remaining items. Then `after_fun` is invoked, to close any resource,\nbut not emitting any new items. `last_fun` is only invoked if the given\nenumerable terminates successfully (either because it is done or it halted\nitself). `after_fun` is always invoked, therefore `after_fun` must be the\none used for closing resources."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.unfold(next_acc, next_fun) <response> Emits a sequence of values for the given accumulator.\n\nSuccessive values are generated by calling `next_fun` with the previous\naccumulator and it must return a tuple with the current value and next\naccumulator. The enumeration finishes if it returns `nil`.\n\n## Examples\n\n    iex> Stream.unfold(5, fn\n    ...>   0 -> nil\n    ...>   n -> {n, n - 1}\n    ...> end) |> Enum.to_list()\n    [5, 4, 3, 2, 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.uniq(enum) <response> Creates a stream that only emits elements if they are unique.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Examples\n\n    iex> Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.uniq_by(enum, fun) <response> Creates a stream that only emits elements if they are unique, by removing the\nelements for which function `fun` returned duplicate elements.\n\nThe function `fun` maps every element to a term which is used to\ndetermine if two elements are duplicates.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Example\n\n    iex> Stream.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}]\n\n    iex> Stream.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end) |> Enum.to_list()\n    [a: {:tea, 2}, c: {:coffee, 1}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.with_index(enum, offset \\\\ 0) <response> Creates a stream where each element in the enumerable will\nbe wrapped in a tuple alongside its index.\n\nIf an `offset` is given, we will index from the given offset instead of from zero.\n\n## Examples\n\n    iex> stream = Stream.with_index([1, 2, 3])\n    iex> Enum.to_list(stream)\n    [{1, 0}, {2, 1}, {3, 2}]\n\n    iex> stream = Stream.with_index([1, 2, 3], 3)\n    iex> Enum.to_list(stream)\n    [{1, 3}, {2, 4}, {3, 5}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip(enumerables) <response> Zips corresponding elements from a finite collection of enumerables\ninto one stream of tuples.\n\nThe zipping finishes as soon as any enumerable in the given collection completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([\"foo\", \"bar\", \"baz\"])\n    iex> Stream.zip([concat, [:a, :b, :c], cycle]) |> Enum.to_list()\n    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip(enumerable1, enumerable2) <response> Zips two enumerables together, lazily.\n\nThe zipping finishes as soon as either enumerable completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([:a, :b, :c])\n    iex> Stream.zip(concat, cycle) |> Enum.to_list()\n    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip_with(enumerables, zip_fun) <response> Lazily zips corresponding elements from a finite collection of enumerables into a new\nenumerable, transforming them with the `zip_fun` function as it goes.\n\nThe first element from each of the enums in `enumerables` will be put into a list which is then passed to\nthe one-arity `zip_fun` function. Then, the second elements from each of the enums are put into a list and passed to\n`zip_fun`, and so on until any one of the enums in `enumerables` completes.\n\nReturns a new enumerable with the results of calling `zip_fun`.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat], fn [a, b] -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat, 1..3], fn [a, b, c] -> a + b + c end) |> Enum.to_list()\n    [3, 6, 9]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip_with(enumerable1, enumerable2, zip_fun) <response> Lazily zips corresponding elements from two enumerables into a new one, transforming them with\nthe `zip_fun` function as it goes.\n\nThe `zip_fun` will be called with the first element from `enumerable1` and the first\nelement from `enumerable2`, then with the second element from each, and so on until\neither one of the enumerables completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with(concat, concat, fn a, b -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.Elixir.Stream <response> Functions for creating and composing streams.\n\nStreams are composable, lazy enumerables (for an introduction on\nenumerables, see the `Enum` module). Any enumerable that generates\nelements one by one during enumeration is called a stream. For example,\nElixir's `Range` is a stream:\n\n    iex> range = 1..5\n    1..5\n    iex> Enum.map(range, &(&1 * 2))\n    [2, 4, 6, 8, 10]\n\nIn the example above, as we mapped over the range, the elements being\nenumerated were created one by one, during enumeration. The `Stream`\nmodule allows us to map the range, without triggering its enumeration:\n\n    iex> range = 1..3\n    iex> stream = Stream.map(range, &(&1 * 2))\n    iex> Enum.map(stream, &(&1 + 1))\n    [3, 5, 7]\n\nNote that we started with a range and then we created a stream that is\nmeant to multiply each element in the range by 2. At this point, no\ncomputation was done. Only when `Enum.map/2` is called we actually\nenumerate over each element in the range, multiplying it by 2 and adding 1.\nWe say the functions in `Stream` are *lazy* and the functions in `Enum`\nare *eager*.\n\nDue to their laziness, streams are useful when working with large\n(or even infinite) collections. When chaining many operations with `Enum`,\nintermediate lists are created, while `Stream` creates a recipe of\ncomputations that are executed at a later moment. Let's see another\nexample:\n\n    1..3\n    |> Enum.map(&IO.inspect(&1))\n    |> Enum.map(&(&1 * 2))\n    |> Enum.map(&IO.inspect(&1))\n    1\n    2\n    3\n    2\n    4\n    6\n    #=> [2, 4, 6]\n\nNote that we first printed each element in the list, then multiplied each\nelement by 2 and finally printed each new value. In this example, the list\nwas enumerated three times. Let's see an example with streams:\n\n    stream = 1..3\n    |> Stream.map(&IO.inspect(&1))\n    |> Stream.map(&(&1 * 2))\n    |> Stream.map(&IO.inspect(&1))\n    Enum.to_list(stream)\n    1\n    2\n    2\n    4\n    3\n    6\n    #=> [2, 4, 6]\n\nAlthough the end result is the same, the order in which the elements were\nprinted changed! With streams, we print the first element and then print\nits double. In this example, the list was enumerated just once!\n\nThat's what we meant when we said earlier that streams are composable,\nlazy enumerables. Note that we could call `Stream.map/2` multiple times,\neffectively composing the streams and keeping them lazy. The computations\nare only performed when you call a function from the `Enum` module.\n\nLike with `Enum`, the functions in this module work in linear time. This\nmeans that, the time it takes to perform an operation grows at the same\nrate as the length of the list. This is expected on operations such as\n`Stream.map/2`. After all, if we want to traverse every element on a\nstream, the longer the stream, the more elements we need to traverse,\nand the longer it will take."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.Elixir.Stream <response> Creating Streams\n\nThere are many functions in Elixir's standard library that return\nstreams, some examples are:\n\n  * `IO.stream/2`         - streams input lines, one by one\n  * `URI.query_decoder/1` - decodes a query string, pair by pair\n\nThis module also provides many convenience functions for creating streams,\nlike `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n\nNote the functions in this module are guaranteed to return enumerables.\nSince enumerables can have different shapes (structs, anonymous functions,\nand so on), the functions in this module may return any of those shapes\nand this may change at any time. For example, a function that today\nreturns an anonymous function may return a struct in future releases."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Chars.to_string(term) <response> Converts `term` to a string."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Chars.Elixir.String.Chars <response> The `String.Chars` protocol is responsible for\nconverting a structure to a binary (only if applicable).\n\nThe only function required to be implemented is\n`to_string/1`, which does the conversion.\n\nThe `to_string/1` function automatically imported\nby `Kernel` invokes this protocol. String\ninterpolation also invokes `to_string/1` in its\narguments. For example, `\"foo#{bar}\"` is the same\nas `\"foo\" <> to_string(bar)`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.at(string, position) <response> Returns the grapheme at the `position` of the given UTF-8 `string`.\nIf `position` is greater than `string` length, then it returns `nil`.\n\n## Examples\n\n    iex> String.at(\"elixir\", 0)\n    \"e\"\n\n    iex> String.at(\"elixir\", 1)\n    \"l\"\n\n    iex> String.at(\"elixir\", 10)\n    nil\n\n    iex> String.at(\"elixir\", -1)\n    \"r\"\n\n    iex> String.at(\"elixir\", -10)\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.bag_distance(string1, string2) <response> Computes the bag distance between two strings.\n\nReturns a float value between 0 and 1 representing the bag\ndistance between `string1` and `string2`.\n\nThe bag distance is meant to be an efficient approximation\nof the distance between two strings to quickly rule out strings\nthat are largely different.\n\nThe algorithm is outlined in the \"String Matching with Metric\nTrees Using an Approximate Distance\" paper by Ilaria Bartolini,\nPaolo Ciaccia, and Marco Patella.\n\n## Examples\n\n    iex> String.bag_distance(\"abc\", \"\")\n    0.0\n    iex> String.bag_distance(\"abcd\", \"a\")\n    0.25\n    iex> String.bag_distance(\"abcd\", \"ab\")\n    0.5\n    iex> String.bag_distance(\"abcd\", \"abc\")\n    0.75\n    iex> String.bag_distance(\"abcd\", \"abcd\")\n    1.0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.capitalize(string, mode \\\\ :default) <response> Converts the first character in the given string to\nuppercase and the remainder to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\ncapitalizes only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.capitalize(\"abcd\")\n    \"Abcd\"\n\n    iex> String.capitalize(\"ï¬n\")\n    \"Fin\"\n\n    iex> String.capitalize(\"olÃ¡\")\n    \"OlÃ¡\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.chunk(string, trait) <response> Splits the string into chunks of characters that share a common trait.\n\nThe trait can be one of two options:\n\n  * `:valid` - the string is split into chunks of valid and invalid\n    character sequences\n\n  * `:printable` - the string is split into chunks of printable and\n    non-printable character sequences\n\nReturns a list of binaries each of which contains only one kind of\ncharacters.\n\nIf the given string is empty, an empty list is returned.\n\n## Examples\n\n    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n    [\"abc\\0\"]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0xFFFF::utf16>>, :valid)\n    [\"abc\\0\", <<0xFFFF::utf16>>]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0FFFF::utf8>>, :printable)\n    [\"abc\", <<0, 0x0FFFF::utf8>>]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.codepoints(string) <response> Returns a list of code points encoded as strings.\n\nTo retrieve code points in their natural integer\nrepresentation, see `to_charlist/1`. For details about\ncode points and graphemes, see the `String` module\ndocumentation.\n\n## Examples\n\n    iex> String.codepoints(\"olÃ¡\")\n    [\"o\", \"l\", \"Ã¡\"]\n\n    iex> String.codepoints(\"Ð¾Ð¿ÑÐ¸Ð¼Ð¸ Ð·Ð°ÑÐ¸Ð¸\")\n    [\"Ð¾\", \"Ð¿\", \"Ñ\", \"Ð¸\", \"Ð¼\", \"Ð¸\", \" \", \"Ð·\", \"Ð°\", \"Ñ\", \"Ð¸\", \"Ð¸\"]\n\n    iex> String.codepoints(\"á¼á¼ªá¿¼\")\n    [\"á¼\", \"á¼ª\", \"á¿¼\"]\n\n    iex> String.codepoints(\"\\u00e9\")\n    [\"Ã©\"]\n\n    iex> String.codepoints(\"\\u0065\\u0301\")\n    [\"e\", \"Ì\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.contains?(string, contents) <response> Searches if `string` contains any of the given `contents`.\n\n`contents` can be either a string, a list of strings,\nor a compiled pattern. If `contents` is a list, this\nfunction will search if any of the strings in `contents`\nare part of `string`.\n\n> Note: if you want to check if `string` is listed in `contents`,\n> where `contents` is a list, use `Enum.member?(contents, string)`\n> instead.\n\n## Examples\n\n    iex> String.contains?(\"elixir of life\", \"of\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"life\", \"death\"])\n    true\n    iex> String.contains?(\"elixir of life\", [\"death\", \"mercury\"])\n    false\n\nThe argument can also be a compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\"life\", \"death\"])\n    iex> String.contains?(\"elixir of life\", pattern)\n    true\n\nAn empty string will always match:\n\n    iex> String.contains?(\"elixir of life\", \"\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.contains?(\"elixir of life\", [])\n    false\n\n    iex> String.contains?(\"\", [])\n    false\n\nBe aware that this function can match within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following returns `true`:\n\n    iex> String.contains?(String.normalize(\"Ã©\", :nfd), \"e\")\n    true\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it will return `false`:\n\n    iex> String.contains?(String.normalize(\"Ã©\", :nfc), \"e\")\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.downcase(string, mode \\\\ :default) <response> Converts all characters in the given string to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nlowercases only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.downcase(\"ABCD\")\n    \"abcd\"\n\n    iex> String.downcase(\"AB 123 XPTO\")\n    \"ab 123 xpto\"\n\n    iex> String.downcase(\"OLÃ\")\n    \"olÃ¡\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.downcase(\"OLÃ\", :ascii)\n    \"olÃ\"\n\nThe `:greek` mode properly handles the context sensitive sigma in Greek:\n\n    iex> String.downcase(\"Î£Î£\")\n    \"ÏÏ\"\n\n    iex> String.downcase(\"Î£Î£\", :greek)\n    \"ÏÏ\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.downcase(\"IÄ°\")\n    \"iiÌ\"\n\n    iex> String.downcase(\"IÄ°\", :turkic)\n    \"Ä±i\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.duplicate(subject, n) <response> Returns a string `subject` repeated `n` times.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.duplicate(\"abc\", 0)\n    \"\"\n\n    iex> String.duplicate(\"abc\", 1)\n    \"abc\"\n\n    iex> String.duplicate(\"abc\", 2)\n    \"abcabc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.ends_with?(string, suffix) <response> Returns `true` if `string` ends with any of the suffixes given.\n\n`suffixes` can be either a single suffix or a list of suffixes.\n\n## Examples\n\n    iex> String.ends_with?(\"language\", \"age\")\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"age\"])\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"elixir\"])\n    false\n\nAn empty suffix will always match:\n\n    iex> String.ends_with?(\"language\", \"\")\n    true\n    iex> String.ends_with?(\"language\", [\"\", \"other\"])\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.equivalent?(string1, string2) <response> Returns `true` if `string1` is canonically equivalent to `string2`.\n\nIt performs Normalization Form Canonical Decomposition (NFD) on the\nstrings before comparing them. This function is equivalent to:\n\n    String.normalize(string1, :nfd) == String.normalize(string2, :nfd)\n\nIf you plan to compare multiple strings, multiple times in a row, you\nmay normalize them upfront and compare them directly to avoid multiple\nnormalization passes.\n\n## Examples\n\n    iex> String.equivalent?(\"abc\", \"abc\")\n    true\n\n    iex> String.equivalent?(\"man\\u0303ana\", \"maÃ±ana\")\n    true\n\n    iex> String.equivalent?(\"abc\", \"ABC\")\n    false\n\n    iex> String.equivalent?(\"nÃ¸\", \"nÃ³\")\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.first(string) <response> Returns the first grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\n## Examples\n\n    iex> String.first(\"elixir\")\n    \"e\"\n\n    iex> String.first(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    \"Õ¥\"\n\n    iex> String.first(\"\")\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.graphemes(string) <response> Returns Unicode graphemes in the string as per Extended Grapheme\nCluster algorithm.\n\nThe algorithm is outlined in the [Unicode Standard Annex #29,\nUnicode Text Segmentation](https://www.unicode.org/reports/tr29/).\n\nFor details about code points and graphemes, see the `String` module documentation.\n\n## Examples\n\n    iex> String.graphemes(\"ÅaÃ¯ve\")\n    [\"Å\", \"a\", \"Ã¯\", \"v\", \"e\"]\n\n    iex> String.graphemes(\"\\u00e9\")\n    [\"Ã©\"]\n\n    iex> String.graphemes(\"\\u0065\\u0301\")\n    [\"eÌ\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.jaro_distance(string1, string2) <response> Computes the Jaro distance (similarity) between two strings.\n\nReturns a float value between `0.0` (equates to no similarity) and `1.0`\n(is an exact match) representing [Jaro](https://en.wikipedia.org/wiki/Jaro-Winkler_distance)\ndistance between `string1` and `string2`.\n\nThe Jaro distance metric is designed and best suited for short\nstrings such as person names. Elixir itself uses this function\nto provide the \"did you mean?\" functionality. For instance, when you\nare calling a function in a module and you have a typo in the\nfunction name, we attempt to suggest the most similar function\nname available, if any, based on the `jaro_distance/2` score.\n\n## Examples\n\n    iex> String.jaro_distance(\"Dwayne\", \"Duane\")\n    0.8222222222222223\n    iex> String.jaro_distance(\"even\", \"odd\")\n    0.0\n    iex> String.jaro_distance(\"same\", \"same\")\n    1.0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.last(string) <response> Returns the last grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\nIt traverses the whole string to find its last grapheme.\n\n## Examples\n\n    iex> String.last(\"\")\n    nil\n\n    iex> String.last(\"elixir\")\n    \"r\"\n\n    iex> String.last(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    \"Õ«\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.length(string) <response> Returns the number of Unicode graphemes in a UTF-8 string.\n\n## Examples\n\n    iex> String.length(\"elixir\")\n    6\n\n    iex> String.length(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    5"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.match?(string, regex) <response> Checks if `string` matches the given regular expression.\n\n## Examples\n\n    iex> String.match?(\"foo\", ~r/foo/)\n    true\n\n    iex> String.match?(\"bar\", ~r/foo/)\n    false\n\nElixir also provides text-based match operator `=~/2` and function `Regex.match?/2` as\nalternatives to test strings against regular expressions."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.myers_difference(string1, string2) <response> Returns a keyword list that represents an edit script.\n\nCheck `List.myers_difference/2` for more information.\n\n## Examples\n\n    iex> string1 = \"fox hops over the dog\"\n    iex> string2 = \"fox jumps over the lazy cat\"\n    iex> String.myers_difference(string1, string2)\n    [eq: \"fox \", del: \"ho\", ins: \"jum\", eq: \"ps over the \", del: \"dog\", ins: \"lazy cat\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.next_codepoint(arg) <response> Returns the next code point in a string.\n\nThe result is a tuple with the code point and the\nremainder of the string or `nil` in case\nthe string reached its end.\n\nAs with other functions in the `String` module, `next_codepoint/1`\nworks with binaries that are invalid UTF-8. If the string starts\nwith a sequence of bytes that is not valid in UTF-8 encoding, the\nfirst element of the returned tuple is a binary with the first byte.\n\n## Examples\n\n    iex> String.next_codepoint(\"olÃ¡\")\n    {\"o\", \"lÃ¡\"}\n\n    iex> invalid = \"\\x80\\x80OK\" # first two bytes are invalid in UTF-8\n    iex> {_, rest} = String.next_codepoint(invalid)\n    {<<128>>, <<128, 79, 75>>}\n    iex> String.next_codepoint(rest)\n    {<<128>>, \"OK\"}\n\n## Comparison with binary pattern matching\n\nBinary pattern matching provides a similar way to decompose\na string:\n\n    iex> <<codepoint::utf8, rest::binary>> = \"Elixir\"\n    \"Elixir\"\n    iex> codepoint\n    69\n    iex> rest\n    \"lixir\"\n\nthough not entirely equivalent because `codepoint` comes as\nan integer, and the pattern won't match invalid UTF-8.\n\nBinary pattern matching, however, is simpler and more efficient,\nso pick the option that better suits your use case."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.next_grapheme(string) <response> Returns the next grapheme in a string.\n\nThe result is a tuple with the grapheme and the\nremainder of the string or `nil` in case\nthe String reached its end.\n\n## Examples\n\n    iex> String.next_grapheme(\"olÃ¡\")\n    {\"o\", \"lÃ¡\"}\n\n    iex> String.next_grapheme(\"\")\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.normalize(string, form) <response> Converts all characters in `string` to Unicode normalization\nform identified by `form`.\n\nInvalid Unicode codepoints are skipped and the remaining of\nthe string is converted. If you want the algorithm to stop\nand return on invalid codepoint, use `:unicode.characters_to_nfd_binary/1`,\n`:unicode.characters_to_nfc_binary/1`, `:unicode.characters_to_nfkd_binary/1`,\nand `:unicode.characters_to_nfkc_binary/1` instead.\n\nNormalization forms `:nfkc` and `:nfkd` should not be blindly applied\nto arbitrary text. Because they erase many formatting distinctions,\nthey will prevent round-trip conversion to and from many legacy\ncharacter sets.\n\n## Forms\n\nThe supported forms are:\n\n  * `:nfd` - Normalization Form Canonical Decomposition.\n    Characters are decomposed by canonical equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfc` - Normalization Form Canonical Composition.\n    Characters are decomposed and then recomposed by canonical equivalence.\n\n  * `:nfkd` - Normalization Form Compatibility Decomposition.\n    Characters are decomposed by compatibility equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfkc` - Normalization Form Compatibility Composition.\n    Characters are decomposed and then recomposed by compatibility equivalence.\n\n## Examples\n\n    iex> String.normalize(\"yÃªsÌÌ£\", :nfd)\n    \"yeÌsÌ£Ì\"\n\n    iex> String.normalize(\"lenÌa\", :nfc)\n    \"leÃ±a\"\n\n    iex> String.normalize(\"ï¬\", :nfkd)\n    \"fi\"\n\n    iex> String.normalize(\"fi\", :nfkc)\n    \"fi\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.pad_leading(string, count, padding \\\\ [\" \"]) <response> Returns a new string padded with a leading filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_leading(\"abc\", 5)\n    \"  abc\"\n\n    iex> String.pad_leading(\"abc\", 4, \"12\")\n    \"1abc\"\n\n    iex> String.pad_leading(\"abc\", 6, \"12\")\n    \"121abc\"\n\n    iex> String.pad_leading(\"abc\", 5, [\"1\", \"23\"])\n    \"123abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.pad_trailing(string, count, padding \\\\ [\" \"]) <response> Returns a new string padded with a trailing filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_trailing(\"abc\", 5)\n    \"abc  \"\n\n    iex> String.pad_trailing(\"abc\", 4, \"12\")\n    \"abc1\"\n\n    iex> String.pad_trailing(\"abc\", 6, \"12\")\n    \"abc121\"\n\n    iex> String.pad_trailing(\"abc\", 5, [\"1\", \"23\"])\n    \"abc123\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.printable?(string, character_limit \\\\ :infinity) <response> Checks if a string contains only printable characters up to `character_limit`.\n\nTakes an optional `character_limit` as a second argument. If `character_limit` is `0`, this\nfunction will return `true`.\n\n## Examples\n\n    iex> String.printable?(\"abc\")\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>)\n    false\n\n    iex> String.printable?(\"abc\" <> <<0>>, 2)\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>, 0)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace(subject, pattern, replacement, options \\\\ []) <response> Returns a new string created by replacing occurrences of `pattern` in\n`subject` with `replacement`.\n\nThe `subject` is always a string.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe `replacement` may be a string or a function that receives the matched\npattern and must return the replacement as a string or iodata.\n\nBy default it replaces all occurrences but this behaviour can be controlled\nthrough the `:global` option; see the \"Options\" section below.\n\n## Options\n\n  * `:global` - (boolean) if `true`, all occurrences of `pattern` are replaced\n    with `replacement`, otherwise only the first occurrence is\n    replaced. Defaults to `true`\n\n## Examples\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\")\n    \"a-b-c\"\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n    \"a-b,c\"\n\nThe pattern may also be a list of strings and the replacement may also\nbe a function that receives the matches:\n\n    iex> String.replace(\"a,b,c\", [\"a\", \"c\"], fn <<char>> -> <<char + 1>> end)\n    \"b,b,d\"\n\nWhen the pattern is a regular expression, one can give `\\N` or\n`\\g{N}` in the `replacement` string to access a specific capture in the\nregular expression:\n\n    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\g{1}\")\n    \"a,bb,cc\"\n\nNote that we had to escape the backslash escape character (i.e., we used `\\\\N`\ninstead of just `\\N` to escape the backslash; same thing for `\\\\g{N}`). By\ngiving `\\0`, one can inject the whole match in the replacement string.\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern(\",\")\n    iex> String.replace(\"a,b,c\", pattern, \"[]\")\n    \"a[]b[]c\"\n\nWhen an empty string is provided as a `pattern`, the function will treat it as\nan implicit empty string between each grapheme and the string will be\ninterspersed. If an empty string is provided as `replacement` the `subject`\nwill be returned:\n\n    iex> String.replace(\"ELIXIR\", \"\", \".\")\n    \".E.L.I.X.I.R.\"\n\n    iex> String.replace(\"ELIXIR\", \"\", \"\")\n    \"ELIXIR\"\n\nBe aware that this function can replace within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following will replace only the letter \"e\",\nmoving the accent to the letter \"o\":\n\n    iex> String.replace(String.normalize(\"Ã©\", :nfd), \"e\", \"o\")\n    \"oÌ\"\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it won't be replaced at all:\n\n    iex> String.replace(String.normalize(\"Ã©\", :nfc), \"e\", \"o\")\n    \"Ã©\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_leading(string, match, replacement) <response> Replaces all leading occurrences of `match` by `replacement` of `match` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe beginning of `string`, and it's impossible to replace \"multiple\"\noccurrences of `\"\"`.\n\n## Examples\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"\")\n    \"world\"\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"ola \")\n    \"ola ola world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_prefix(string, match, replacement) <response> Replaces prefix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just prepended to `string`.\n\n## Examples\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"\")\n    \"hello world\"\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"ola \")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"ola \")\n    \"ola hello world\"\n\n    iex> String.replace_prefix(\"world\", \"\", \"hello \")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_suffix(string, match, replacement) <response> Replaces suffix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just appended to `string`.\n\n## Examples\n\n    iex> String.replace_suffix(\"hello\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \"\")\n    \"hello world\"\n\n    iex> String.replace_suffix(\"hello\", \" world\", \" mundo\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \" mundo\")\n    \"hello world mundo\"\n\n    iex> String.replace_suffix(\"hello\", \"\", \" world\")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_trailing(string, match, replacement) <response> Replaces all trailing occurrences of `match` by `replacement` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe end of `string`, and it's impossible to replace \"multiple\" occurrences of\n`\"\"`.\n\n## Examples\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \"\")\n    \"hello\"\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \" mundo\")\n    \"hello mundo mundo\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.reverse(string) <response> Reverses the graphemes in given string.\n\n## Examples\n\n    iex> String.reverse(\"abcd\")\n    \"dcba\"\n\n    iex> String.reverse(\"hello world\")\n    \"dlrow olleh\"\n\n    iex> String.reverse(\"hello âog\")\n    \"goâ olleh\"\n\nKeep in mind reversing the same string twice does\nnot necessarily yield the original string:\n\n    iex> \"Ìe\"\n    \"Ìe\"\n    iex> String.reverse(\"Ìe\")\n    \"eÌ\"\n    iex> String.reverse(String.reverse(\"Ìe\"))\n    \"eÌ\"\n\nIn the first example the accent is before the vowel, so\nit is considered two graphemes. However, when you reverse\nit once, you have the vowel followed by the accent, which\nbecomes one grapheme. Reversing it again will keep it as\none single grapheme."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.slice(string, range) <response> Returns a substring from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nIf the start of the range is not a valid offset for the given\nstring or if the range is in reverse order, returns `\"\"`.\n\nIf the start or end of the range is negative, the whole string\nis traversed first in order to convert the negative indices into\npositive ones.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or\n`Kernel.binary_slice/2` instead\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> String.slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -100..100)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> String.slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole string as is:\n\n    iex> String.slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the string:\n\n    iex> String.slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> String.slice(\"elixir\", 10..3)\n    \"\"\n    iex> String.slice(\"a\", 1..1500)\n    \"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.slice(string, start, length) <response> Returns a substring starting at the offset `start`, and of the given `length`.\n\nIf the offset is greater than string length, then it returns `\"\"`.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or `Kernel.binary_slice/3`\ninstead.\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1, 3)\n    \"lix\"\n\n    iex> String.slice(\"elixir\", 1, 10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", 10, 3)\n    \"\"\n\nIf the start position is negative, it is normalized\nagainst the string length and clamped to 0:\n\n    iex> String.slice(\"elixir\", -4, 4)\n    \"ixir\"\n\n    iex> String.slice(\"elixir\", -10, 3)\n    \"eli\"\n\nIf start is more than the string length, an empty\nstring is returned:\n\n    iex> String.slice(\"elixir\", 10, 1500)\n    \"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.split(binary) <response> Divides a string into substrings at each Unicode whitespace\noccurrence with leading and trailing whitespace ignored. Groups\nof whitespace are treated as a single occurrence. Divisions do\nnot occur on non-breaking whitespace.\n\n## Examples\n\n    iex> String.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\" foo   bar \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"no\\u00a0break\")\n    [\"no\\u00a0break\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.split(string, pattern, options \\\\ []) <response> Divides a string into parts based on a pattern.\n\nReturns a list of these parts.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe string is split into as many parts as possible by\ndefault, but can be controlled via the `:parts` option.\n\nEmpty strings are only removed from the result if the\n`:trim` option is set to `true`.\n\nWhen the pattern used is a regular expression, the string is\nsplit using `Regex.split/3`.\n\n## Options\n\n  * `:parts` (positive integer or `:infinity`) - the string\n    is split into at most as many parts as this option specifies.\n    If `:infinity`, the string will be split into all possible\n    parts. Defaults to `:infinity`.\n\n  * `:trim` (boolean) - if `true`, empty strings are removed from\n    the resulting list.\n\nThis function also accepts all options accepted by `Regex.split/3`\nif `pattern` is a regular expression.\n\n## Examples\n\nSplitting with a string pattern:\n\n    iex> String.split(\"a,b,c\", \",\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", \",\", parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", \" \", trim: true)\n    [\"a\", \"b\", \"c\"]\n\nA list of patterns:\n\n    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n    [\"1\", \"2\", \"3\", \"4\"]\n\nA regular expression:\n\n    iex> String.split(\"a,b,c\", ~r{,})\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", ~r{b}, include_captures: true)\n    [\"a\", \"b\", \"c\"]\n\nA compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.split(\"1,2 3,4\", pattern)\n    [\"1\", \"2\", \"3\", \"4\"]\n\nSplitting on empty string returns graphemes:\n\n    iex> String.split(\"abc\", \"\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> String.split(\"abc\", \"\", trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", \"\", parts: 1)\n    [\"abc\"]\n\n    iex> String.split(\"abc\", \"\", parts: 3)\n    [\"\", \"a\", \"bc\"]\n\nBe aware that this function can split within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following will split the string into two parts:\n\n    iex> String.split(String.normalize(\"Ã©\", :nfd), \"e\")\n    [\"\", \"Ì\"]\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it will split the string into just one part:\n\n    iex> String.split(String.normalize(\"Ã©\", :nfc), \"e\")\n    [\"Ã©\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.split_at(string, position) <response> Splits a string into two at the specified offset. When the offset given is\nnegative, location is counted from the end of the string.\n\nThe offset is capped to the length of the string. Returns a tuple with\ntwo elements.\n\nNote: keep in mind this function splits on graphemes and for such it\nhas to linearly traverse the string. If you want to split a string or\na binary based on the number of bytes, use `Kernel.binary_part/3`\ninstead.\n\n## Examples\n\n    iex> String.split_at(\"sweetelixir\", 5)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"sweetelixir\", -6)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"abc\", 0)\n    {\"\", \"abc\"}\n\n    iex> String.split_at(\"abc\", 1000)\n    {\"abc\", \"\"}\n\n    iex> String.split_at(\"abc\", -1000)\n    {\"\", \"abc\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.splitter(string, pattern, options \\\\ []) <response> Returns an enumerable that splits a string on demand.\n\nThis is in contrast to `split/3` which splits the\nentire string upfront.\n\nThis function does not support regular expressions\nby design. When using regular expressions, it is often\nmore efficient to have the regular expressions traverse\nthe string at once than in parts, like this function does.\n\n## Options\n\n  * :trim - when `true`, does not emit empty patterns\n\n## Examples\n\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", [\" \", \",\"]) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]\n\n    iex> String.splitter(\"abcd\", \"\") |> Enum.take(10)\n    [\"\", \"a\", \"b\", \"c\", \"d\", \"\"]\n\n    iex> String.splitter(\"abcd\", \"\", trim: true) |> Enum.take(10)\n    [\"a\", \"b\", \"c\", \"d\"]\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", pattern) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.starts_with?(string, prefix) <response> Returns `true` if `string` starts with any of the prefixes given.\n\n`prefix` can be either a string, a list of strings, or a compiled\npattern.\n\n## Examples\n\n    iex> String.starts_with?(\"elixir\", \"eli\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"elixir\"])\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"ruby\"])\n    false\n\nAn empty string will always match:\n\n    iex> String.starts_with?(\"elixir\", \"\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.starts_with?(\"elixir\", [])\n    false\n\n    iex> String.starts_with?(\"\", [])\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_atom(string) <response> Converts a string to an atom.\n\nWarning: this function creates atoms dynamically and atoms are\nnot garbage-collected. Therefore, `string` should not be an\nuntrusted value, such as input received from a socket or during\na web request. Consider using `to_existing_atom/1` instead.\n\nBy default, the maximum number of atoms is `1_048_576`. This limit\ncan be raised or lowered using the VM option `+t`.\n\nThe maximum atom size is of 255 Unicode code points.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_atom(\"my_atom\")\n    :my_atom"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_charlist(string) <response> Converts a string into a charlist.\n\nSpecifically, this function takes a UTF-8 encoded binary and returns a list of its integer\ncode points. It is similar to `codepoints/1` except that the latter returns a list of code points as\nstrings.\n\nIn case you need to work with bytes, take a look at the\n[`:binary` module](`:binary`).\n\n## Examples\n\n    iex> String.to_charlist(\"Ã¦Ã\")\n    'Ã¦Ã'"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_existing_atom(string) <response> Converts a string to an existing atom.\n\nThe maximum atom size is of 255 Unicode code points.\nRaises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `String.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.\n\n## Examples\n\n    iex> _ = :my_atom\n    iex> String.to_existing_atom(\"my_atom\")\n    :my_atom"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_float(string) <response> Returns a float whose text representation is `string`.\n\n`string` must be the string representation of a float including a decimal point.\nIn order to parse a string without decimal point as a float then `Float.parse/1`\nshould be used. Otherwise, an `ArgumentError` will be raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_float(\"2.2017764e+0\")\n    2.2017764\n\n    iex> String.to_float(\"3.0\")\n    3.0\n\n    String.to_float(\"3\")\n    ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_integer(string) <response> Returns an integer whose text representation is `string`.\n\n`string` must be the string representation of an integer.\nOtherwise, an `ArgumentError` will be raised. If you want\nto parse a string that may contain an ill-formatted integer,\nuse `Integer.parse/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"123\")\n    123\n\nPassing a string that does not represent an integer leads to an error:\n\n    String.to_integer(\"invalid data\")\n    ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_integer(string, base) <response> Returns an integer whose text representation is `string` in base `base`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"3FF\", 16)\n    1023"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim(string) <response> Returns a string where all leading and trailing Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim(\"\\n  abc\\n  \")\n    \"abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim(string, to_trim) <response> Returns a string where all leading and trailing `to_trim` characters have been\nremoved.\n\n## Examples\n\n    iex> String.trim(\"a  abc  a\", \"a\")\n    \"  abc  \""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_leading(string) <response> Returns a string where all leading Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"\\n  abc   \")\n    \"abc   \""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_leading(string, to_trim) <response> Returns a string where all leading `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"__ abc _\", \"_\")\n    \" abc _\"\n\n    iex> String.trim_leading(\"1 abc\", \"11\")\n    \"1 abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_trailing(string) <response> Returns a string where all trailing Unicode whitespaces\nhas been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"   abc\\n  \")\n    \"   abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_trailing(string, to_trim) <response> Returns a string where all trailing `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"_ abc __\", \"_\")\n    \"_ abc \"\n\n    iex> String.trim_trailing(\"abc 1\", \"11\")\n    \"abc 1\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.upcase(string, mode \\\\ :default) <response> Converts all characters in the given string to uppercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nuppercases only the letters a to z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.upcase(\"abcd\")\n    \"ABCD\"\n\n    iex> String.upcase(\"ab 123 xpto\")\n    \"AB 123 XPTO\"\n\n    iex> String.upcase(\"olÃ¡\")\n    \"OLÃ\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.upcase(\"olÃ¡\", :ascii)\n    \"OLÃ¡\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.upcase(\"Ä±i\")\n    \"II\"\n\n    iex> String.upcase(\"Ä±i\", :turkic)\n    \"IÄ°\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.valid?(string) <response> Checks whether `string` contains only valid characters.\n\n## Examples\n\n    iex> String.valid?(\"a\")\n    true\n\n    iex> String.valid?(\"Ã¸\")\n    true\n\n    iex> String.valid?(<<0xFFFF::16>>)\n    false\n\n    iex> String.valid?(<<0xEF, 0xB7, 0x90>>)\n    true\n\n    iex> String.valid?(\"asd\" <> <<0xFFFF::16>>)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Strings in Elixir are UTF-8 encoded binaries.\n\nStrings in Elixir are a sequence of Unicode characters,\ntypically written between double quoted strings, such\nas `\"hello\"` and `\"hÃ©llÃ²\"`.\n\nIn case a string must have a double-quote in itself,\nthe double quotes must be escaped with a backslash,\nfor example: `\"this is a string with \\\"double quotes\\\"\"`.\n\nYou can concatenate two strings with the `<>/2` operator:\n\n    iex> \"hello\" <> \" \" <> \"world\"\n    \"hello world\"\n\nThe functions in this module act according to\n[The Unicode Standard, Version 14.0.0](http://www.unicode.org/versions/Unicode14.0.0/)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Interpolation\n\nStrings in Elixir also support interpolation. This allows\nyou to place some value in the middle of a string by using\nthe `#{}` syntax:\n\n    iex> name = \"joe\"\n    iex> \"hello #{name}\"\n    \"hello joe\"\n\nAny Elixir expression is valid inside the interpolation.\nIf a string is given, the string is interpolated as is.\nIf any other value is given, Elixir will attempt to convert\nit to a string using the `String.Chars` protocol. This\nallows, for example, to output an integer from the interpolation:\n\n    iex> \"2 + 2 = #{2 + 2}\"\n    \"2 + 2 = 4\"\n\nIn case the value you want to interpolate cannot be\nconverted to a string, because it doesn't have a human\ntextual representation, a protocol error will be raised."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Escape characters\n\nBesides allowing double-quotes to be escaped with a backslash,\nstrings also support the following escape characters:\n\n  * `\\0` - Null byte\n  * `\\a` - Bell\n  * `\\b` - Backspace\n  * `\\t` - Horizontal tab\n  * `\\n` - Line feed (New lines)\n  * `\\v` - Vertical tab\n  * `\\f` - Form feed\n  * `\\r` - Carriage return\n  * `\\e` - Command Escape\n  * `\\s` - Space\n  * `\\#` - Returns the `#` character itself, skipping interpolation\n  * `\\\\` - Single backslash\n  * `\\xNN` - A byte represented by the hexadecimal `NN`\n  * `\\uNNNN` - A Unicode code point represented by `NNNN`\n\nNote it is generally not advised to use `\\xNN` in Elixir\nstrings, as introducing an invalid byte sequence would\nmake the string invalid. If you have to introduce a\ncharacter by its hexadecimal representation, it is best\nto work with Unicode code points, such as `\\uNNNN`. In fact,\nunderstanding Unicode code points can be essential when doing\nlow-level manipulations of string, so let's explore them in\ndetail next."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Unicode and code points\n\nIn order to facilitate meaningful communication between computers\nacross multiple languages, a standard is required so that the ones\nand zeros on one machine mean the same thing when they are transmitted\nto another. The Unicode Standard acts as an official registry of\nvirtually all the characters we know: this includes characters from\nclassical and historical texts, emoji, and formatting and control\ncharacters as well.\n\nUnicode organizes all of the characters in its repertoire into code\ncharts, and each character is given a unique numerical index. This\nnumerical index is known as a Code Point.\n\nIn Elixir you can use a `?` in front of a character literal to reveal\nits code point:\n\n    iex> ?a\n    97\n    iex> ?Å\n    322\n\nNote that most Unicode code charts will refer to a code point by its\nhexadecimal (hex) representation, e.g. `97` translates to `0061` in hex,\nand we can represent any Unicode character in an Elixir string by\nusing the `\\u` escape character followed by its code point number:\n\n    iex> \"\\u0061\" === \"a\"\n    true\n    iex> 0x0061 = 97 = ?a\n    97\n\nThe hex representation will also help you look up information about a\ncode point, e.g. [https://codepoints.net/U+0061](https://codepoints.net/U+0061)\nhas a data sheet all about the lower case `a`, a.k.a. code point 97.\nRemember you can get the hex presentation of a number by calling\n`Integer.to_string/2`:\n\n    iex> Integer.to_string(?a, 16)\n    \"61\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> UTF-8 encoded and encodings\n\nNow that we understand what the Unicode standard is and what code points\nare, we can finally talk about encodings. Whereas the code point is **what**\nwe store, an encoding deals with **how** we store it: encoding is an\nimplementation. In other words, we need a mechanism to convert the code\npoint numbers into bytes so they can be stored in memory, written to disk, and such.\n\nElixir uses UTF-8 to encode its strings, which means that code points are\nencoded as a series of 8-bit bytes. UTF-8 is a **variable width** character\nencoding that uses one to four bytes to store each code point. It is capable\nof encoding all valid Unicode code points. Let's see an example:\n\n    iex> string = \"hÃ©llo\"\n    \"hÃ©llo\"\n    iex> String.length(string)\n    5\n    iex> byte_size(string)\n    6\n\nAlthough the string above has 5 characters, it uses 6 bytes, as two bytes\nare used to represent the character `Ã©`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Grapheme clusters\n\nThis module also works with the concept of grapheme cluster\n(from now on referenced as graphemes). Graphemes can consist\nof multiple code points that may be perceived as a single character\nby readers. For example, \"Ã©\" can be represented either as a single\n\"e with acute\" code point, as seen above in the string `\"hÃ©llo\"`,\nor as the letter \"e\" followed by a \"combining acute accent\"\n(two code points):\n\n    iex> string = \"\\u0065\\u0301\"\n    \"eÌ\"\n    iex> byte_size(string)\n    3\n    iex> String.length(string)\n    1\n    iex> String.codepoints(string)\n    [\"e\", \"Ì\"]\n    iex> String.graphemes(string)\n    [\"eÌ\"]\n\nAlthough it looks visually the same as before, the example above\nis made of two characters, it is perceived by users as one.\n\nGraphemes can also be two characters that are interpreted as one\nby some languages. For example, some languages may consider \"ch\"\nas a single character. However, since this information depends on\nthe locale, it is not taken into account by this module.\n\nIn general, the functions in this module rely on the Unicode\nStandard, but do not contain any of the locale specific behaviour.\nMore information about graphemes can be found in the [Unicode\nStandard Annex #29](https://www.unicode.org/reports/tr29/).\n\nFor converting a binary to a different encoding and for Unicode\nnormalization mechanisms, see Erlang's `:unicode` module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> String and binary operations\n\nTo act according to the Unicode Standard, many functions\nin this module run in linear time, as they need to traverse\nthe whole string considering the proper Unicode code points.\n\nFor example, `String.length/1` will take longer as\nthe input grows. On the other hand, `Kernel.byte_size/1` always runs\nin constant time (i.e. regardless of the input size).\n\nThis means often there are performance costs in using the\nfunctions in this module, compared to the more low-level\noperations that work directly with binaries:\n\n  * `Kernel.binary_part/3` - retrieves part of the binary\n  * `Kernel.bit_size/1` and `Kernel.byte_size/1` - size related functions\n  * `Kernel.is_bitstring/1` and `Kernel.is_binary/1` - type-check function\n  * Plus a number of functions for working with binaries (bytes)\n    in the [`:binary` module](`:binary`)\n\nA `utf8` modifier is also available inside the binary syntax `<<>>`.\nIt can be used to match code points out of a binary/string:\n\n    iex> <<eacute::utf8>> = \"Ã©\"\n    iex> eacute\n    233\n\nYou can also fully convert a string into a list of integer code points,\nknown as \"charlists\" in Elixir, by calling `String.to_charlist/1`:\n\n    iex> String.to_charlist(\"hÃ©llo\")\n    [104, 233, 108, 108, 111]\n\nIf you would rather see the underlying bytes of a string, instead of\nits codepoints, a common trick is to concatenate the null byte `<<0>>`\nto it:\n\n    iex> \"hÃ©llo\" <> <<0>>\n    <<104, 195, 169, 108, 108, 111, 0>>\n\nAlternatively, you can view a string's binary representation by\npassing an option to `IO.inspect/2`:\n\n    IO.inspect(\"hÃ©llo\", binaries: :as_binaries)\n    #=> <<104, 195, 169, 108, 108, 111>>"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Self-synchronization\n\nThe UTF-8 encoding is self-synchronizing. This means that\nif malformed data (i.e., data that is not possible according\nto the definition of the encoding) is encountered, only one\ncode point needs to be rejected.\n\nThis module relies on this behaviour to ignore such invalid\ncharacters. For example, `length/1` will return\na correct result even if an invalid code point is fed into it.\n\nIn other words, this module expects invalid data to be detected\nelsewhere, usually when retrieving data from the external source.\nFor example, a driver that reads strings from a database will be\nresponsible to check the validity of the encoding. `String.chunk/2`\ncan be used for breaking a string into valid and invalid parts."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Compile binary patterns\n\nMany functions in this module work with patterns. For example,\n`String.split/3` can split a string into multiple strings given\na pattern. This pattern can be a string, a list of strings or\na compiled pattern:\n\n    iex> String.split(\"foo bar\", \" \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo bar!\", [\" \", \"!\"])\n    [\"foo\", \"bar\", \"\"]\n\n    iex> pattern = :binary.compile_pattern([\" \", \"!\"])\n    iex> String.split(\"foo bar!\", pattern)\n    [\"foo\", \"bar\", \"\"]\n\nThe compiled pattern is useful when the same match will\nbe done over and over again. Note though that the compiled\npattern cannot be stored in a module attribute as the pattern\nis generated at runtime and does not survive compile time."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.close(pid) <response> Stops the IO device and returns the remaining input/output\nbuffers.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.close(pid)\n    {:ok, {\"in\", \"out\"}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.contents(pid) <response> Returns the current input/output buffers for the given IO\ndevice.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.contents(pid)\n    {\"in\", \"out\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.flush(pid) <response> Flushes the output buffer and returns its current contents.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.flush(pid)\n    \"out\"\n    iex> StringIO.contents(pid)\n    {\"in\", \"\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.open(string, options_or_function \\\\ []) <response> Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\n`options_or_function` can be a keyword list of options or\na function.\n\nIf options are provided, the result will be `{:ok, pid}`, returning the\nIO device created. The option `:capture_prompt`, when set to `true`, causes\nprompts (which are specified as arguments to `IO.get*` functions) to be\nincluded in the device's output.\n\nIf a function is provided, the device will be created and sent to the\nfunction. When the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"foo\")\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \"\"}\n\n    iex> {:ok, pid} = StringIO.open(\"foo\", capture_prompt: true)\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \">\"}\n\n    iex> StringIO.open(\"foo\", fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.open(string, options, function) <response> Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\nThe device will be created and sent to the function given.\nWhen the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.\n\n## Options\n\n  * `:capture_prompt` - if set to `true`, prompts (specified as\n    arguments to `IO.get*` functions) are captured in the output.\n    Defaults to `false`.\n\n  * `:encoding` (since v1.10.0) - encoding of the IO device. Allowed\n    values are `:unicode` (default) and `:latin1`.\n\n## Examples\n\n    iex> StringIO.open(\"foo\", [], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}\n\n    iex> StringIO.open(\"foo\", [capture_prompt: true], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \">The input was foo\"}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.Elixir.StringIO <response> Controls an IO device process that wraps a string.\n\nA `StringIO` IO device can be passed as a \"device\" to\nmost of the functions in the `IO` module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.Elixir.StringIO <response> Examples\n\n    iex> {:ok, pid} = StringIO.open(\"foo\")\n    iex> IO.read(pid, 2)\n    \"fo\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.supervise(children, options) <response> Receives a list of `children` (workers or supervisors) to\nsupervise and a set of `options`.\n\nReturns a tuple containing the supervisor specification. This tuple can be\nused as the return value of the `c:Supervisor.init/1` callback when implementing a\nmodule-based supervisor.\n\n## Examples\n\n    supervise(children, strategy: :one_for_one)\n\n## Options\n\n  * `:strategy` - the restart strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, `:one_for_all`, or\n    `:simple_one_for_one`. You can learn more about strategies\n    in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\nThe `:strategy` option is required and by default a maximum of 3 restarts is\nallowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.supervisor(module, args, options \\\\ []) <response> Defines the given `module` as a supervisor which will be started\nwith the given arguments.\n\n    supervisor(module, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: :infinity,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.worker(module, args, options \\\\ []) <response> Defines the given `module` as a worker which will be started\nwith the given arguments.\n\n    worker(ExUnit.Runner, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: 5000,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.Elixir.Supervisor.Spec <response> Outdated functions for building child specifications.\n\nThe functions in this module are deprecated and they do not work\nwith the module-based child specs introduced in Elixir v1.5.\nPlease see the `Supervisor` documentation instead.\n\nConvenience functions for defining supervisor specifications."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.Elixir.Supervisor.Spec <response> Example\n\nBy using the functions in this module one can specify the children\nto be used under a supervisor, started with `Supervisor.start_link/2`:\n\n    import Supervisor.Spec\n\n    children = [\n      worker(MyWorker, [arg1, arg2, arg3]),\n      supervisor(MySupervisor, [arg1])\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nSometimes, it may be handy to define supervisors backed\nby a module:\n\n    defmodule MySupervisor do\n      use Supervisor\n\n      def start_link(arg) do\n        Supervisor.start_link(__MODULE__, arg)\n      end\n\n      def init(arg) do\n        children = [\n          worker(MyWorker, [arg], restart: :temporary)\n        ]\n\n        supervise(children, strategy: :simple_one_for_one)\n      end\n    end\n\nNote that in this case we don't have to explicitly import\n`Supervisor.Spec` since `use Supervisor` automatically does so.\nDefining a module-based supervisor can be useful, for example,\nto perform initialization tasks in the `c:Supervisor.init/1` callback."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.Elixir.Supervisor.Spec <response> Supervisor and worker options\n\nIn the example above, we defined specs for workers and supervisors.\nThese specs (both for workers as well as supervisors) accept the\nfollowing options:\n\n  * `:id` - a name used to identify the child specification\n    internally by the supervisor; defaults to the given module\n    name for the child worker/supervisor\n\n  * `:function` - the function to invoke on the child to start it\n\n  * `:restart` - an atom that defines when a terminated child process should\n    be restarted (see the \"Restart values\" section below)\n\n  * `:shutdown` - an atom that defines how a child process should be\n    terminated (see the \"Shutdown values\" section below)\n\n  * `:modules` - it should be a list with one element `[module]`,\n    where module is the name of the callback module only if the\n    child process is a `Supervisor` or `GenServer`; if the child\n    process is a `GenEvent`, `:modules` should be `:dynamic`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.Elixir.Supervisor.Spec <response> # Restart values (:restart)\n\nThe following restart values are supported in the `:restart` option:\n\n  * `:permanent` - the child process is always restarted\n\n  * `:temporary` - the child process is never restarted (not even\n    when the supervisor's strategy is `:rest_for_one` or `:one_for_all`)\n\n  * `:transient` - the child process is restarted only if it\n    terminates abnormally, i.e., with an exit reason other than\n    `:normal`, `:shutdown` or `{:shutdown, term}`\n\nNote that supervisor that reached maximum restart intensity will exit with `:shutdown` reason.\nIn this case the supervisor will only restart if its child specification was defined with\nthe `:restart` option set to `:permanent` (the default)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.Elixir.Supervisor.Spec <response> # Shutdown values (`:shutdown`)\n\nThe following shutdown values are supported in the `:shutdown` option:\n\n  * `:brutal_kill` - the child process is unconditionally terminated\n    using `Process.exit(child, :kill)`\n\n  * `:infinity` - if the child process is a supervisor, this is a mechanism\n    to give the subtree enough time to shut down; it can also be used with\n    workers with care\n\n  * a non-negative integer - the amount of time in milliseconds\n    that the supervisor tells the child process to terminate by calling\n    `Process.exit(child, :shutdown)` and then waits for an exit signal back.\n    If no exit signal is received within the specified time,\n    the child process is unconditionally terminated\n    using `Process.exit(child, :kill)`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.child_spec(module_or_map, overrides) <response> Builds and overrides a child specification.\n\nSimilar to `start_link/2` and `init/2`, it expects a module, `{module, arg}`,\nor a [child specification](`t:child_spec/0`).\n\nIf a two-element tuple in the shape of `{module, arg}` is given,\nthe child specification is retrieved by calling `module.child_spec(arg)`.\n\nIf a module is given, the child specification is retrieved by calling\n`module.child_spec([])`.\n\nAfter the child specification is retrieved, the fields on `overrides`\nare directly applied on the child spec. If `overrides` has keys that\ndo not map to any child specification field, an error is raised.\n\nSee the \"Child specification\" section in the module documentation\nfor all of the available keys for overriding.\n\n## Examples\n\nThis function is often used to set an `:id` option when\nthe same module needs to be started multiple times in the\nsupervision tree:\n\n    Supervisor.child_spec({Agent, fn -> :ok end}, id: {Agent, 1})\n    #=> %{id: {Agent, 1},\n    #=>   start: {Agent, :start_link, [fn -> :ok end]}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.count_children(supervisor) <response> Returns a map containing count values for the given supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the total count of children, dead or alive\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not these\n    child supervisors are still alive\n\n  * `:workers` - the count of all workers, whether or not these child workers\n    are still alive"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.delete_child(supervisor, child_id) <response> Deletes the child specification identified by `child_id`.\n\nThe corresponding child process must not be running; use `terminate_child/2`\nto terminate it if it's running.\n\nIf successful, this function returns `:ok`. This function may return an error\nwith an appropriate error tuple if the `child_id` is not found, or if the\ncurrent process is running or being restarted."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.init(children, options) <response> Receives a list of child specifications to initialize and a set of `options`.\n\nThis is typically invoked at the end of the `c:init/1` callback of\nmodule-based supervisors. See the sections \"Supervisor strategies and options\" and\n\"Module-based supervisors\" in the module documentation for more information.\n\nThis function returns a tuple containing the supervisor\nflags and child specifications.\n\n## Examples\n\n    def init(_init_arg) do\n      children = [\n        {Counter, 0}\n      ]\n\n      Supervisor.init(children, strategy: :one_for_one)\n    end\n\n## Options\n\n  * `:strategy` - the supervision strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, or `:one_for_all`\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in seconds in which `:max_restarts`\n    applies. Defaults to `5`.\n\nThe `:strategy` option is required and by default a maximum of 3 restarts\nis allowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.restart_child(supervisor, child_id) <response> Restarts a child process identified by `child_id`.\n\nThe child specification must exist and the corresponding child process must not\nbe running.\n\nNote that for temporary children, the child specification is automatically deleted\nwhen the child terminates, and thus it is not possible to restart such children.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child, info}`,\nthe PID is added to the supervisor and this function returns the same value.\n\nIf the child process start function returns `:ignore`, the PID remains set to\n`:undefined` and this function returns `{:ok, :undefined}`.\n\nThis function may return an error with an appropriate error tuple if the\n`child_id` is not found, or if the current process is running or being\nrestarted.\n\nIf the child process start function returns an error tuple or an erroneous value,\nor if it fails, this function returns `{:error, error}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.start_child(supervisor, child_spec) <response> Adds a child specification to `supervisor` and starts that child.\n\n`child_spec` should be a valid child specification. The child process will\nbe started as defined in the child specification.\n\nIf a child specification with the specified ID already exists, `child_spec` is\ndiscarded and this function returns an error with `:already_started` or\n`:already_present` if the corresponding child process is running or not,\nrespectively.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child,\ninfo}`, then child specification and PID are added to the supervisor and\nthis function returns the same value.\n\nIf the child process start function returns `:ignore`, the child specification\nis added to the supervisor, the PID is set to `:undefined` and this function\nreturns `{:ok, :undefined}`.\n\nIf the child process start function returns an error tuple or an erroneous\nvalue, or if it fails, the child specification is discarded and this function\nreturns `{:error, error}` where `error` is a term containing information about\nthe error and child specification."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.start_link(children, options) <response> Starts a supervisor with the given children.\n\n`children` is a list of the following forms:\n\n  * a [child specification](`t:child_spec/0`)\n\n  * a module, where `module.child_spec([])` will be invoked to retrieve\n    its child specification\n\n  * a two-element tuple in the shape of `{module, arg}`, where `module.child_spec(arg)`\n    will be invoked to retrieve its child specification\n\nA strategy is required to be provided through the `:strategy` option. See\n\"Supervisor strategies and options\" for examples and other options.\n\nThe options can also be used to register a supervisor name.\nThe supported values are described under the \"Name registration\"\nsection in the `GenServer` module docs.\n\nIf the supervisor and all child processes are successfully spawned\n(if the start function of each child process returns `{:ok, child}`,\n`{:ok, child, info}`, or `:ignore`), this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nIf the start function of any of the child processes fails or returns an error\ntuple or an erroneous value, the supervisor first terminates with reason\n`:shutdown` all the child processes that have already been started, and then\nterminates itself and returns `{:error, {:shutdown, reason}}`.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.start_link(module, init_arg, options \\\\ []) <response> Starts a module-based supervisor process with the given `module` and `init_arg`.\n\nTo start the supervisor, the `c:init/1` callback will be invoked in the given\n`module`, with `init_arg` as its argument. The `c:init/1` callback must return a\nsupervisor specification which can be created with the help of the `init/2`\nfunction.\n\nIf the `c:init/1` callback returns `:ignore`, this function returns\n`:ignore` as well and the supervisor terminates with reason `:normal`.\nIf it fails or returns an incorrect value, this function returns\n`{:error, term}` where `term` is a term with information about the\nerror, and the supervisor terminates with reason `term`.\n\nThe `:name` option can also be given in order to register a supervisor\nname, the supported values are described in the \"Name registration\"\nsection in the `GenServer` module docs."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.stop(supervisor, reason \\\\ :normal, timeout \\\\ :infinity) <response> Synchronously stops the given supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.terminate_child(supervisor, child_id) <response> Terminates the given child identified by `child_id`.\n\nThe process is terminated, if there's one. The child specification is\nkept unless the child is temporary.\n\nA non-temporary child process may later be restarted by the supervisor.\nThe child process can also be restarted explicitly by calling `restart_child/2`.\nUse `delete_child/2` to remove the child specification.\n\nIf successful, this function returns `:ok`. If there is no child\nspecification for the given child ID, this function returns\n`{:error, :not_found}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.which_children(supervisor) <response> Returns a list with information about all children of the given supervisor.\n\nNote that calling this function when supervising a large number of children\nunder low memory conditions can cause an out of memory exception.\n\nThis function returns a list of `{id, child, type, modules}` tuples, where:\n\n  * `id` - as defined in the child specification\n\n  * `child` - the PID of the corresponding child process, `:restarting` if the\n    process is about to be restarted, or `:undefined` if there is no such\n    process\n\n  * `type` - `:worker` or `:supervisor`, as specified by the child specification\n\n  * `modules` - as specified by the child specification"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> A behaviour module for implementing supervisors.\n\nA supervisor is a process which supervises other processes, which we\nrefer to as *child processes*. Supervisors are used to build a hierarchical\nprocess structure called a *supervision tree*. Supervision trees provide\nfault-tolerance and encapsulate how our applications start and shutdown.\n\nA supervisor may be started directly with a list of child specifications via\n`start_link/2` or you may define a module-based supervisor that implements\nthe required callbacks. The sections below use `start_link/2` to start\nsupervisors in most examples, but it also includes a specific section\non module-based ones."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Examples\n\nIn order to start a supervisor, we need to first define a child process\nthat will be supervised. As an example, we will define a `GenServer`,\na generic server, that keeps a counter. Other processes can then send\nmessages to this process to read the counter and bump its value.\n\n> Note: in practice you would not define a counter as a GenServer. Instead,\n> if you need a counter, you would pass it around as inputs and outputs to\n> the functions that need it. The reason we picked a counter in this example\n> is due to its simplicity, as it allows us to focus on how supervisors work.\n\n    defmodule Counter do\n      use GenServer\n\n      def start_link(arg) when is_integer(arg) do\n        GenServer.start_link(__MODULE__, arg, name: __MODULE__)\n      end\n\n      ## Callbacks\n\n      @impl true\n      def init(counter) do\n        {:ok, counter}\n      end\n\n      @impl true\n      def handle_call(:get, _from, counter) do\n        {:reply, counter, counter}\n      end\n\n      def handle_call({:bump, value}, _from, counter) do\n        {:reply, counter, counter + value}\n      end\n    end\n\nThe `Counter` receives an argument on `start_link`. This argument\nis passed to the `init/1` callback which becomes the initial value\nof the counter. Our counter handles two operations (known as calls):\n`:get`, to get the current counter value, and `:bump`, that bumps\nthe counter by the given `value` and returns the old counter.\n\nWe can now start a supervisor that will start and supervise our\ncounter process. The first step is to define a list of **child\nspecifications** that control how each child behaves. Each child\nspecification is a map, as shown below:\n\n    children = [\n      # The Counter is a child started via Counter.start_link(0)\n      %{\n        id: Counter,\n        start: {Counter, :start_link, [0]}\n      }\n    ]\n\n    # Now we start the supervisor with the children and a strategy\n    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n\n    # After started, we can query the supervisor for information\n    Supervisor.count_children(pid)\n    #=> %{active: 1, specs: 1, supervisors: 0, workers: 1}\n\nNote that when starting the GenServer, we are registering it\nwith name `Counter` via the `name: __MODULE__` option. This allows\nus to call it directly and get its value:\n\n    GenServer.call(Counter, :get)\n    #=> 0\n\n    GenServer.cast(Counter, {:bump, 3})\n    #=> 0\n\n    GenServer.call(Counter, :get)\n    #=> 3\n\nHowever, there is a bug in our counter server. If we call `:bump` with\na non-numeric value, it is going to crash:\n\n    GenServer.call(Counter, {:bump, \"oops\"})\n    ** (exit) exited in: GenServer.call(Counter, {:bump, \"oops\"}, 5000)\n\nLuckily, since the server is being supervised by a supervisor, the\nsupervisor will automatically start a new one, reset back to its initial\nvalue of `0`:\n\n    GenServer.call(Counter, :get)\n    #=> 0\n\nSupervisors support different strategies; in the example above, we\nhave chosen `:one_for_one`. Furthermore, each supervisor can have many\nworkers and/or supervisors as children, with each one having its own\nconfiguration (as outlined in the \"Child specification\" section).\n\nThe rest of this document will cover how child processes are specified,\nhow they can be started and stopped, different supervision strategies\nand more."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Child specification\n\nThe child specification describes how the supervisor starts, shuts down,\nand restarts child processes.\n\nThe child specification is a map containing up to 6 elements. The first two keys\nin the following list are required, and the remaining ones are optional:\n\n  * `:id` - any term used to identify the child specification internally by\n    the supervisor; defaults to the given module. This key is required.\n    For supervisors, in the case of conflicting `:id` values, the supervisor\n    will refuse to initialize and require explicit IDs. This is not the case\n    for [dynamic supervisors](`DynamicSupervisor`) though.\n\n  * `:start` - a tuple with the module-function-args to be invoked\n    to start the child process. This key is required.\n\n  * `:restart` - an atom that defines when a terminated child process\n     should be restarted (see the \"Restart values\" section below).\n     This key is optional and defaults to `:permanent`.\n\n  * `:shutdown` - an integer or atom that defines how a child process should\n    be terminated (see the \"Shutdown values\" section below). This key\n    is optional and defaults to `5_000` if the type is `:worker` or\n    `:infinity` if the type is `:supervisor`.\n\n  * `:type` - specifies that the child process is a `:worker` or a\n    `:supervisor`. This key is optional and defaults to `:worker`.\n\n  * `:modules` - a list of modules used by hot code upgrade mechanisms\n    to determine which processes are using certain modules. It is typically\n    set to the callback module of behaviours like `GenServer`, `Supervisor`,\n    and such. It is set automatically based on the `:start` value and it is rarely\n    changed in practice.\n\nLet's understand what the `:shutdown` and `:restart` options control."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> # Shutdown values (:shutdown)\n\nThe following shutdown values are supported in the `:shutdown` option:\n\n  * `:brutal_kill` - the child process is unconditionally and immediately\n    terminated using `Process.exit(child, :kill)`.\n\n  * any integer >= 0 - the amount of time in milliseconds that the\n    supervisor will wait for its children to terminate after emitting a\n    `Process.exit(child, :shutdown)` signal. If the child process is\n    not trapping exits, the initial `:shutdown` signal will terminate\n    the child process immediately. If the child process is trapping\n    exits, it has the given amount of time to terminate.\n    If it doesn't terminate within the specified time, the child process\n    is unconditionally terminated by the supervisor via\n    `Process.exit(child, :kill)`.\n\n  * `:infinity` - works as an integer except the supervisor will wait\n    indefinitely for the child to terminate. If the child process is a\n    supervisor, the recommended value is `:infinity` to give the supervisor\n    and its children enough time to shut down. This option can be used with\n    regular workers but doing so is discouraged and requires extreme care.\n    If not used carefully, the child process will never terminate,\n    preventing your application from terminating as well."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> # Restart values (:restart)\n\nThe `:restart` option controls what the supervisor should consider to\nbe a successful termination or not. If the termination is successful,\nthe supervisor won't restart the child. If the child process crashed,\nthe supervisor will start a new one.\n\nThe following restart values are supported in the `:restart` option:\n\n  * `:permanent` - the child process is always restarted.\n\n  * `:temporary` - the child process is never restarted, regardless\n    of the supervision strategy: any termination (even abnormal) is\n    considered successful.\n\n  * `:transient` - the child process is restarted only if it\n    terminates abnormally, i.e., with an exit reason other than\n    `:normal`, `:shutdown`, or `{:shutdown, term}`.\n\nFor a more complete understanding of the exit reasons and their\nimpact, see the \"Exit reasons and restarts\" section."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> `child_spec/1` function\n\nWhen starting a supervisor, we may pass a list of child specifications. Those\nspecifications are maps that tell how the supervisor should start, stop and\nrestart each of its children:\n\n    %{\n      id: Counter,\n      start: {Counter, :start_link, [0]}\n    }\n\nThe map above defines a child with `:id` of `Counter` that is started\nby calling `Counter.start_link(0)`.\n\nHowever, defining the child specification for each child as a map can be\nquite error prone, as we may change the `Counter` implementation and forget\nto update its specification. That's why Elixir allows you to pass a tuple with\nthe module name and the `start_link` argument instead of the specification:\n\n    children = [\n      {Counter, 0}\n    ]\n\nThe supervisor will then invoke `Counter.child_spec(0)` to retrieve a child\nspecification. Now the `Counter` module is responsible for building its own\nspecification, for example, we could write:\n\n    def child_spec(arg) do\n      %{\n        id: Counter,\n        start: {Counter, :start_link, [arg]}\n      }\n    end\n\nLuckily for us, `use GenServer` already defines a `Counter.child_spec/1`\nexactly like above, so you don't need to write the definition above yourself.\nIf you want to customize the automatically generated `child_spec/1` function,\nyou can pass the options directly to `use GenServer`:\n\n    use GenServer, restart: :transient\n\nFinally, note it is also possible to simply pass the `Counter` module as\na child:\n\n    children = [\n      Counter\n    ]\n\nWhen only the module name is given, it is equivalent to `{Counter, []}`,\nwhich in our case would be invalid, which is why we always pass the initial\ncounter explicitly.\n\nBy replacing the child specification with `{Counter, 0}`, we keep it\nencapsulated in the `Counter` module. We could now share our\n`Counter` implementation with other developers and they can add it directly\nto their supervision tree without worrying about the low-level details of\nthe counter.\n\nOverall, a child specification can be one of the following:\n\n  * a map representing the child specification itself - as outlined in the\n    \"Child specification\" section\n\n  * a tuple with a module as first element and the start argument as second -\n    such as `{Counter, 0}`. In this case, `Counter.child_spec(0)` is called\n    to retrieve the child specification\n\n  * a module - such as `Counter`. In this case, `Counter.child_spec([])`\n    would be called, which is invalid for the counter, but it is useful in\n    many other cases, especially when you want to pass a list of options\n    to the child process\n\nIf you need to convert a `{module, arg}` tuple or a module child specification to a\n[child specification](`t:child_spec/0`) or modify a child specification itself,\nyou can use the `Supervisor.child_spec/2` function.\nFor example, to run the counter with a different `:id` and a `:shutdown` value of\n10 seconds (10_000 milliseconds):\n\n    children = [\n      Supervisor.child_spec({Counter, 0}, id: MyCounter, shutdown: 10_000)\n    ]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Supervisor strategies and options\n\nSo far we have started the supervisor passing a single child as a tuple\nas well as a strategy called `:one_for_one`:\n\n    children = [\n      {Counter, 0}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe first argument given to `start_link/2` is a list of child\nspecifications as defined in the \"child_spec/1\" section above.\n\nThe second argument is a keyword list of options:\n\n  * `:strategy` - the supervision strategy option. It can be either\n    `:one_for_one`, `:rest_for_one` or `:one_for_all`. Required.\n    See the \"Strategies\" section.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:name` - a name to register the supervisor process. Supported values are\n    explained in the \"Name registration\" section in the documentation for\n    `GenServer`. Optional."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> # Strategies\n\nSupervisors support different supervision strategies (through the\n`:strategy` option, as seen above):\n\n  * `:one_for_one` - if a child process terminates, only that\n    process is restarted.\n\n  * `:one_for_all` - if a child process terminates, all other child\n    processes are terminated and then all child processes (including\n    the terminated one) are restarted.\n\n  * `:rest_for_one` - if a child process terminates, the terminated child\n    process and the rest of the children started after it, are terminated and\n    restarted.\n\nIn the above, process termination refers to unsuccessful termination, which\nis determined by the `:restart` option.\n\nTo efficiently supervise children started dynamically, see `DynamicSupervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> # Name registration\n\nA supervisor is bound to the same name registration rules as a `GenServer`.\nRead more about these rules in the documentation for `GenServer`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Module-based supervisors\n\nIn the example so far, the supervisor was started by passing the supervision\nstructure to `start_link/2`. However, supervisors can also be created by\nexplicitly defining a supervision module:\n\n    defmodule MyApp.Supervisor do\n      # Automatically defines child_spec/1\n      use Supervisor\n\n      def start_link(init_arg) do\n        Supervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      @impl true\n      def init(_init_arg) do\n        children = [\n          {Counter, 0}\n        ]\n\n        Supervisor.init(children, strategy: :one_for_one)\n      end\n    end\n\nThe difference between the two approaches is that a module-based\nsupervisor gives you more direct control over how the supervisor\nis initialized. Instead of calling `Supervisor.start_link/2` with\na list of child specifications that are automatically initialized, we manually\ninitialize the children by calling `Supervisor.init/2` inside its\n`c:init/1` callback. `Supervisor.init/2` accepts the same `:strategy`,\n`:max_restarts`, and `:max_seconds` options as `start_link/2`.\n\n`use Supervisor` also defines a `child_spec/1` function which allows\nus to run `MyApp.Supervisor` as a child of another supervisor or\nat the top of your supervision tree as:\n\n    children = [\n      MyApp.Supervisor\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nA general guideline is to use the supervisor without a callback\nmodule only at the top of your supervision tree, generally in the\n`c:Application.start/2` callback. We recommend using module-based\nsupervisors for any other supervisor in your application, so they\ncan run as a child of another supervisor in the tree. The `child_spec/1`\ngenerated automatically by `Supervisor` can be customized with the\nfollowing options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the supervisor should be restarted, defaults to `:permanent`\n\nThe `@doc` annotation immediately preceding `use Supervisor` will be\nattached to the generated `child_spec/1` function."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Start and shutdown\n\nWhen the supervisor starts, it traverses all child specifications and\nthen starts each child in the order they are defined. This is done by\ncalling the function defined under the `:start` key in the child\nspecification and typically defaults to `start_link/1`.\n\nThe `start_link/1` (or a custom) is then called for each child process.\nThe `start_link/1` function must return `{:ok, pid}` where `pid` is the\nprocess identifier of a new process that is linked to the supervisor.\nThe child process usually starts its work by executing the `c:init/1`\ncallback. Generally speaking, the `init` callback is where we initialize\nand configure the child process.\n\nThe shutdown process happens in reverse order.\n\nWhen a supervisor shuts down, it terminates all children in the opposite\norder they are listed. The termination happens by sending a shutdown exit\nsignal, via `Process.exit(child_pid, :shutdown)`, to the child process and\nthen awaiting for a time interval for the child process to terminate. This\ninterval defaults to 5000 milliseconds. If the child process does not\nterminate in this interval, the supervisor abruptly terminates the child\nwith reason `:kill`. The shutdown time can be configured in the child\nspecification which is fully detailed in the next section.\n\nIf the child process is not trapping exits, it will shutdown immediately\nwhen it receives the first exit signal. If the child process is trapping\nexits, then the `terminate` callback is invoked, and the child process\nmust terminate in a reasonable time interval before being abruptly\nterminated by the supervisor.\n\nIn other words, if it is important that a process cleans after itself\nwhen your application or the supervision tree is shutting down, then\nthis process must trap exits and its child specification should specify\nthe proper `:shutdown` value, ensuring it terminates within a reasonable\ninterval."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Exit reasons and restarts\n\nA supervisor restarts a child process depending on its `:restart` configuration.\nFor example, when `:restart` is set to `:transient`, the supervisor does not\nrestart the child in case it exits with reason `:normal`, `:shutdown` or\n`{:shutdown, term}`.\n\nSo one may ask: which exit reason should I choose when exiting? There are\nthree options:\n\n  * `:normal` - in such cases, the exit won't be logged, there is no restart\n    in transient mode, and linked processes do not exit\n\n  * `:shutdown` or `{:shutdown, term}` - in such cases, the exit won't be\n    logged, there is no restart in transient mode, and linked processes exit\n    with the same reason unless they're trapping exits\n\n  * any other term - in such cases, the exit will be logged, there are\n    restarts in transient mode, and linked processes exit with the same\n    reason unless they're trapping exits\n\nNote that the supervisor that reaches maximum restart intensity will exit with\n`:shutdown` reason. In this case the supervisor will only be restarted if its\nchild specification was defined with the `:restart` option set to `:permanent`\n(the default)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.argv() <response> Lists command line arguments.\n\nReturns the list of command line arguments passed to the program."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.argv(args) <response> Modifies command line arguments.\n\nChanges the list of command line arguments. Use it with caution,\nas it destroys any previous argv information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.at_exit(fun) <response> Registers a program exit handler function.\n\nRegisters a function that will be invoked at the end of an Elixir script.\nA script is typically started via the command line via the `elixir` and\n`mix` executables.\n\nThe handler always executes in a different process from the one it was\nregistered in. As a consequence, any resources managed by the calling process\n(ETS tables, open files, and others) won't be available by the time the handler\nfunction is invoked.\n\nThe function must receive the exit status code as an argument.\n\nIf the VM terminates programmatically, via `System.stop/1`, `System.halt/1`,\nor exit signals, the `at_exit/1` callbacks are not executed."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.build_info() <response> Elixir build information.\n\nReturns a map with the Elixir version, the Erlang/OTP release it was compiled\nwith, a short Git revision hash and the date and time it was built.\n\nEvery value in the map is a string, and these are:\n\n  * `:build` - the Elixir version, short Git revision hash and\n    Erlang/OTP release it was compiled with\n  * `:date` - a string representation of the ISO8601 date and time it was built\n  * `:otp_release` - OTP release it was compiled with\n  * `:revision` - short Git revision hash. If Git was not available at building\n    time, it is set to `\"\"`\n  * `:version` - the Elixir version\n\nOne should not rely on the specific formats returned by each of those fields.\nInstead one should use specialized functions, such as `version/0` to retrieve\nthe Elixir version and `otp_release/0` to retrieve the Erlang/OTP release.\n\n## Examples\n\n    iex> System.build_info()\n    %{\n      build: \"1.9.0-dev (772a00a0c) (compiled with Erlang/OTP 21)\",\n      date: \"2018-12-24T01:09:21Z\",\n      otp_release: \"21\",\n      revision: \"772a00a0c\",\n      version: \"1.9.0-dev\"\n    }"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.cmd(command, args, opts \\\\ []) <response> Executes the given `command` with `args`.\n\n`command` is expected to be an executable available in PATH\nunless an absolute path is given.\n\n`args` must be a list of binaries which the executable will receive\nas its arguments as is. This means that:\n\n  * environment variables will not be interpolated\n  * wildcard expansion will not happen (unless `Path.wildcard/2` is used\n    explicitly)\n  * arguments do not need to be escaped or quoted for shell safety\n\nThis function returns a tuple containing the collected result\nand the command exit status.\n\nInternally, this function uses a `Port` for interacting with the\noutside world. However, if you plan to run a long-running program,\nports guarantee stdin/stdout devices will be closed but it does not\nautomatically terminate the program. The documentation for the\n`Port` module describes this problem and possible solutions under\nthe \"Zombie processes\" section.\n\n## Examples\n\n    iex> System.cmd(\"echo\", [\"hello\"])\n    {\"hello\\n\", 0}\n\n    iex> System.cmd(\"echo\", [\"hello\"], env: [{\"MIX_ENV\", \"test\"}])\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.cmd(\"echo\", [\"hello\"], into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}\n\n## Options\n\n  * `:into` - injects the result into the given collectable, defaults to `\"\"`\n  * `:cd` - the directory to run the command in\n  * `:env` - an enumerable of tuples containing environment key-value as\n    binary. The child process inherits all environment variables from its\n    parent process, the Elixir application, except those overwritten or\n    cleared using this option. Specify a value of `nil` to clear (unset) an\n    environment variable, which is useful for preventing credentials passed\n    to the application from leaking into child processes.\n  * `:arg0` - sets the command arg0\n  * `:stderr_to_stdout` - redirects stderr to stdout when `true`\n  * `:parallelism` - when `true`, the VM will schedule port tasks to improve\n    parallelism in the system. If set to `false`, the VM will try to perform\n    commands immediately, improving latency at the expense of parallelism.\n    The default can be set on system startup by passing the \"+spp\" argument\n    to `--erl`.\n\n## Error reasons\n\nIf invalid arguments are given, `ArgumentError` is raised by\n`System.cmd/3`. `System.cmd/3` also expects a strict set of\noptions and will raise if unknown or invalid options are given.\n\nFurthermore, `System.cmd/3` may fail with one of the POSIX reasons\ndetailed below:\n\n  * `:system_limit` - all available ports in the Erlang emulator are in use\n\n  * `:enomem` - there was not enough memory to create the port\n\n  * `:eagain` - there are no more available operating system processes\n\n  * `:enametoolong` - the external command given was too long\n\n  * `:emfile` - there are no more available file descriptors\n    (for the operating system process that the Erlang emulator runs in)\n\n  * `:enfile` - the file table is full (for the entire operating system)\n\n  * `:eacces` - the command does not point to an executable file\n\n  * `:enoent` - the command does not point to an existing file\n\n## Shell commands\n\nIf you desire to execute a trusted command inside a shell, with pipes,\nredirecting and so on, please check `shell/2`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.compiled_endianness() <response> Returns the endianness the system was compiled with."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.convert_time_unit(time, from_unit, to_unit) <response> Converts `time` from time unit `from_unit` to time unit `to_unit`.\n\nThe result is rounded via the floor function.\n\n`convert_time_unit/3` accepts an additional time unit (other than the\nones in the `t:time_unit/0` type) called `:native`. `:native` is the time\nunit used by the Erlang runtime system. It's determined when the runtime\nstarts and stays the same until the runtime is stopped, but could differ\nthe next time the runtime is started on the same machine. For this reason,\nyou should use this function to convert `:native` time units to a predictable\nunit before you display them to humans.\n\nTo determine how many seconds the `:native` unit represents in your current\nruntime, you can call this function to convert 1 second to the `:native`\ntime unit: `System.convert_time_unit(1, :second, :native)`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.cwd() <response> Current working directory.\n\nReturns the current working directory or `nil` if one\nis not available."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.cwd!() <response> Current working directory, exception on error.\n\nReturns the current working directory or raises `RuntimeError`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.delete_env(varname) <response> Deletes an environment variable.\n\nRemoves the variable `varname` from the environment."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.endianness() <response> Returns the endianness."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.fetch_env(varname) <response> Returns the value of the given environment variable or `:error` if not found.\n\nIf the environment variable `varname` is set, then `{:ok, value}` is returned\nwhere `value` is a string. If `varname` is not set, `:error` is returned.\n\n## Examples\n\n    iex> System.fetch_env(\"PORT\")\n    {:ok, \"4000\"}\n\n    iex> System.fetch_env(\"NOT_SET\")\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.fetch_env!(varname) <response> Returns the value of the given environment variable or raises if not found.\n\nSame as `get_env/1` but raises instead of returning `nil` when the variable is\nnot set.\n\n## Examples\n\n    iex> System.fetch_env!(\"PORT\")\n    \"4000\"\n\n    iex> System.fetch_env!(\"NOT_SET\")\n    ** (ArgumentError) could not fetch environment variable \"NOT_SET\" because it is not set"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.find_executable(program) <response> Locates an executable on the system.\n\nThis function looks up an executable program given\nits name using the environment variable PATH on Windows and Unix-like\noperating systems. It also considers the proper executable\nextension for each operating system, so for Windows it will try to\nlookup files with `.com`, `.cmd` or similar extensions."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.get_env() <response> Returns all system environment variables.\n\nThe returned value is a map containing name-value pairs.\nVariable names and their values are strings."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.get_env(varname, default \\\\ nil) <response> Returns the value of the given environment variable.\n\nThe returned value of the environment variable\n`varname` is a string. If the environment variable\nis not set, returns the string specified in `default` or\n`nil` if none is specified.\n\n## Examples\n\n    iex> System.get_env(\"PORT\")\n    \"4000\"\n\n    iex> System.get_env(\"NOT_SET\")\n    nil\n\n    iex> System.get_env(\"NOT_SET\", \"4001\")\n    \"4001\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.get_pid() <response> Erlang VM process identifier.\n\nReturns the process identifier of the current Erlang emulator\nin the format most commonly used by the operating system environment.\n\nFor more information, see `:os.getpid/0`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.halt(status \\\\ 0) <response> Immediately halts the Erlang runtime system.\n\nTerminates the Erlang runtime system without properly shutting down\napplications and ports. Please see `stop/1` for a careful shutdown of the\nsystem.\n\n`status` must be a non-negative integer, the atom `:abort` or a binary.\n\n  * If an integer, the runtime system exits with the integer value which\n    is returned to the operating system.\n\n  * If `:abort`, the runtime system aborts producing a core dump, if that is\n    enabled in the operating system.\n\n  * If a string, an Erlang crash dump is produced with status as slogan,\n    and then the runtime system exits with status code 1.\n\nNote that on many platforms, only the status codes 0-255 are supported\nby the operating system.\n\nFor more information, see `:erlang.halt/1`.\n\n## Examples\n\n    System.halt(0)\n    System.halt(1)\n    System.halt(:abort)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.monotonic_time() <response> Returns the current monotonic time in the `:native` time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.monotonic_time(unit) <response> Returns the current monotonic time in the given time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.no_halt() <response> Checks if the system will halt or not at the end of ARGV processing."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.no_halt(boolean) <response> Marks if the system should halt or not at the end of ARGV processing."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.os_time() <response> Returns the current operating system (OS) time.\n\nThe result is returned in the `:native` time unit.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.os_time(unit) <response> Returns the current operating system (OS) time in the given time `unit`.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.otp_release() <response> Returns the Erlang/OTP release number."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.pid() <response> Returns the operating system PID for the current Erlang runtime system instance.\n\nReturns a string containing the (usually) numerical identifier for a process.\nOn Unix-like operating systems, this is typically the return value of the `getpid()` system call.\nOn Windows, the process ID as returned by the `GetCurrentProcessId()` system\ncall is used.\n\n## Examples\n\n    System.pid()"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.put_env(enum) <response> Sets multiple environment variables.\n\nSets a new value for each environment variable corresponding\nto each `{key, value}` pair in `enum`. Keys are automatically\nconverted to strings, values are sent as is. `nil` values erase\nthe given keys."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.put_env(varname, value) <response> Sets an environment variable value.\n\nSets a new `value` for the environment variable `varname`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.restart() <response> Restarts all applications in the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system starts all applications once again.\n\n## Examples\n\n    System.restart()"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.schedulers() <response> Returns the number of schedulers in the VM."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.schedulers_online() <response> Returns the number of schedulers online in the VM."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.shell(command, opts \\\\ []) <response> Executes the given `command` in the OS shell.\n\nIt uses `sh` for Unix-like systems and `cmd` for Windows.\n\n> **Important:**: Use this function with care. In particular, **never\n> pass untrusted user input to this function**, as the user would be\n> able to perform \"command injection attacks\" by executing any code\n> directly on the machine. Generally speaking, prefer to use `cmd/3`\n> over this function.\n\n## Examples\n\n    iex> System.shell(\"echo hello\")\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.shell(\"echo hello\", into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}\n\n## Options\n\nIt accepts the same options as `cmd/3` (except for `arg0`).\nIt also accepts the following exclusive options:\n\n  * `:close_stdin` (since v1.14.1) - if the stdin should be closed\n    on Unix systems, forcing any command that waits on stdin to\n    immediately terminate. Defaults to false."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.stacktrace() <response> Deprecated mechanism to retrieve the last exception stacktrace.\n\nIt always return an empty list."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.stop(status \\\\ 0) <response> Carefully stops the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system terminates by calling `halt/1`.\n\n`status` must be a non-negative integer or a binary.\n\n  * If an integer, the runtime system exits with the integer value which is\n    returned to the operating system.\n\n  * If a binary, an Erlang crash dump is produced with status as slogan, and\n    then the runtime system exits with status code 1.\n\nNote that on many platforms, only the status codes 0-255 are supported\nby the operating system.\n\n## Examples\n\n    System.stop(0)\n    System.stop(1)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.system_time() <response> Returns the current system time in the `:native` time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.system_time(unit) <response> Returns the current system time in the given time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.time_offset() <response> Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the `:native` time unit.\n\nSee `time_offset/1` for more information.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.time_offset(unit) <response> Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the given time unit `unit`. The returned\noffset, added to an Erlang monotonic time (for instance, one obtained with\n`monotonic_time/1`), gives the Erlang system time that corresponds\nto that monotonic time."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.tmp_dir() <response> Writable temporary directory.\n\nReturns a writable temporary directory.\nSearches for directories in the following order:\n\n  1. the directory named by the TMPDIR environment variable\n  2. the directory named by the TEMP environment variable\n  3. the directory named by the TMP environment variable\n  4. `C:\\TMP` on Windows or `/tmp` on Unix-like operating systems\n  5. as a last resort, the current working directory\n\nReturns `nil` if none of the above are writable."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.tmp_dir!() <response> Writable temporary directory, exception on error.\n\nSame as `tmp_dir/0` but raises `RuntimeError`\ninstead of returning `nil` if no temp dir is set."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.trap_signal(signal, id \\\\ make_ref(), fun) <response> Traps the given `signal` to execute the `fun`.\n\n> **Important**: Trapping signals may have strong implications\n> on how a system shuts down and behave in production and\n> therefore it is extremely discouraged for libraries to\n> set their own traps. Instead, they should redirect users\n> to configure them themselves. The only cases where it is\n> acceptable for libraries to set their own traps is when\n> using Elixir in script mode, such as in `.exs` files and\n> via Mix tasks.\n\nAn optional `id` that uniquely identifies the function\ncan be given, otherwise a unique one is automatically\ngenerated. If a previously registered `id` is given,\nthis function returns an error tuple. The `id` can be\nused to remove a registered signal by calling\n`untrap_signal/2`.\n\nThe given `fun` receives no arguments and it must return\n`:ok`.\n\nIt returns `{:ok, id}` in case of success,\n`{:error, :already_registered}` in case the id has already\nbeen registered for the given signal, or `{:error, :not_sup}`\nin case trapping exists is not supported by the current OS.\n\nThe first time a signal is trapped, it will override the\ndefault behaviour from the operating system. If the same\nsignal is trapped multiple times, subsequent functions\ngiven to `trap_signal` will execute *first*. In other\nwords, you can consider each function is prepended to\nthe signal handler.\n\nBy default, the Erlang VM register traps to the three\nsignals:\n\n  * `:sigstop` - gracefully shuts down the VM with `stop/0`\n  * `:sigquit` - halts the VM via `halt/0`\n  * `:sigusr1` - halts the VM via status code of 1\n\nTherefore, if you add traps to the signals above, the\ndefault behaviour above will be executed after all user\nsignals.\n\n## Implementation notes\n\nAll signals run from a single process. Therefore, blocking the\n`fun` will block subsequent traps. It is also not possible to add\nor remove traps from within a trap itself.\n\nInternally, this functionality is built on top of `:os.set_signal/2`.\nWhen you register a trap, Elixir automatically sets it to `:handle`\nand it reverts it back to `:default` once all traps are removed\n(except for `:sigquit`, `:sigterm`, and `:sigusr1` which are always\nhandled). If you or a library call `:os.set_signal/2` directly,\nit may disable Elixir traps (or Elixir may override your configuration)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.unique_integer(modifiers \\\\ []) <response> Generates and returns an integer that is unique in the current runtime\ninstance.\n\n\"Unique\" means that this function, called with the same list of `modifiers`,\nwill never return the same integer more than once on the current runtime\ninstance.\n\nIf `modifiers` is `[]`, then a unique integer (that can be positive or negative) is returned.\nOther modifiers can be passed to change the properties of the returned integer:\n\n  * `:positive` - the returned integer is guaranteed to be positive.\n  * `:monotonic` - the returned integer is monotonically increasing. This\n    means that, on the same runtime instance (but even on different\n    processes), integers returned using the `:monotonic` modifier will always\n    be strictly less than integers returned by successive calls with the\n    `:monotonic` modifier.\n\nAll modifiers listed above can be combined; repeated modifiers in `modifiers`\nwill be ignored.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.untrap_signal(signal, id) <response> Removes a previously registered `signal` with `id`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.user_home() <response> User home directory.\n\nReturns the user home directory (platform independent)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.user_home!() <response> User home directory, exception on error.\n\nSame as `user_home/0` but raises `RuntimeError`\ninstead of returning `nil` if no user home is set."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.version() <response> Elixir version information.\n\nReturns Elixir's version as binary."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.Elixir.System <response> The `System` module provides functions that interact directly\nwith the VM or the host system."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.Elixir.System <response> Time\n\nThe `System` module also provides functions that work with time,\nreturning different times kept by the system with support for\ndifferent time units.\n\nOne of the complexities in relying on system times is that they\nmay be adjusted. For example, when you enter and leave daylight\nsaving time, the system clock will be adjusted, often adding\nor removing one hour. We call such changes \"time warps\". In\norder to understand how such changes may be harmful, imagine\nthe following code:\n\n    ## DO NOT DO THIS\n    prev = System.os_time()\n    # ... execute some code ...\n    next = System.os_time()\n    diff = next - prev\n\nIf, while the code is executing, the system clock changes,\nsome code that executed in 1 second may be reported as taking\nover 1 hour! To address such concerns, the VM provides a\nmonotonic time via `System.monotonic_time/0` which never\ndecreases and does not leap:\n\n    ## DO THIS\n    prev = System.monotonic_time()\n    # ... execute some code ...\n    next = System.monotonic_time()\n    diff = next - prev\n\nGenerally speaking, the VM provides three time measurements:\n\n  * `os_time/0` - the time reported by the operating system (OS). This time may be\n    adjusted forwards or backwards in time with no limitation;\n\n  * `system_time/0` - the VM view of the `os_time/0`. The system time and operating\n    system time may not match in case of time warps although the VM works towards\n    aligning them. This time is not monotonic (i.e., it may decrease)\n    as its behaviour is configured [by the VM time warp\n    mode](https://www.erlang.org/doc/apps/erts/time_correction.html#Time_Warp_Modes);\n\n  * `monotonic_time/0` - a monotonically increasing time provided\n    by the Erlang VM.\n\nThe time functions in this module work in the `:native` unit\n(unless specified otherwise), which is operating system dependent. Most of\nthe time, all calculations are done in the `:native` unit, to\navoid loss of precision, with `convert_time_unit/3` being\ninvoked at the end to convert to a specific time unit like\n`:millisecond` or `:microsecond`. See the `t:time_unit/0` type for\nmore information.\n\nFor a more complete rundown on the VM support for different\ntimes, see the [chapter on time and time\ncorrection](https://www.erlang.org/doc/apps/erts/time_correction.html)\nin the Erlang docs."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async(supervisor, fun, options \\\\ []) <response> Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/3` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async(supervisor, module, fun, args, options \\\\ []) <response> Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/3` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_nolink(supervisor, fun, options \\\\ []) <response> Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/3` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n\n## Compatibility with OTP behaviours\n\nIf you create a task using `async_nolink` inside an OTP behaviour\nlike `GenServer`, you should match on the message coming from the\ntask inside your `c:GenServer.handle_info/2` callback.\n\nThe reply sent by the task will be in the format `{ref, result}`,\nwhere `ref` is the monitor reference held by the task struct\nand `result` is the return value of the task function.\n\nKeep in mind that, regardless of how the task created with `async_nolink`\nterminates, the caller's process will always receive a `:DOWN` message\nwith the same `ref` value that is held by the task struct. If the task\nterminates normally, the reason in the `:DOWN` message will be `:normal`.\n\n## Examples\n\nTypically, you use `async_nolink/3` when there is a reasonable expectation that\nthe task may fail, and you don't want it to take down the caller. Let's see an\nexample where a `GenServer` is meant to run a single task and track its status:\n\n    defmodule MyApp.Server do\n      use GenServer\n\n      # ...\n\n      def start_task do\n        GenServer.call(__MODULE__, :start_task)\n      end\n\n      # In this case the task is already running, so we just return :ok.\n      def handle_call(:start_task, _from, %{ref: ref} = state) when is_reference(ref) do\n        {:reply, :ok, state}\n      end\n\n      # The task is not running yet, so let's start it.\n      def handle_call(:start_task, _from, %{ref: nil} = state) do\n        task =\n          Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn ->\n            ...\n          end)\n\n        # We return :ok and the server will continue running\n        {:reply, :ok, %{state | ref: task.ref}}\n      end\n\n      # The task completed successfully\n      def handle_info({ref, answer}, %{ref: ref} = state) do\n        # We don't care about the DOWN message now, so let's demonitor and flush it\n        Process.demonitor(ref, [:flush])\n        # Do something with the result and then return\n        {:noreply, %{state | ref: nil}}\n      end\n\n      # The task failed\n      def handle_info({:DOWN, ref, :process, _pid, _reason}, %{ref: ref} = state) do\n        # Log and possibly restart the task...\n        {:noreply, %{state | ref: nil}}\n      end\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_nolink(supervisor, module, fun, args, options \\\\ []) <response> Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/3` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\nNote this function requires the task supervisor to have `:temporary`\nas the `:restart` option (the default), as `async_nolink/5` keeps a\ndirect reference to the task which is lost if the task is restarted."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_stream(supervisor, enumerable, fun, options \\\\ []) <response> Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and linked to the caller process, similarly to `async/3`.\n\nSee `async_stream/6` for discussion, options, and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_stream(supervisor, enumerable, module, function, args, options \\\\ []) <response> Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element will be prepended to the given `args` and processed by its\nown task. The tasks will be spawned under the given `supervisor` and\nlinked to the caller process, similarly to `async/5`.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nThe order of results depends on the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nIf you find yourself trapping exits to handle exits inside\nthe async stream, consider using `async_stream_nolink/6` to start tasks\nthat are not linked to the calling process.\n\n## Options\n\n  * `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. This option is useful when you have large\n    streams and don't want to buffer results before they are delivered.\n    This is also useful when you're using the tasks for side effects.\n    Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time to wait (in milliseconds)\n    without receiving a task reply (across all running tasks).\n    Defaults to `5000`.\n\n  * `:on_timeout` - what do to when a task times out. The possible\n    values are:\n    * `:exit` (default) - the process that spawned the tasks exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value. Defaults to `5000` milliseconds.\n\n## Examples\n\nLet's build a stream and then enumerate it:\n\n    stream = Task.Supervisor.async_stream(MySupervisor, collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_stream_nolink(supervisor, enumerable, fun, options \\\\ []) <response> Returns a stream that runs the given `function` concurrently on each\nelement in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and will not be linked to the caller process, similarly\nto `async_nolink/3`.\n\nSee `async_stream/6` for discussion and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_stream_nolink(supervisor, enumerable, module, function, args, options \\\\ []) <response> Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element in `enumerable` will be prepended to the given `args` and processed\nby its own task. The tasks will be spawned under the given `supervisor` and\nwill not be linked to the caller process, similarly to `async_nolink/5`.\n\nSee `async_stream/6` for discussion, options, and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.children(supervisor) <response> Returns all children PIDs except those that are restarting.\n\nNote that calling this function when supervising a large number\nof children under low memory conditions can cause an out of memory\nexception."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.start_child(supervisor, fun, options \\\\ []) <response> Starts a task as a child of the given `supervisor`.\n\n    Task.Supervisor.start_child(MyTaskSupervisor, fn ->\n      IO.puts \"I am running in a task\"\n    end)\n\nNote that the spawned process is not linked to the caller, but\nonly to the supervisor. This command is useful in case the\ntask needs to perform side-effects (like I/O) and you have no\ninterest in its results nor if it completes successfully.\n\n## Options\n\n  * `:restart` - the restart strategy, may be `:temporary` (the default),\n    `:transient` or `:permanent`. `:temporary` means the task is never\n    restarted, `:transient` means it is restarted if the exit is not\n    `:normal`, `:shutdown` or `{:shutdown, reason}`. A `:permanent` restart\n    strategy means it is always restarted.\n\n  * `:shutdown` - `:brutal_kill` if the task must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.start_child(supervisor, module, fun, args, options \\\\ []) <response> Starts a task as a child of the given `supervisor`.\n\nSimilar to `start_child/3` except the task is specified\nby the given `module`, `fun` and `args`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.start_link(options \\\\ []) <response> Starts a new supervisor.\n\n## Examples\n\nA task supervisor is typically started under a supervision tree using\nthe tuple format:\n\n    {Task.Supervisor, name: MyApp.TaskSupervisor}\n\nYou can also start it by calling `start_link/1` directly:\n\n    Task.Supervisor.start_link(name: MyApp.TaskSupervisor)\n\nBut this is recommended only for scripting and should be avoided in\nproduction code. Generally speaking, processes should always be started\ninside supervision trees.\n\n## Options\n\n  * `:name` - used to register a supervisor name, the supported values are\n    described under the `Name Registration` section in the `GenServer` module\n    docs;\n\n  * `:max_restarts`, `:max_seconds`, and `:max_children` - as specified in\n    `DynamicSupervisor`;\n\nThis function could also receive `:restart` and `:shutdown` as options\nbut those two options have been deprecated and it is now preferred to\ngive them directly to `start_child`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.terminate_child(supervisor, pid) <response> Terminates the child with the given `pid`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.Elixir.Task.Supervisor <response> A task supervisor.\n\nThis module defines a supervisor which can be used to dynamically\nsupervise tasks.\n\nA task supervisor is started with no children, often under a\nsupervisor and a name:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe options given in the child specification are documented in `start_link/1`.\n\nOnce started, you can start tasks directly under the supervisor, for example:\n\n    task = Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n      :do_some_work\n    end)\n\nSee the `Task` module for more examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.Elixir.Task.Supervisor <response> Scalability and partitioning\n\nThe `Task.Supervisor` is a single process responsible for starting\nother processes. In some applications, the `Task.Supervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `Task.Supervisor` and then pick a random instance to start\nthe task on.\n\nInstead of:\n\n    children = [\n      {Task.Supervisor, name: Task.Supervisor}\n    ]\n\nand:\n\n    Task.Supervisor.async(MyApp.TaskSupervisor, fn -> :do_some_work end)\n\nYou can do this:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: Task.Supervisor,\n       name: MyApp.TaskSupervisors}\n    ]\n\nand then:\n\n    Task.Supervisor.async(\n      {:via, PartitionSupervisor, {MyApp.TaskSupervisors, self()}},\n      fn -> :do_some_work end\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `Task.Supervisor` by name, you call it through the\npartition supervisor using the `{:via, PartitionSupervisor, {name, key}}`\nformat, where `name` is the name of the partition supervisor and `key`\nis the routing key. We picked `self()` as the routing key, which means\neach process will be assigned one of the existing task supervisors.\nRead the `PartitionSupervisor` docs for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.Elixir.Task.Supervisor <response> Name registration\n\nA `Task.Supervisor` is bound to the same name registration rules as a\n`GenServer`. Read more about them in the `GenServer` docs."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.%Task{} <response> The Task struct.\n\nIt contains these fields:\n\n  * `:mfa` - a three-element tuple containing the module, function name,\n    and arity invoked to start the task in `async/1` and `async/3`\n\n  * `:owner` - the PID of the process that started the task\n\n  * `:pid` - the PID of the task process; `nil` if the task does\n    not use a task process\n\n  * `:ref` - the task monitor reference"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.async(fun) <response> Starts a task that must be awaited on.\n\n`fun` must be a zero-arity anonymous function. This function\nspawns a process that is linked to and monitored by the caller\nprocess. A `Task` struct is returned containing the relevant\ninformation. Developers must eventually call `Task.await/2` or\n`Task.yield/2` followed by `Task.shutdown/2` on the returned task.\n\nRead the `Task` module documentation for more information about\nthe general usage of async tasks.\n\n## Linking\n\nThis function spawns a process that is linked to and monitored\nby the caller process. The linking part is important because it\naborts the task if the parent process dies. It also guarantees\nthe code before async/await has the same properties after you\nadd the async call. For example, imagine you have this:\n\n    x = heavy_fun()\n    y = some_fun()\n    x + y\n\nNow you want to make the `heavy_fun()` async:\n\n    x = Task.async(&heavy_fun/0)\n    y = some_fun()\n    Task.await(x) + y\n\nAs before, if `heavy_fun/0` fails, the whole computation will\nfail, including the caller process. If you don't want the task\nto fail then you must change the `heavy_fun/0` code in the\nsame way you would achieve it if you didn't have the async call.\nFor example, to either return `{:ok, val} | :error` results or,\nin more extreme cases, by using `try/rescue`. In other words,\nan asynchronous task should be thought of as an extension of the\ncaller process rather than a mechanism to isolate it from all errors.\n\nIf you don't want to link the caller to the task, then you\nmust use a supervised task with `Task.Supervisor` and call\n`Task.Supervisor.async_nolink/2`.\n\nIn any case, avoid any of the following:\n\n  * Setting `:trap_exit` to `true` - trapping exits should be\n    used only in special circumstances as it would make your\n    process immune to not only exits from the task but from\n    any other processes.\n\n    Moreover, even when trapping exits, calling `await` will\n    still exit if the task has terminated without sending its\n    result back.\n\n  * Unlinking the task process started with `async`/`await`.\n    If you unlink the processes and the task does not belong\n    to any supervisor, you may leave dangling tasks in case\n    the caller process dies.\n\n## Metadata\n\nThe task created with this function stores `:erlang.apply/2` in\nits `:mfa` metadata field, which is used internally to apply\nthe anonymous function. Use `async/3` if you want another function\nto be used as metadata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.async(module, function_name, args) <response> Starts a task that must be awaited on.\n\nSimilar to `async/1` except the function to be started is\nspecified by the given `module`, `function_name`, and `args`.\nThe `module`, `function_name`, and its arity are stored as\na tuple in the `:mfa` field for reflection purposes."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.async_stream(enumerable, fun, options \\\\ []) <response> Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nWorks the same as `async_stream/5` but with an anonymous function instead of a\nmodule-function-arguments tuple. `fun` must be a one-arity anonymous function.\n\nEach `enumerable` element is passed as argument to the given function `fun` and\nprocessed by its own task. The tasks will be linked to the caller process, similarly\nto `async/1`.\n\n## Example\n\nCount the code points in each string asynchronously, then add the counts together using reduce.\n\n    iex> strings = [\"long string\", \"longer string\", \"there are many of these\"]\n    iex> stream = Task.async_stream(strings, fn text -> text |> String.codepoints() |> Enum.count() end)\n    iex> Enum.reduce(stream, 0, fn {:ok, num}, acc -> num + acc end)\n    47\n\nSee `async_stream/5` for discussion, options, and more examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.async_stream(enumerable, module, function_name, args, options \\\\ []) <response> Returns a stream where the given function (`module` and `function_name`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element of `enumerable` will be prepended to the given `args` and\nprocessed by its own task. Those tasks will be linked to an intermediate\nprocess that is then linked to the caller process. This means a failure\nin a task terminates the caller process and a failure in the caller\nprocess terminates all tasks.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nIt's possible to have `{:exit, {element, reason}}` for exits\nusing the `:zip_input_on_exit` option. The order of results depends\non the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nConsider using `Task.Supervisor.async_stream/6` to start tasks\nunder a supervisor. If you find yourself trapping exits to ensure\nerrors in the tasks do not terminate the caller process, consider\nusing `Task.Supervisor.async_stream_nolink/6` to start tasks that\nare not linked to the caller process.\n\n## Options\n\n  * `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. When the output is ordered, Elixir may need to\n    buffer results to emit them in the original order. Setting this option\n    to false disables the need to buffer at the cost of removing ordering.\n    This is also useful when you're using the tasks only for the side effects.\n    Note that regardless of what `:ordered` is set to, the tasks will\n    process asynchronously. If you need to process elements in order,\n    consider using `Enum.map/2` or `Enum.each/2` instead. Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time (in milliseconds or `:infinity`)\n    each task is allowed to execute for. Defaults to `5000`.\n\n  * `:on_timeout` - what to do when a task times out. The possible\n    values are:\n    * `:exit` (default) - the caller (the process that spawned the tasks) exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:zip_input_on_exit` - (since v1.14.0) adds the original\n    input to `:exit` tuples. The value emitted for that task is\n    `{:exit, {input, reason}}`, where `input` is the collection element\n    that caused an exited during processing. Defaults to `false`.\n\n## Example\n\nLet's build a stream and then enumerate it:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)\n\nThe concurrency can be increased or decreased using the `:max_concurrency`\noption. For example, if the tasks are IO heavy, the value can be increased:\n\n    max_concurrency = System.schedulers_online() * 2\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], max_concurrency: max_concurrency)\n    Enum.to_list(stream)\n\nIf you do not care about the results of the computation, you can run\nthe stream with `Stream.run/1`. Also set `ordered: false`, as you don't\ncare about the order of the results either:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], ordered: false)\n    Stream.run(stream)\n\n## First async tasks to complete\n\nYou can also use `async_stream/3` to execute M tasks and find the N tasks\nto complete. For example:\n\n    [\n      &heavy_call_1/0,\n      &heavy_call_2/0,\n      &heavy_call_3/0\n    ]\n    |> Task.async_stream(fn fun -> fun.() end, ordered: false, max_concurrency: 3)\n    |> Stream.filter(&match?({:ok, _}, &1))\n    |> Enum.take(2)\n\nIn the example above, we are executing three tasks and waiting for the\nfirst 2 to complete. We use `Stream.filter/2` to restrict ourselves only\nto successfully completed tasks, and then use `Enum.take/2` to retrieve\nN items. Note it is important to set both `ordered: false` and\n`max_concurrency: M`, where M is the number of tasks, to make sure all\ncalls execute concurrently.\n\n### Attention: unbound async + take\n\nIf you want to potentially process a high number of items and keep only\npart of the results, you may end-up processing more items than desired.\nLet's see an example:\n\n    1..100\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.take(10)\n\nRunning the example above in a machine with 8 cores will process 16 items,\neven though you want only 10 elements, since `async_stream/3` process items\nconcurrently. That's because it will process 8 elements at once. Then all 8\nelements complete at roughly the same time, causing 8 elements to be kicked\noff for processing. Out of these extra 8, only 2 will be used, and the rest\nwill be terminated.\n\nDepending on the problem, you can filter or limit the number of elements\nupfront:\n\n    1..100\n    |> Stream.take(10)\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.to_list()\n\nIn other cases, you likely want to tweak `:max_concurrency` to limit how\nmany elements may be over processed at the cost of reducing concurrency.\nYou can also set the number of elements to take to be a multiple of\n`:max_concurrency`. For instance, setting `max_concurrency: 5` in the\nexample above."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.await(task, timeout \\\\ 5000) <response> Awaits a task reply and returns it.\n\nIn case the task process dies, the caller process will exit with the same\nreason as the task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nIf the task process is linked to the caller process which is the case when\na task is started with `async`, then the task process will also exit. If the\ntask process is trapping exits or not linked to the caller process, then it\nwill continue to run.\n\nThis function assumes the task's monitor is still active or the monitor's\n`:DOWN` message is in the message queue. If it has been demonitored, or the\nmessage already received, this function will wait for the duration of the\ntimeout awaiting the message.\n\nThis function can only be called once for any given task. If you want\nto be able to check multiple times if a long-running task has finished\nits computation, use `yield/2` instead.\n\n## Examples\n\n    iex> task = Task.async(fn -> 1 + 1 end)\n    iex> Task.await(task)\n    2\n\n## Compatibility with OTP behaviours\n\nIt is not recommended to `await` a long-running task inside an OTP\nbehaviour such as `GenServer`. Instead, you should match on the message\ncoming from a task inside your `c:GenServer.handle_info/2` callback.\n\nA GenServer will receive two messages on `handle_info/2`:\n\n  * `{ref, result}` - the reply message where `ref` is the monitor\n    reference returned by the `task.ref` and `result` is the task\n    result\n\n  * `{:DOWN, ref, :process, pid, reason}` - since all tasks are also\n    monitored, you will also receive the `:DOWN` message delivered by\n    `Process.monitor/1`. If you receive the `:DOWN` message without a\n    a reply, it means the task crashed\n\nAnother consideration to have in mind is that tasks started by `Task.async/1`\nare always linked to their callers and you may not want the GenServer to\ncrash if the task crashes. Therefore, it is preferable to instead use\n`Task.Supervisor.async_nolink/3` inside OTP behaviours. For completeness, here\nis an example of a GenServer that start tasks and handles their results:\n\n    defmodule GenServerTaskExample do\n      use GenServer\n\n      def start_link(opts) do\n        GenServer.start_link(__MODULE__, :ok, opts)\n      end\n\n      def init(_opts) do\n        # We will keep all running tasks in a map\n        {:ok, %{tasks: %{}}}\n      end\n\n      # Imagine we invoke a task from the GenServer to access a URL...\n      def handle_call(:some_message, _from, state) do\n        url = ...\n        task = Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn -> fetch_url(url) end)\n\n        # After we start the task, we store its reference and the url it is fetching\n        state = put_in(state.tasks[task.ref], url)\n\n        {:reply, :ok, state}\n      end\n\n      # If the task succeeds...\n      def handle_info({ref, result}, state) do\n        # The task succeed so we can cancel the monitoring and discard the DOWN message\n        Process.demonitor(ref, [:flush])\n\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"Got #{inspect(result)} for URL #{inspect url}\"\n        {:noreply, state}\n      end\n\n      # If the task fails...\n      def handle_info({:DOWN, ref, _, _, reason}, state) do\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"URL #{inspect url} failed with reason #{inspect(reason)}\"\n        {:noreply, state}\n      end\n    end\n\nWith the server defined, you will want to start the task supervisor\nabove and the GenServer in your supervision tree:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor},\n      {GenServerTaskExample, name: MyApp.GenServerTaskExample}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.await_many(tasks, timeout \\\\ 5000) <response> Awaits replies from multiple tasks and returns them.\n\nThis function receives a list of tasks and waits for their replies in the\ngiven time interval. It returns a list of the results, in the same order as\nthe tasks supplied in the `tasks` input argument.\n\nIf any of the task processes dies, the caller process will exit with the same\nreason as that task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nAny task processes that are linked to the caller process (which is the case\nwhen a task is started with `async`) will also exit. Any task processes that\nare trapping exits or not linked to the caller process will continue to run.\n\nThis function assumes the tasks' monitors are still active or the monitor's\n`:DOWN` message is in the message queue. If any tasks have been demonitored,\nor the message already received, this function will wait for the duration of\nthe timeout.\n\nThis function can only be called once for any given task. If you want to be\nable to check multiple times if a long-running task has finished its\ncomputation, use `yield_many/2` instead.\n\n## Compatibility with OTP behaviours\n\nIt is not recommended to `await` long-running tasks inside an OTP behaviour\nsuch as `GenServer`. See `await/2` for more information.\n\n## Examples\n\n    iex> tasks = [\n    ...>   Task.async(fn -> 1 + 1 end),\n    ...>   Task.async(fn -> 2 + 3 end)\n    ...> ]\n    iex> Task.await_many(tasks)\n    [2, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.child_spec(arg) <response> Returns a specification to start a task under a supervisor.\n\n`arg` is passed as the argument to `Task.start_link/1` in the `:start` field\nof the spec.\n\nFor more information, see the `Supervisor` module,\nthe `Supervisor.child_spec/2` function and the `t:Supervisor.child_spec/0` type."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.completed(result) <response> Starts a task that immediately completes with the given `result`.\n\nUnlike `async/1`, this task does not spawn a linked process. It can\nbe awaited or yielded like any other task.\n\n## Usage\n\nIn some cases, it is useful to create a \"completed\" task that represents\na task that has already run and generated a result. For example, when\nprocessing data you may be able to determine that certain inputs are\ninvalid before dispatching them for further processing:\n\n    def process(data) do\n      tasks =\n        for entry <- data do\n          if invalid_input?(entry) do\n            Task.completed({:error, :invalid_input})\n          else\n            Task.async(fn -> further_process(entry) end)\n          end\n        end\n\n      Task.await_many(tasks)\n    end\n\nIn many cases, `Task.completed/1` may be avoided in favor of returning the\nresult directly.  You should generally only require this variant when working\nwith mixed asynchrony, when a group of inputs will be handled partially\nsynchronously and partially asynchronously."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.ignore(task) <response> Ignores an existing task.\n\nThis means the task will continue running, but it will be unlinked\nand you can no longer yield, await or shut it down.\n\nReturns `{:ok, reply}` if the reply is received before ignoring the task,\n`{:exit, reason}` if the task died before ignoring it, otherwise `nil`.\n\nImportant: avoid using [`Task.async/1,3`](`async/1`) and then immediately ignoring\nthe task. If you want to start tasks you don't care about their\nresults, use `Task.Supervisor.start_child/2` instead.\n\nRequires Erlang/OTP 24+."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.shutdown(task, shutdown \\\\ 5000) <response> Unlinks and shuts down the task, and then checks for a reply.\n\nReturns `{:ok, reply}` if the reply is received while shutting down the task,\n`{:exit, reason}` if the task died, otherwise `nil`. Once shut down,\nyou can no longer await or yield it.\n\nThe second argument is either a timeout or `:brutal_kill`. In case\nof a timeout, a `:shutdown` exit signal is sent to the task process\nand if it does not exit within the timeout, it is killed. With `:brutal_kill`\nthe task is killed straight away. In case the task terminates abnormally\n(possibly killed by another process), this function will exit with the same reason.\n\nIt is not required to call this function when terminating the caller, unless\nexiting with reason `:normal` or if the task is trapping exits. If the caller is\nexiting with a reason other than `:normal` and the task is not trapping exits, the\ncaller's exit signal will stop the task. The caller can exit with reason\n`:shutdown` to shut down all of its linked processes, including tasks, that\nare not trapping exits without generating any log messages.\n\nIf a task's monitor has already been demonitored or received and there is not\na response waiting in the message queue this function will return\n`{:exit, :noproc}` as the result or exit reason can not be determined."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.start(fun) <response> Starts a task.\n\n`fun` must be a zero-arity anonymous function.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.start(module, function_name, args) <response> Starts a task.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.start_link(fun) <response> Starts a task as part of a supervision tree with the given `fun`.\n\n`fun` must be a zero-arity anonymous function.\n\nThis is used to start a statically supervised task under a supervision tree."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.start_link(module, function, args) <response> Starts a task as part of a supervision tree with the given\n`module`, `function`, and `args`.\n\nThis is used to start a statically supervised task under a supervision tree."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.yield(task, timeout \\\\ 5000) <response> Temporarily blocks the caller process waiting for a task reply.\n\nReturns `{:ok, reply}` if the reply is received, `nil` if\nno reply has arrived, or `{:exit, reason}` if the task has already\nexited. Keep in mind that normally a task failure also causes\nthe process owning the task to exit. Therefore this function can\nreturn `{:exit, reason}` if at least one of the conditions below apply:\n\n  * the task process exited with the reason `:normal`\n  * the task isn't linked to the caller (the task was started\n    with `Task.Supervisor.async_nolink/2` or `Task.Supervisor.async_nolink/4`)\n  * the caller is trapping exits\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the time runs out before a message from the task is received,\nthis function will return `nil` and the monitor will remain active. Therefore\n`yield/2` can be called multiple times on the same task.\n\nThis function assumes the task's monitor is still active or the\nmonitor's `:DOWN` message is in the message queue. If it has been\ndemonitored or the message already received, this function will wait\nfor the duration of the timeout awaiting the message.\n\nIf you intend to shut the task down if it has not responded within `timeout`\nmilliseconds, you should chain this together with `shutdown/1`, like so:\n\n    case Task.yield(task, timeout) || Task.shutdown(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warn(\"Failed to get a result in #{timeout}ms\")\n        nil\n    end\n\nIf you intend to check on the task but leave it running after the timeout,\nyou can chain this together with `ignore/1`, like so:\n\n    case Task.yield(task, timeout) || Task.ignore(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warn(\"Failed to get a result in #{timeout}ms\")\n        nil\n    end\n\nThat ensures that if the task completes after the `timeout` but before `shutdown/1`\nhas been called, you will still get the result, since `shutdown/1` is designed to\nhandle this case and return the result."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.yield_many(tasks, timeout \\\\ 5000) <response> Yields to multiple tasks in the given time interval.\n\nThis function receives a list of tasks and waits for their\nreplies in the given time interval. It returns a list\nof two-element tuples, with the task as the first element\nand the yielded result as the second. The tasks in the returned\nlist will be in the same order as the tasks supplied in the `tasks`\ninput argument.\n\nSimilarly to `yield/2`, each task's result will be\n\n  * `{:ok, term}` if the task has successfully reported its\n    result back in the given time interval\n  * `{:exit, reason}` if the task has died\n  * `nil` if the task keeps running past the timeout\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`.\n\nCheck `yield/2` for more information.\n\n## Example\n\n`Task.yield_many/2` allows developers to spawn multiple tasks\nand retrieve the results received in a given timeframe.\nIf we combine it with `Task.shutdown/2` (or `Task.ignore/1`),\nit allows us to gather those results and cancel (or ignore)\nthe tasks that have not replied in time.\n\nLet's see an example.\n\n    tasks =\n      for i <- 1..10 do\n        Task.async(fn ->\n          Process.sleep(i * 1000)\n          i\n        end)\n      end\n\n    tasks_with_results = Task.yield_many(tasks, 5000)\n\n    results =\n      Enum.map(tasks_with_results, fn {task, res} ->\n        # Shut down the tasks that did not reply nor exit\n        res || Task.shutdown(task, :brutal_kill)\n      end)\n\n    # Here we are matching only on {:ok, value} and\n    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n    for {:ok, value} <- results do\n      IO.inspect(value)\n    end\n\nIn the example above, we create tasks that sleep from 1\nup to 10 seconds and return the number of seconds they slept for.\nIf you execute the code all at once, you should see 1 up to 5\nprinted, as those were the tasks that have replied in the\ngiven time. All other tasks will have been shut down using\nthe `Task.shutdown/2` call."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> Conveniences for spawning and awaiting tasks.\n\nTasks are processes meant to execute one particular\naction throughout their lifetime, often with little or no\ncommunication with other processes. The most common use case\nfor tasks is to convert sequential code into concurrent code\nby computing a value asynchronously:\n\n    task = Task.async(fn -> do_some_work() end)\n    res = do_some_other_work()\n    res + Task.await(task)\n\nTasks spawned with `async` can be awaited on by their caller\nprocess (and only their caller) as shown in the example above.\nThey are implemented by spawning a process that sends a message\nto the caller once the given computation is performed.\n\nBesides `async/1` and `await/2`, tasks can also be\nstarted as part of a supervision tree and dynamically spawned\non remote nodes. We will explore these scenarios next."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> async and await\n\nOne of the common uses of tasks is to convert sequential code\ninto concurrent code with `Task.async/1` while keeping its semantics.\nWhen invoked, a new process will be created, linked and monitored\nby the caller. Once the task action finishes, a message will be sent\nto the caller with the result.\n\n`Task.await/2` is used to read the message sent by the task.\n\nThere are two important things to consider when using `async`:\n\n  1. If you are using async tasks, you **must await** a reply\n     as they are *always* sent. If you are not expecting a reply,\n     consider using `Task.start_link/1` as detailed below.\n\n  2. async tasks link the caller and the spawned process. This\n     means that, if the caller crashes, the task will crash\n     too and vice-versa. This is on purpose: if the process\n     meant to receive the result no longer exists, there is\n     no purpose in completing the computation.\n\n     If this is not desired, you will want to use supervised\n     tasks, described next."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> Dynamically supervised tasks\n\nThe `Task.Supervisor` module allows developers to dynamically\ncreate multiple supervised tasks.\n\nA short example is:\n\n    {:ok, pid} = Task.Supervisor.start_link()\n\n    task =\n      Task.Supervisor.async(pid, fn ->\n        # Do something\n      end)\n\n    Task.await(task)\n\nHowever, in the majority of cases, you want to add the task supervisor\nto your supervision tree:\n\n    Supervisor.start_link([\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ], strategy: :one_for_one)\n\nAnd now you can use async/await by passing the name of\nthe supervisor instead of the pid:\n\n    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n      # Do something\n    end)\n    |> Task.await()\n\nWe encourage developers to rely on supervised tasks as much as possible.\nSupervised tasks improves the visibility of how many tasks are running\nat a given moment and enable a huge variety of patterns that gives you\nexplicit control on how to handle the results, errors, and timeouts.\nHere is a summary:\n\n  * Using `Task.Supervisor.start_child/2` allows you to start a fire-and-forget\n    task that you don't care about its results or if it completes successfully or not.\n\n  * Using `Task.Supervisor.async/2` + `Task.await/2` allows you to execute\n    tasks concurrently and retrieve its result. If the task fails,\n    the caller will also fail.\n\n  * Using `Task.Supervisor.async_nolink/2` + `Task.yield/2` + `Task.shutdown/2`\n    allows you to execute tasks concurrently and retrieve their results\n    or the reason they failed within a given time frame. If the task fails,\n    the caller won't fail. You will receive the error reason either on\n    `yield` or `shutdown`.\n\nFurthermore, the supervisor guarantee all tasks first terminate, within a\nconfigurable shutdown period, when your application shuts down. See the\n`Task.Supervisor` module for details on the supported operations."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> # Distributed tasks\n\nWith `Task.Supervisor`, it is easy to dynamically start tasks across nodes:\n\n    # On the remote node named :remote@local\n    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n\n    # On the client\n    supervisor = {MyApp.DistSupervisor, :remote@local}\n    Task.Supervisor.async(supervisor, MyMod, :my_fun, [arg1, arg2, arg3])\n\nNote that, when working with distributed tasks, one should use the\n`Task.Supervisor.async/5` function that expects explicit module, function,\nand arguments, instead of `Task.Supervisor.async/3` that works with anonymous\nfunctions. That's because anonymous functions expect the same module version\nto exist on all involved nodes. Check the `Agent` module documentation for\nmore information on distributed processes as the limitations described there\napply to the whole ecosystem."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> Statically supervised tasks\n\nThe `Task` module implements the `child_spec/1` function, which\nallows it to be started directly under a regular `Supervisor` -\ninstead of a `Task.Supervisor` - by passing a tuple with a function\nto run:\n\n    Supervisor.start_link([\n      {Task, fn -> :some_work end}\n    ], strategy: :one_for_one)\n\nThis is often useful when you need to execute some steps while\nsetting up your supervision tree. For example: to warm up caches,\nlog the initialization status, and such.\n\nIf you don't want to put the Task code directly under the `Supervisor`,\nyou can wrap the `Task` in its own module, similar to how you would\ndo with a `GenServer` or an `Agent`:\n\n    defmodule MyTask do\n      use Task\n\n      def start_link(arg) do\n        Task.start_link(__MODULE__, :run, [arg])\n      end\n\n      def run(arg) do\n        # ...\n      end\n    end\n\nAnd then passing it to the supervisor:\n\n    Supervisor.start_link([\n      {MyTask, arg}\n    ], strategy: :one_for_one)\n\nSince these tasks are supervised and not directly linked to the caller,\nthey cannot be awaited on. By default, the functions `Task.start/1`\nand `Task.start_link/1` are for fire-and-forget tasks, where you don't\ncare about the results or if it completes successfully or not.\n\n`use Task` defines a `child_spec/1` function, allowing the\ndefined module to be put under a supervision tree. The generated\n`child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:temporary`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nOpposite to `GenServer`, `Agent` and `Supervisor`, a Task has\na default `:restart` of `:temporary`. This means the task will\nnot be restarted even if it crashes. If you desire the task to\nbe restarted for non-successful exits, do:\n\n    use Task, restart: :transient\n\nIf you want the task to always be restarted:\n\n    use Task, restart: :permanent\n\nSee the \"Child specification\" section in the `Supervisor` module\nfor more detailed information. The `@doc` annotation immediately\npreceding `use Task` will be attached to the generated `child_spec/1`\nfunction."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> Ancestor and Caller Tracking\n\nWhenever you start a new process, Elixir annotates the parent of that process\nthrough the `$ancestors` key in the process dictionary. This is often used to\ntrack the hierarchy inside a supervision tree.\n\nFor example, we recommend developers to always start tasks under a supervisor.\nThis provides more visibility and allows you to control how those tasks are\nterminated when a node shuts down. That might look something like\n`Task.Supervisor.start_child(MySupervisor, task_function)`. This means\nthat, although your code is the one invoking the task, the actual ancestor of\nthe task is the supervisor, as the supervisor is the one effectively starting it.\n\nTo track the relationship between your code and the task, we use the `$callers`\nkey in the process dictionary. Therefore, assuming the `Task.Supervisor` call\nabove, we have:\n\n    [your code] -- calls --> [supervisor] ---- spawns --> [task]\n\nWhich means we store the following relationships:\n\n    [your code]              [supervisor] <-- ancestor -- [task]\n        ^                                                  |\n        |--------------------- caller ---------------------|\n\nThe list of callers of the current process can be retrieved from the Process\ndictionary with `Process.get(:\"$callers\")`. This will return either `nil` or\na list `[pid_n, ..., pid2, pid1]` with at least one entry Where `pid_n` is\nthe PID that called the current process, `pid2` called `pid_n`, and `pid2` was\ncalled by `pid1`.\n\nIf a task crashes, the callers field is included as part of the log message\nmetadata under the `:callers` key."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.add(time, amount_to_add, unit \\\\ :second) <response> Adds the `amount_to_add` of `unit`s to the given `time`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\nNote the result value represents the time of day, meaning that it is cyclic,\nfor instance, it will never go over 24 hours for the ISO calendar.\n\n## Examples\n\n    iex> Time.add(~T[10:00:00], 27000)\n    ~T[17:30:00]\n    iex> Time.add(~T[11:00:00.005], 2400)\n    ~T[11:40:00.005]\n    iex> Time.add(~T[00:00:00.000], 86_399_999, :millisecond)\n    ~T[23:59:59.999]\n\nNegative values are allowed:\n\n    iex> Time.add(~T[23:00:00], -60)\n    ~T[22:59:00]\n\nNote that the time is cyclic:\n\n    iex> Time.add(~T[17:10:05], 86400)\n    ~T[17:10:05]\n\nHours and minutes are also supported:\n\n    iex> Time.add(~T[17:10:05], 2, :hour)\n    ~T[19:10:05]\n    iex> Time.add(~T[17:10:05], 30, :minute)\n    ~T[17:40:05]\n\nThis operation merges the precision of the time with the given unit:\n\n    iex> result = Time.add(~T[00:29:10], 21, :millisecond)\n    ~T[00:29:10.021]\n    iex> result.microsecond\n    {21000, 3}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.compare(time1, time2) <response> Compares two time structs.\n\nReturns `:gt` if first time is later than the second\nand `:lt` for vice versa. If the two times are equal\n`:eq` is returned.\n\n## Examples\n\n    iex> Time.compare(~T[16:04:16], ~T[16:04:28])\n    :lt\n    iex> Time.compare(~T[16:04:16], ~T[16:04:16])\n    :eq\n    iex> Time.compare(~T[16:04:16.01], ~T[16:04:16.001])\n    :gt\n\nThis function can also be used to compare across more\ncomplex calendar types by considering only the time fields:\n\n    iex> Time.compare(~N[1900-01-01 16:04:16], ~N[2015-01-01 16:04:16])\n    :eq\n    iex> Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])\n    :lt\n    iex> Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 16:04:16.001])\n    :gt"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.convert(time, calendar) <response> Converts given `time` to a different calendar.\n\nReturns `{:ok, time}` if the conversion was successful,\nor `{:error, reason}` if it was not, for some reason.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert(~T[13:30:15], Calendar.Holocene)\n    {:ok, %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.convert!(time, calendar) <response> Similar to `Time.convert/2`, but raises an `ArgumentError`\nif the conversion between the two calendars is not possible.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert!(~T[13:30:15], Calendar.Holocene)\n    %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.diff(time1, time2, unit \\\\ :second) <response> Returns the difference between two times, considering only the hour, minute,\nsecond and microsecond.\n\nAs with the `compare/2` function both `Time` structs and other structures\ncontaining time can be used. If for instance a `NaiveDateTime` or `DateTime`\nis passed, only the hour, minute, second, and microsecond is considered. Any\nadditional information about a date or time zone is ignored when calculating\nthe difference.\n\nThe answer can be returned in any `:hour`, `:minute`, `:second` or any\nsubsecond `unit` available from `t:System.time_unit/0`. If the first time\nvalue is earlier than the second, a negative number is returned.\n\nThe unit is measured according to `Calendar.ISO` and defaults to `:second`.\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> Time.diff(~T[00:29:12], ~T[00:29:10])\n    2\n\n    # When passing a `NaiveDateTime` the date part is ignored.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~T[00:29:10])\n    2\n\n    # Two `NaiveDateTime` structs could have big differences in the date\n    # but only the time part is considered.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~N[1900-02-03 00:29:10])\n    2\n\n    iex> Time.diff(~T[00:29:12], ~T[00:29:10], :microsecond)\n    2_000_000\n    iex> Time.diff(~T[00:29:10], ~T[00:29:12], :microsecond)\n    -2_000_000\n\n    iex> Time.diff(~T[02:29:10], ~T[00:29:10], :hour)\n    2\n    iex> Time.diff(~T[02:29:10], ~T[00:29:11], :hour)\n    1"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.from_erl(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Converts an Erlang time tuple to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_erl({23, 30, 15}, {5000, 3})\n    {:ok, ~T[23:30:15.005]}\n    iex> Time.from_erl({24, 30, 15})\n    {:error, :invalid_time}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.from_erl!(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Converts an Erlang time tuple to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_erl!({23, 30, 15})\n    ~T[23:30:15]\n    iex> Time.from_erl!({23, 30, 15}, {5000, 3})\n    ~T[23:30:15.005]\n    iex> Time.from_erl!({24, 30, 15})\n    ** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.from_iso8601(string, calendar \\\\ Calendar.ISO) <response> Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nTime zone offset may be included in the string but they will be\nsimply discarded as such information is not included in times.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\n## Examples\n\n    iex> Time.from_iso8601(\"23:50:07\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"T23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n\n    iex> Time.from_iso8601(\"23:50:07,0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.123Z\")\n    {:ok, ~T[23:50:07.123]}\n\n    iex> Time.from_iso8601(\"2015:01:23 23-50-07\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07A\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07.\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:61\")\n    {:error, :invalid_time}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.from_iso8601!(string, calendar \\\\ Calendar.ISO) <response> Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> Time.from_iso8601!(\"23:50:07,123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"23:50:07.123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"2015:01:23 23-50-07\")\n    ** (ArgumentError) cannot parse \"2015:01:23 23-50-07\" as time, reason: :invalid_format"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.from_seconds_after_midnight(seconds, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Converts a number of seconds after midnight to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_seconds_after_midnight(10_000)\n    ~T[02:46:40]\n    iex> Time.from_seconds_after_midnight(30_000, {5000, 3})\n    ~T[08:20:00.005]\n    iex> Time.from_seconds_after_midnight(-1)\n    ~T[23:59:59]\n    iex> Time.from_seconds_after_midnight(100_000)\n    ~T[03:46:40]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.new(hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Builds a new time.\n\nExpects all values to be integers. Returns `{:ok, time}` if each\nentry fits its appropriate range, returns `{:error, reason}` otherwise.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.\n\n## Examples\n\n    iex> Time.new(0, 0, 0, 0)\n    {:ok, ~T[00:00:00.000000]}\n    iex> Time.new(23, 59, 59, 999_999)\n    {:ok, ~T[23:59:59.999999]}\n\n    iex> Time.new(24, 59, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 60, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 60, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 59, 1_000_000)\n    {:error, :invalid_time}\n\n    # Invalid precision\n    Time.new(23, 59, 59, {999_999, 10})\n    {:error, :invalid_time}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.new!(hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Builds a new time.\n\nExpects all values to be integers. Returns `time` if each\nentry fits its appropriate range, raises if the time is invalid.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.\n\n## Examples\n\n    iex> Time.new!(0, 0, 0, 0)\n    ~T[00:00:00.000000]\n    iex> Time.new!(23, 59, 59, 999_999)\n    ~T[23:59:59.999999]\n    iex> Time.new!(24, 59, 59, 999_999)\n    ** (ArgumentError) cannot build time, reason: :invalid_time"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.to_erl(time) <response> Converts given `time` to an Erlang time tuple.\n\nWARNING: Loss of precision may occur, as Erlang time tuples\nonly contain hours/minutes/seconds.\n\n## Examples\n\n    iex> Time.to_erl(~T[23:30:15.999])\n    {23, 30, 15}\n\n    iex> Time.to_erl(~N[2010-04-17 23:30:15.999])\n    {23, 30, 15}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.to_iso8601(time, format \\\\ :extended) <response> Converts the given time to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `Time.to_iso8601/2` returns times formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through\npassing the `:basic` option.\n\n### Examples\n\n    iex> Time.to_iso8601(~T[23:00:13])\n    \"23:00:13\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001])\n    \"23:00:13.001\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001], :basic)\n    \"230013.001\"\n\n    iex> Time.to_iso8601(~N[2010-04-17 23:00:13])\n    \"23:00:13\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.to_seconds_after_midnight(time) <response> Converts a `Time` struct to a number of seconds after midnight.\n\nThe returned value is a two-element tuple with the number of seconds and microseconds.\n\n## Examples\n\n    iex> Time.to_seconds_after_midnight(~T[23:30:15])\n    {84615, 0}\n    iex> Time.to_seconds_after_midnight(~N[2010-04-17 23:30:15.999])\n    {84615, 999000}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.to_string(time) <response> Converts the given `time` to a string.\n\n### Examples\n\n    iex> Time.to_string(~T[23:00:00])\n    \"23:00:00\"\n    iex> Time.to_string(~T[23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~T[23:00:00.123456])\n    \"23:00:00.123456\"\n\n    iex> Time.to_string(~N[2015-01-01 23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~N[2015-01-01 23:00:00.123456])\n    \"23:00:00.123456\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.truncate(time, precision) <response> Returns the given time with the microsecond field truncated to the given\nprecision (`:microsecond`, `millisecond` or `:second`).\n\nThe given time is returned unchanged if it already has lower precision than\nthe given precision.\n\n## Examples\n\n    iex> Time.truncate(~T[01:01:01.123456], :microsecond)\n    ~T[01:01:01.123456]\n\n    iex> Time.truncate(~T[01:01:01.123456], :millisecond)\n    ~T[01:01:01.123]\n\n    iex> Time.truncate(~T[01:01:01.123456], :second)\n    ~T[01:01:01]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.utc_now(calendar \\\\ Calendar.ISO) <response> Returns the current time in UTC.\n\n## Examples\n\n    iex> time = Time.utc_now()\n    iex> time.hour >= 0\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.Elixir.Time <response> A Time struct and functions.\n\nThe Time struct contains the fields hour, minute, second and microseconds.\nNew times can be built with the `new/4` function or using the\n`~T` (see `sigil_T/2`) sigil:\n\n    iex> ~T[23:00:07.001]\n    ~T[23:00:07.001]\n\nBoth `new/4` and sigil return a struct where the time fields can\nbe accessed directly:\n\n    iex> time = ~T[23:00:07.001]\n    iex> time.hour\n    23\n    iex> time.microsecond\n    {1000, 3}\n\nThe functions on this module work with the `Time` struct as well\nas any struct that contains the same fields as the `Time` struct,\nsuch as `NaiveDateTime` and `DateTime`. Such functions expect\n`t:Calendar.time/0` in their typespecs (instead of `t:t/0`).\n\nDevelopers should avoid creating the Time structs directly\nand instead rely on the functions provided by this module as well\nas the ones in third-party calendar libraries."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.Elixir.Time <response> Comparing times\n\nComparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `Time` struct fields. For proper comparison between\ntimes, use the `compare/2` function. The existence of the `compare/2`\nfunction in this module also allows using `Enum.min/2` and `Enum.max/2`\nfunctions to get the minimum and maximum time of an `Enum`. For example:\n\n    iex> Enum.min([~T[23:00:07.001], ~T[10:00:07.001]], Time)\n    ~T[10:00:07.001]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.append(tuple, value) <response> Inserts an element at the end of a tuple.\n\nReturns a new tuple with the element appended at the end, and contains\nthe elements in `tuple` followed by `value` as the last element.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar}\n    iex> Tuple.append(tuple, :baz)\n    {:foo, :bar, :baz}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.delete_at(tuple, index) <response> Removes an element from a tuple.\n\nDeletes the element at the given `index` from `tuple`.\nRaises an `ArgumentError` if `index` is negative or greater than\nor equal to the length of `tuple`. Index is zero-based.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.delete_at(tuple, 0)\n    {:bar, :baz}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.duplicate(data, size) <response> Creates a new tuple.\n\nCreates a tuple of `size` containing the\ngiven `data` at every position.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Tuple.duplicate(:hello, 3)\n    {:hello, :hello, :hello}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.insert_at(tuple, index, value) <response> Inserts an element into a tuple.\n\nInserts `value` into `tuple` at the given `index`.\nRaises an `ArgumentError` if `index` is negative or greater than the\nlength of `tuple`. Index is zero-based.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:bar, :baz}\n    iex> Tuple.insert_at(tuple, 0, :foo)\n    {:foo, :bar, :baz}\n    iex> Tuple.insert_at(tuple, 2, :bong)\n    {:bar, :baz, :bong}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.product(tuple) <response> Computes a product of tuple elements.\n\n## Examples\n\n    iex> Tuple.product({255, 255})\n    65025\n    iex> Tuple.product({255, 1.0})\n    255.0\n    iex> Tuple.product({})\n    1"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.sum(tuple) <response> Computes a sum of tuple elements.\n\n## Examples\n\n    iex> Tuple.sum({255, 255})\n    510\n    iex> Tuple.sum({255, 0.0})\n    255.0\n    iex> Tuple.sum({})\n    0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.to_list(tuple) <response> Converts a tuple to a list.\n\nReturns a new list with all the tuple elements.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.to_list(tuple)\n    [:foo, :bar, :baz]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.Elixir.Tuple <response> Functions for working with tuples.\n\nPlease note the following functions for tuples are found in `Kernel`:\n\n  * `elem/2` - accesses a tuple by index\n  * `put_elem/3` - inserts a value into a tuple by index\n  * `tuple_size/1` - gets the number of elements in a tuple\n\nTuples are intended as fixed-size containers for multiple elements.\nTo manipulate a collection of elements, use a list instead. `Enum`\nfunctions do not work on tuples.\n\nTuples are denoted with curly braces:\n\n    iex> {}\n    {}\n    iex> {1, :two, \"three\"}\n    {1, :two, \"three\"}\n\nA tuple may contain elements of different types, which are stored\ncontiguously in memory. Accessing any element takes constant time,\nbut modifying a tuple, which produces a shallow copy, takes linear time.\nTuples are good for reading data while lists are better for traversals.\n\nTuples are typically used either when a function has multiple return values\nor for error handling. `File.read/1` returns `{:ok, contents}` if reading\nthe given file is successful, or else `{:error, reason}` such as when\nthe file does not exist.\n\nThe functions in this module that add and remove elements from tuples are\nrarely used in practice, as they typically imply tuples are being used as\ncollections. To append to a tuple, it is preferable to extract the elements\nfrom the old tuple with pattern matching, and then create a new tuple:\n\n    tuple = {:ok, :example}\n\n    # Avoid\n    result = Tuple.insert_at(tuple, 2, %{})\n\n    # Prefer\n    {:ok, atom} = tuple\n    result = {:ok, atom, %{}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.%URI{} <response> The URI struct.\n\nThe fields are defined to match the following URI representation\n(with field names between brackets):\n\n    [scheme]://[userinfo]@[host]:[port][path]?[query]#[fragment]\n\n\nNote the `authority` field is deprecated. `parse/1` will still\npopulate it for backwards compatibility but you should generally\navoid setting or getting it."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.append_query(uri, query) <response> Appends `query` to the given `uri`.\n\nThe given `query` is not automatically encoded, use `encode/2` or `encode_www_form/1`.\n\n## Examples\n\n    iex> URI.append_query(URI.parse(\"http://example.com/\"), \"x=1\") |> URI.to_string()\n    \"http://example.com/?x=1\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"y=2\") |> URI.to_string()\n    \"http://example.com/?x=1&y=2\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"x=2\") |> URI.to_string()\n    \"http://example.com/?x=1&x=2\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.char_reserved?(character) <response> Checks if `character` is a reserved one in a URI.\n\nAs specified in [RFC 3986, section 2.2](https://tools.ietf.org/html/rfc3986#section-2.2),\nthe following characters are reserved: `:`, `/`, `?`, `#`, `[`, `]`, `@`, `!`, `$`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `;`, `=`\n\n## Examples\n\n    iex> URI.char_reserved?(?+)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.char_unescaped?(character) <response> Checks if `character` is allowed unescaped in a URI.\n\nThis is the default used by `URI.encode/2` where both\n[reserved](`char_reserved?/1`) and [unreserved characters](`char_unreserved?/1`)\nare kept unescaped.\n\n## Examples\n\n    iex> URI.char_unescaped?(?{)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.char_unreserved?(character) <response> Checks if `character` is an unreserved one in a URI.\n\nAs specified in [RFC 3986, section 2.3](https://tools.ietf.org/html/rfc3986#section-2.3),\nthe following characters are unreserved:\n\n  * Alphanumeric characters: `A-Z`, `a-z`, `0-9`\n  * `~`, `_`, `-`, `.`\n\n## Examples\n\n    iex> URI.char_unreserved?(?_)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.decode(uri) <response> Percent-unescapes a URI.\n\n## Examples\n\n    iex> URI.decode(\"https%3A%2F%2Felixir-lang.org\")\n    \"https://elixir-lang.org\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.decode_query(query, map \\\\ %{}, encoding \\\\ :www_form) <response> Decodes `query` into a map.\n\nGiven a query string in the form of `key1=value1&key2=value2...`, this\nfunction inserts each key-value pair in the query string as one entry in the\ngiven `map`. Keys and values in the resulting map will be binaries. Keys and\nvalues will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.\n\nUse `query_decoder/1` if you want to iterate over each value manually.\n\n## Examples\n\n    iex> URI.decode_query(\"foo=1&bar=2\")\n    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{\"starting\" => \"map\"})\n    %{\"percent\" => \"oh yes!\", \"starting\" => \"map\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{}, :rfc3986)\n    %{\"percent\" => \"oh+yes!\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.decode_www_form(string) <response> Decodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.\n\n## Examples\n\n    iex> URI.decode_www_form(\"%3Call+in%2F\")\n    \"<all in/\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.default_port(scheme) <response> Returns the default port for a given `scheme`.\n\nIf the scheme is unknown to the `URI` module, this function returns\n`nil`. The default port for any scheme can be configured globally\nvia `default_port/2`.\n\n## Examples\n\n    iex> URI.default_port(\"ftp\")\n    21\n\n    iex> URI.default_port(\"ponzi\")\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.default_port(scheme, port) <response> Registers the default `port` for the given `scheme`.\n\nAfter this function is called, `port` will be returned by\n`default_port/1` for the given scheme `scheme`. Note that this function\nchanges the default port for the given `scheme` *globally*, meaning for\nevery application.\n\nIt is recommended for this function to be invoked in your\napplication's start callback in case you want to register\nnew URIs."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.encode(string, predicate \\\\ &char_unescaped?/1) <response> Percent-escapes all characters that require escaping in `string`.\n\nThis means reserved characters, such as `:` and `/`, and the\nso-called unreserved characters, which have the same meaning both\nescaped and unescaped, won't be escaped by default.\n\nSee `encode_www_form/1` if you are interested in escaping reserved\ncharacters too.\n\nThis function also accepts a `predicate` function as an optional\nargument. If passed, this function will be called with each byte\nin `string` as its argument and should return a truthy value (anything other\nthan `false` or `nil`) if the given byte should be left as is, or return a\nfalsy value (`false` or `nil`) if the character should be escaped. Defaults\nto `URI.char_unescaped?/1`.\n\n## Examples\n\n    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+Ð¹\")\n    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n\n    iex> URI.encode(\"a string\", &(&1 != ?i))\n    \"a str%69ng\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.encode_query(enumerable, encoding \\\\ :www_form) <response> Encodes `enumerable` into a query string using `encoding`.\n\nTakes an enumerable that enumerates as a list of two-element\ntuples (for instance, a map or a keyword list) and returns a string\nin the form of `key1=value1&key2=value2...`.\n\nKeys and values can be any term that implements the `String.Chars`\nprotocol with the exception of lists, which are explicitly forbidden.\n\nYou can specify one of the following `encoding` strategies:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are URL encoded as\n    per `encode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It encodes \" \" as \"+\".\n\n  * `:rfc3986` - (since v1.12.0) the same as `:www_form` except it encodes\n    \" \" as \"%20\" according [RFC 3986](https://tools.ietf.org/html/rfc3986).\n    This is the best option if you are encoding in a non-browser situation,\n    since encoding spaces as \"+\" can be ambiguous to URI parsers. This can\n    inadvertently lead to spaces being interpreted as literal plus signs.\n\nEncoding defaults to `:www_form` for backward compatibility.\n\n## Examples\n\n    iex> query = %{\"foo\" => 1, \"bar\" => 2}\n    iex> URI.encode_query(query)\n    \"bar=2&foo=1\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query)\n    \"key=value+with+spaces\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query, :rfc3986)\n    \"key=value%20with%20spaces\"\n\n    iex> URI.encode_query(%{key: [:a, :list]})\n    ** (ArgumentError) encode_query/2 values cannot be lists, got: [:a, :list]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.encode_www_form(string) <response> Encodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.\n\n## Example\n\n    iex> URI.encode_www_form(\"put: it+Ð¹\")\n    \"put%3A+it%2B%D0%B9\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.merge(uri, rel) <response> Merges two URIs.\n\nThis function merges two URIs as per\n[RFC 3986, section 5.2](https://tools.ietf.org/html/rfc3986#section-5.2).\n\n## Examples\n\n    iex> URI.merge(URI.parse(\"http://google.com\"), \"/query\") |> to_string()\n    \"http://google.com/query\"\n\n    iex> URI.merge(\"http://example.com\", \"http://google.com\") |> to_string()\n    \"http://google.com\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.new(uri) <response> Creates a new URI struct from a URI or a string.\n\nIf a `%URI{}` struct is given, it returns `{:ok, uri}`. If a string is\ngiven, it will parse and validate it. If the string is valid, it returns\n`{:ok, uri}`, otherwise it returns `{:error, part}` with the invalid part\nof the URI. For parsing URIs without further validation, see `parse/1`.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\n`nil` or not.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.\n\n## Examples\n\n    iex> URI.new(\"https://elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//[fe80::]/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"fe80::\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"https:?query\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: nil,\n      port: 443,\n      query: \"query\",\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/invalid_greater_than_in_path/>\")\n    {:error, \">\"}\n\nGiving an existing URI simply returns it wrapped in a tuple:\n\n    iex> {:ok, uri} = URI.new(\"https://elixir-lang.org/\")\n    iex> URI.new(uri)\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.new!(uri) <response> Similar to `new/1` but raises `URI.Error` if an invalid string is given.\n\n## Examples\n\n    iex> URI.new!(\"https://elixir-lang.org/\")\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.new!(\"/invalid_greater_than_in_path/>\")\n    ** (URI.Error) cannot parse due to reason invalid_uri: \">\"\n\nGiving an existing URI simply returns it:\n\n    iex> uri = URI.new!(\"https://elixir-lang.org/\")\n    iex> URI.new!(uri)\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.parse(uri) <response> Parses a URI into its components, without further validation.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\nnil or not. Furthermore, this function expects both absolute and\nrelative URIs to be well-formed and does not perform any validation.\nSee the \"Examples\" section below. Use `new/1` if you want to validate\nthe URI fields after parsing.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.\n\nIf a `%URI{}` struct is given to this function, this function returns it\nunmodified.\n\n> Note: this function sets the field :authority for backwards\n> compatibility reasons but it is deprecated.\n\n## Examples\n\n    iex> URI.parse(\"https://elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"//elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"/foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nIn contrast to `URI.new/1`, this function will parse poorly-formed\nURIs, for example:\n\n    iex> URI.parse(\"/invalid_greater_than_in_path/>\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/invalid_greater_than_in_path/>\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nAnother example is a URI with brackets in query strings. It is accepted\nby `parse/1`, it is commonly accepted by browsers, but it will be refused\nby `new/1`:\n\n    iex> URI.parse(\"/?foo[bar]=baz\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/\",\n      port: nil,\n      query: \"foo[bar]=baz\",\n      scheme: nil,\n      userinfo: nil\n    }"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.query_decoder(query, encoding \\\\ :www_form) <response> Returns a stream of two-element tuples representing key-value pairs in the\ngiven `query`.\n\nKey and value in each tuple will be binaries and will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.\n\n## Examples\n\n    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.to_list()\n    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\") |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water please\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\", :rfc3986) |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water+please\"}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.to_string(uri) <response> Returns the string representation of the given [URI struct](`t:t/0`).\n\n## Examples\n\n    iex> uri = URI.parse(\"http://google.com\")\n    iex> URI.to_string(uri)\n    \"http://google.com\"\n\n    iex> uri = URI.parse(\"foo://bar.baz\")\n    iex> URI.to_string(uri)\n    \"foo://bar.baz\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.Elixir.URI <response> Utilities for working with URIs.\n\nThis module provides functions for working with URIs (for example, parsing\nURIs or encoding query strings). The functions in this module are implemented\naccording to [RFC 3986](https://tools.ietf.org/html/rfc3986)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.Requirement.Elixir.Version.Requirement <response> A struct that holds version requirement information.\n\nThe struct fields are private and should not be accessed.\n\nSee the \"Requirements\" section in the `Version` module\nfor more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.%Version{} <response> The Version struct.\n\nIt contains the fields `:major`, `:minor`, `:patch`, `:pre`, and\n`:build` according to SemVer 2.0, where `:pre` is a list.\n\nYou can read those fields but you should not create a new `Version`\ndirectly via the struct syntax. Instead use the functions in this\nmodule."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.compare(version1, version2) <response> Compares two versions.\n\nReturns `:gt` if the first version is greater than the second one, and `:lt`\nfor vice versa. If the two versions are equal, `:eq` is returned.\n\nPre-releases are strictly less than their corresponding release versions.\n\nPatch segments are compared lexicographically if they are alphanumeric, and\nnumerically otherwise.\n\nBuild segments are ignored: if two versions differ only in their build segment\nthey are considered to be equal.\n\nRaises a `Version.InvalidVersionError` exception if any of the two given\nversions are not parsable. If given an already parsed version this function\nwon't raise.\n\n## Examples\n\n    iex> Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n    :gt\n\n    iex> Version.compare(\"1.0.0-beta\", \"1.0.0-rc1\")\n    :lt\n\n    iex> Version.compare(\"1.0.0-10\", \"1.0.0-2\")\n    :gt\n\n    iex> Version.compare(\"2.0.1+build0\", \"2.0.1\")\n    :eq\n\n    iex> Version.compare(\"invalid\", \"2.0.1\")\n    ** (Version.InvalidVersionError) invalid version: \"invalid\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.compile_requirement(requirement) <response> Compiles a requirement to an internal representation that may optimize matching.\n\nThe internal representation is opaque."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.match?(version, requirement, opts \\\\ []) <response> Checks if the given version matches the specification.\n\nReturns `true` if `version` satisfies `requirement`, `false` otherwise.\nRaises a `Version.InvalidRequirementError` exception if `requirement` is not\nparsable, or a `Version.InvalidVersionError` exception if `version` is not parsable.\nIf given an already parsed version and requirement this function won't\nraise.\n\n## Options\n\n  * `:allow_pre` (boolean) - when `false`, pre-release versions will not match\n    unless the operand is a pre-release version. Defaults to `true`.\n    For examples, please refer to the table above under the \"Requirements\" section.\n\n## Examples\n\n    iex> Version.match?(\"2.0.0\", \"> 1.0.0\")\n    true\n\n    iex> Version.match?(\"2.0.0\", \"== 1.0.0\")\n    false\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\")\n    true\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\", allow_pre: false)\n    false\n\n    iex> Version.match?(\"foo\", \"== 1.0.0\")\n    ** (Version.InvalidVersionError) invalid version: \"foo\"\n\n    iex> Version.match?(\"2.0.0\", \"== == 1.0.0\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 1.0.0\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.parse(string) <response> Parses a version string into a `Version` struct.\n\n## Examples\n\n    iex> Version.parse(\"2.0.1-alpha1\")\n    {:ok, %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}}\n\n    iex> Version.parse(\"2.0-alpha1\")\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.parse!(string) <response> Parses a version string into a `Version`.\n\nIf `string` is an invalid version, a `Version.InvalidVersionError` is raised.\n\n## Examples\n\n    iex> Version.parse!(\"2.0.1-alpha1\")\n    %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}\n\n    iex> Version.parse!(\"2.0-alpha1\")\n    ** (Version.InvalidVersionError) invalid version: \"2.0-alpha1\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.parse_requirement(string) <response> Parses a version requirement string into a `Version.Requirement` struct.\n\n## Examples\n\n    iex> {:ok, requirement} = Version.parse_requirement(\"== 2.0.1\")\n    iex> requirement\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement(\"== == 2.0.1\")\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.parse_requirement!(string) <response> Parses a version requirement string into a `Version.Requirement` struct.\n\nIf `string` is an invalid requirement, a `Version.InvalidRequirementError` is raised.\n\n# Examples\n\n    iex> Version.parse_requirement!(\"== 2.0.1\")\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement!(\"== == 2.0.1\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 2.0.1\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.to_string(version) <response> Converts the given version to a string.\n\n### Examples\n\n    iex> Version.to_string(%Version{major: 1, minor: 2, patch: 3})\n    \"1.2.3\"\n    iex> Version.to_string(Version.parse!(\"1.14.0-rc.0+build0\"))\n    \"1.14.0-rc.0+build0\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.Elixir.Version <response> Functions for parsing and matching versions against requirements.\n\nA version is a string in a specific format or a `Version`\ngenerated after parsing via `Version.parse/1`.\n\nAlthough Elixir projects are not required to follow SemVer,\nthey must follow the format outlined on [SemVer 2.0 schema](https://semver.org/)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.Elixir.Version <response> Versions\n\nIn a nutshell, a version is represented by three numbers:\n\n    MAJOR.MINOR.PATCH\n\nPre-releases are supported by optionally appending a hyphen and a series of\nperiod-separated identifiers immediately following the patch version.\nIdentifiers consist of only ASCII alphanumeric characters and hyphens (`[0-9A-Za-z-]`):\n\n    \"1.0.0-alpha.3\"\n\nBuild information can be added by appending a plus sign and a series of\ndot-separated identifiers immediately following the patch or pre-release version.\nIdentifiers consist of only ASCII alphanumeric characters and hyphens (`[0-9A-Za-z-]`):\n\n    \"1.0.0-alpha.3+20130417140000.amd64\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.Elixir.Version <response> Requirements\n\nRequirements allow you to specify which versions of a given\ndependency you are willing to work against. Requirements support the common\ncomparison operators such as `>`, `>=`, `<`, `<=`, and `==` that work as one\nwould expect, and additionally the special operator `~>` described in detail\nfurther below.\n\n    # Only version 2.0.0\n    \"== 2.0.0\"\n\n    # Anything later than 2.0.0\n    \"> 2.0.0\"\n\nRequirements also support `and` and `or` for complex conditions:\n\n    # 2.0.0 and later until 2.1.0\n    \">= 2.0.0 and < 2.1.0\"\n\nSince the example above is such a common requirement, it can\nbe expressed as:\n\n    \"~> 2.0.0\"\n\n`~>` will never include pre-release versions of its upper bound,\nregardless of the usage of the `:allow_pre` option, or whether the operand\nis a pre-release version. It can also be used to set an upper bound on only the major\nversion part. See the table below for `~>` requirements and\ntheir corresponding translations.\n\n`~>`           | Translation\n:------------- | :---------------------\n`~> 2.0.0`     | `>= 2.0.0 and < 2.1.0`\n`~> 2.1.2`     | `>= 2.1.2 and < 2.2.0`\n`~> 2.1.3-dev` | `>= 2.1.3-dev and < 2.2.0`\n`~> 2.0`       | `>= 2.0.0 and < 3.0.0`\n`~> 2.1`       | `>= 2.1.0 and < 3.0.0`\n\nThe requirement operand after the `~>` is allowed to omit the patch version,\nallowing us to express `~> 2.1` or `~> 2.1-dev`, something that wouldn't be allowed\nwhen using the common comparison operators.\n\nWhen the `:allow_pre` option is set `false` in `Version.match?/3`, the requirement\nwill not match a pre-release version unless the operand is a pre-release version.\nThe default is to always allow pre-releases but note that in\nHex `:allow_pre` is set to `false`. See the table below for examples.\n\nRequirement    | Version     | `:allow_pre`      | Matches\n:------------- | :---------- | :---------------- | :------\n`~> 2.0`       | `2.1.0`     | `true` or `false` | `true`\n`~> 2.0`       | `3.0.0`     | `true` or `false` | `false`\n`~> 2.0.0`     | `2.0.5`     | `true` or `false` | `true`\n`~> 2.0.0`     | `2.1.0`     | `true` or `false` | `false`\n`~> 2.1.2`     | `2.1.6-dev` | `true`            | `true`\n`~> 2.1.2`     | `2.1.6-dev` | `false`           | `false`\n`~> 2.1-dev`   | `2.2.0-dev` | `true` or `false` | `true`\n`~> 2.1.2-dev` | `2.1.6-dev` | `true` or `false` | `true`\n`>= 2.1.0`     | `2.2.0-dev` | `true`            | `true`\n`>= 2.1.0`     | `2.2.0-dev` | `false`           | `false`\n`>= 2.1.0-dev` | `2.2.6-dev` | `true` or `false` | `true`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.add_backend(backend, opts \\\\ []) <response> Adds a new backend.\n\nAdding a backend calls the `init/1` function in that backend\nwith the name of the backend as its argument. For example,\ncalling\n\n    Logger.add_backend(MyBackend)\n\nwill call `MyBackend.init(MyBackend)` to initialize the new\nbackend. If the backend's `init/1` callback returns `{:ok, _}`,\nthen this function returns `{:ok, pid}`. If the handler returns\n`{:error, :ignore}` from `init/1`, this function still returns\n`{:ok, pid}` but the handler is not started. If the handler\nreturns `{:error, reason}` from `init/1`, this function returns\n`{:error, {reason, info}}` where `info` is more information on\nthe backend that failed to start.\n\nBackends added by this function are not persisted. Therefore\nif the Logger application or supervision tree is restarted,\nthe backend won't be available. If you need this guarantee,\nthen configure the backend via the application environment:\n\n    config :logger, :backends, [MyBackend]\n\n## Options\n\n  * `:flush` - when `true`, guarantees all messages currently sent\n    to `Logger` are processed before the backend is added\n\n## Examples\n\n    {:ok, _pid} = Logger.add_backend(MyBackend, flush: true)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.add_translator(translator) <response> Adds a new translator."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.bare_log(level, message_or_fun, metadata \\\\ []) <response> Logs a message dynamically.\n\nOpposite to `log/3`, `debug/2`, `info/2`, and friends, the arguments\ngiven to `bare_log/3` are always evaluated. However, you can pass\nanonymous functions to `bare_log/3` and they will only be evaluated\nif there is something to be logged."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.compare_levels(left, right) <response> Compares log levels.\n\nReceives two log levels and compares the `left` level\nagainst the `right` level and returns:\n\n  * `:lt` if `left` is less than `right`\n  * `:eq` if `left` and `right` are equal\n  * `:gt` if `left` is greater than `right`\n\n## Examples\n\n    iex> Logger.compare_levels(:debug, :warning)\n    :lt\n    iex> Logger.compare_levels(:error, :info)\n    :gt"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.configure(options) <response> Configures the logger.\n\nSee the \"Runtime Configuration\" section in the `Logger` module\ndocumentation for the available options. The changes done here\nare automatically persisted to the `:logger` application\nenvironment."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.configure_backend(backend, options) <response> Configures the given backend.\n\nThe backend needs to be started and running in order to\nbe configured at runtime."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_all_module_levels() <response> Resets the logging level for all modules to the primary level."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_application_level(appname) <response> Resets logging level for all modules in the given application to the primary level.\n\nEquivalent of:\n\n    appname |> Application.spec(:modules) |> Logger.delete_module_level()"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_module_level(module) <response> Resets the logging level for a given module to the primary level."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_process_level(pid) <response> Resets logging level for the current process to the primary level.\n\nCurrently the only accepted PID is `self()`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.disable(pid) <response> Disables logging for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nEquivalent of:\n\n    put_process_level(pid, :none)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.enable(pid) <response> Enables logging for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nEquivalent of:\n\n    delete_process_level(pid)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.enabled?(pid) <response> Returns whether the logging is enabled for a given process.\n\nCurrently the only accepted PID is `self()`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.flush() <response> Flushes the logger.\n\nThis guarantees all messages sent to `Logger` prior to this call will\nbe processed. This is useful for testing and it should not be called\nin production code."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.get_module_level(mod) <response> Gets logging level for given module.\n\nThe returned value will be the effective value used. If no value\nwas set for a given module, then it will not be present in\nthe returned list."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.get_process_level(pid) <response> Gets logging level for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nThe returned value will be the effective value used. If no value\nwas set for a given process, then `nil` is returned."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.level() <response> Retrieves the `Logger` level.\n\nThe `Logger` level can be changed via `configure/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.metadata() <response> Reads the current process metadata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.metadata(keyword) <response> Alters the current process metadata according to the given keyword list.\n\nThis function will merge the given keyword list into the existing metadata,\nwith the exception of setting a key to `nil`, which will remove that key\nfrom the metadata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.put_application_level(appname, level) <response> Puts logging level for modules in a given application.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the project.\n\nEquivalent of:\n\n    appname |> Application.spec(:modules) |> Logger.put_module_level(level)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.put_module_level(mod, level) <response> Puts logging level for given module.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the project.\n\n## Example\n\n    defmodule Foo do\n      require Logger\n\n      def log, do: Logger.debug(\"foo\")\n    end\n\n    Logger.configure(level: :error)\n    Logger.put_module_level(Foo, :all)\n\n    Foo.log()\n    # This will print the message even if global level is :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.put_process_level(pid, level) <response> Puts logging level for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the running system."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.remove_backend(backend, opts \\\\ []) <response> Removes a backend.\n\n## Options\n\n  * `:flush` - when `true`, guarantees all messages currently sent\n    to `Logger` are processed before the backend is removed"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.remove_translator(translator) <response> Removes a translator."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.reset_metadata(keyword \\\\ []) <response> Resets the current process metadata to the given keyword list."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> A logger for Elixir applications.\n\nIt includes many features:\n\n  * Provides debug, info, warn, and error levels.\n\n  * Supports multiple backends which are automatically\n    supervised when plugged into `Logger`.\n\n  * Formats and truncates messages on the client\n    to avoid clogging `Logger` backends.\n\n  * Alternates between sync and async modes to remain\n    performant when required but also apply backpressure\n    when under stress.\n\n  * Integrates with Erlang's [`:logger`](`:logger`)\n    to convert terms to Elixir syntax.\n\n  * Allows overriding the logging level for a specific module,\n    application or process.\n\nLogging is useful for tracking when an event of interest happens in your\nsystem. For example, it may be helpful to log whenever a user is deleted.\n\n    def delete_user(user) do\n      Logger.info(\"Deleting user from the system: #{inspect(user)}\")\n      # ...\n    end\n\nThe `Logger.info/2` macro emits the provided message at the `:info`\nlevel. Note the arguments given to `info/2` will only be evaluated\nif a message is logged. For instance, if the Logger level is\nset to `:warning`, `:info` messages are never logged and therefore\nthe arguments given above won't even be executed.\n\nThere are additional macros for other levels.\n\nLogger also allows log commands to be removed altogether via the\n`:compile_time_purge_matching` option (see below).\n\nFor dynamically logging messages, see `bare_log/3`. But note that\n`bare_log/3` always evaluates its arguments (unless the argument\nis an anonymous function)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Levels\n\nThe supported levels, ordered by importance, are:\n\n  * `:emergency` - when system is unusable, panics\n  * `:alert` - for alerts, actions that must be taken immediately,\n    ex. corrupted database\n  * `:critical` - for critical conditions\n  * `:error` - for errors\n  * `:warning` - for warnings\n  * `:notice` - for normal, but significant, messages\n  * `:info` - for information of any kind\n  * `:debug` - for debug-related messages\n\nFor example, `:info` takes precedence over `:debug`. If your log\nlevel is set to `:info`, then all `:info`, `:notice` and above will\nbe passed to backends. If your log level is set to `:alert`, only\n`:alert` and `:emergency` will be printed."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Message\n\nLogger can be used for logging both unstructured and structured data.\n\nUnstructured data is a string or a list of strings:\n\n    Logger.info(\"hello world!\")\n    Logger.info([\"hello \", \"world!\"])\n\nStructured data, also known as reports, are keyword lists and maps:\n\n    Logger.info([new_user: user.id, account_type: :admin])\n    Logger.info(%{new_user: user.id, account_type: :admin})\n\nLog functions also accept a zero-arity anonymous function as a message:\n\n    Logger.info(fn -> \"hello world!\" end)\n\nThe anonymous function can return a message or a tuple containing\nthe message and additional metadata (to be described in the next\nsection).\n\nIn all cases, the arguments given to the `Logger` macros are only\nevaluated if required by the current log level. The exception is\nthe `bare_log/3` function, which is the raw mechanism for logging."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Metadata\n\nWhenever a message is logged, additional information can be given\nvia metadata. Each log operation, such as `Logger.info/2`, allows\nmetadata to be given as an argument.\n\nFurthermore, metadata can be set per process with `Logger.metadata/1`.\n\nSome metadata, however, is always added automatically by Logger\nwhenever possible. Those are:\n\n  * `:application` - the current application\n\n  * `:mfa` - the current module, function and arity\n\n  * `:file` - the current file\n\n  * `:line` - the current line\n\n  * `:pid` - the current process identifier\n\n  * `:initial_call` - the initial call that started the process\n\n  * `:registered_name` - the process registered name as an atom\n\n  * `:domain` - a list of domains for the logged message. For example,\n    all Elixir reports default to `[:elixir]`. Erlang reports may start\n    with `[:otp]` or `[:sasl]`\n\n  * `:crash_reason` - a two-element tuple with the throw/error/exit reason\n    as first argument and the stacktrace as second. A throw will always be\n    `{:nocatch, term}`. An error is always an `Exception` struct. All other\n    entries are exits. The console backend ignores this metadata by default\n    but it can be useful to other backends, such as the ones that report\n    errors to third-party services\n\nNote that all metadata is optional and may not always be available.\nThe `:mfa`, `:file`, `:line`, and similar metadata are automatically\nincluded when using `Logger` macros. `Logger.bare_log/3` does not include\nany metadata beyond the `:pid` by default. Other metadata, such as\n`:crash_reason`, `:initial_call`, and `:registered_name` are available\nonly inside behaviours such as GenServer, Supervisor, and others.\n\nFor example, you might wish to include a custom `:error_code` metadata in\nyour logs:\n\n    Logger.error(\"We have a problem\", [error_code: :pc_load_letter])\n\nIn your app's logger configuration, you would need to include the\n`:error_code` key and you would need to include `$metadata` as part of\nyour log format template:\n\n    config :logger, :console,\n     format: \"[$level] $message $metadata\\n\",\n     metadata: [:error_code, :file]\n\nYour logs might then receive lines like this:\n\n    [error] We have a problem error_code=pc_load_letter file=lib/app.ex"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Configuration\n\n`Logger` supports a wide range of configurations.\n\nThis configuration is split in three categories:\n\n  * Application configuration - must be set before the `:logger`\n    application is started\n\n  * Runtime configuration - can be set before the `:logger`\n    application is started, but may be changed during runtime\n\n  * Erlang configuration - options that handle integration with\n    Erlang's logging facilities"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Application configuration\n\nThe following configuration must be set via config files (such as\n`config/config.exs`) before the `:logger` application is started.\n\n  * `:backends` - the backends to be used. Defaults to `[:console]`.\n    See the \"Backends\" section for more information.\n\n  * `:compile_time_application` - sets the `:application` metadata value\n    to the configured value at compilation time. This configuration is\n    automatically set by Mix and made available as metadata when logging.\n\n  * `:compile_time_purge_matching` - purges *at compilation time* all calls\n    that match the given conditions. This means that `Logger` calls with\n    level lower than this option will be completely removed at compile time,\n    accruing no overhead at runtime. This configuration expects a list of\n    keyword lists. Each keyword list contains a metadata key and the matching\n    value that should be purged. Some special keys are supported:\n\n      * `:level_lower_than` - purges all messages with a lower logger level\n      * `:module` - purges all messages with the matching module\n      * `:function` - purges all messages with the \"function/arity\"\n\n    Remember that if you want to purge log calls from a dependency, the\n    dependency must be recompiled.\n\n  * `:start_options` - passes start options to Logger's main process, such\n    as `:spawn_opt` and `:hibernate_after`. All options in `t:GenServer.option/0`\n    are accepted, except `:name`.\n\nFor example, to configure the `:backends` and purge all calls that happen\nat compile time with level lower than `:info` in a `config/config.exs` file:\n\n    config :logger,\n      backends: [:console],\n      compile_time_purge_matching: [\n        [level_lower_than: :info]\n      ]\n\nIf you want to purge all log calls from an application named `:foo` and only\nkeep errors from `Bar.foo/3`, you can set up two different matches:\n\n    config :logger,\n      compile_time_purge_matching: [\n        [application: :foo],\n        [module: Bar, function: \"foo/3\", level_lower_than: :error]\n      ]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Runtime Configuration\n\nAll configuration below can be set via config files (such as\n`config/config.exs`) but also changed dynamically during runtime via\n`Logger.configure/1`.\n\n  * `:level` - the logging level. Attempting to log any message\n    with severity less than the configured level will simply\n    cause the message to be ignored. Keep in mind that each backend\n    may have its specific level, too. In addition to levels mentioned\n    above it also supports 2 \"meta-levels\":\n\n      - `:all` - all messages will be logged, conceptually identical to\n        `:debug`\n      - `:none` - no messages will be logged at all\n\n  * `:utc_log` - when `true`, uses UTC in logs. By default it uses\n    local time (i.e., it defaults to `false`).\n\n  * `:truncate` - the maximum message size to be logged (in bytes).\n    Defaults to 8192 bytes. Note this configuration is approximate.\n    Truncated messages will have `\" (truncated)\"` at the end.\n    The atom `:infinity` can be passed to disable this behavior.\n\n  * `:sync_threshold` - if the `Logger` manager has more than\n    `:sync_threshold` messages in its queue, `Logger` will change\n    to *sync mode*, to apply backpressure to the clients.\n    `Logger` will return to *async mode* once the number of messages\n    in the queue is reduced to one below the `sync_threshold`.\n    Defaults to 20 messages. `:sync_threshold` can be set to `0` to\n    force *sync mode*.\n\n  * `:discard_threshold` - if the `Logger` manager has more than\n    `:discard_threshold` messages in its queue, `Logger` will change\n    to *discard mode* and messages will be discarded directly in the\n    clients. `Logger` will return to *sync mode* once the number of\n    messages in the queue is reduced to one below the `discard_threshold`.\n    Defaults to 500 messages.\n\n  * `:discard_threshold_periodic_check` - a periodic check that\n    checks and reports if logger is discarding messages. It logs a warning\n    message whenever the system is (or continues) in discard mode and\n    it logs a warning message whenever if the system was discarding messages\n    but stopped doing so after the previous check. By default it runs\n    every `30_000` milliseconds.\n\n  * `:translator_inspect_opts` - when translating OTP reports and\n    errors, the last message and state must be inspected in the\n    error reports. This configuration allow developers to change\n    how much and how the data should be inspected.\n\nFor example, to configure the `:level` and `:truncate` options in a\n`config/config.exs` file:\n\n    config :logger,\n      level: :warning,\n      truncate: 4096"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Erlang/OTP integration\n\nFrom Elixir v1.10, Elixir's Logger is fully integrated with Erlang's\nlogger. They share the same `Logger.level/0`, any metadata set with\n`Logger.metadata/1` applies to both, and so on.\n\nElixir also supports formatting Erlang reports using Elixir syntax.\nThis can be controlled with two configurations:\n\n  * `:handle_otp_reports` - redirects OTP reports to `Logger` so\n    they are formatted in Elixir terms. This effectively disables\n    Erlang standard logger. Defaults to `true`.\n\n  * `:handle_sasl_reports` - redirects supervisor, crash and\n    progress reports to `Logger` so they are formatted in Elixir\n    terms. Your application must guarantee `:sasl` is started before\n    `:logger`. This means you may see some initial reports written\n    in Erlang syntax until the Logger application kicks in.\n    Defaults to `false`. This option only has an effect if\n    `:handle_otp_reports` is true.\n\nFor example, to configure `Logger` to redirect all Erlang messages using a\n`config/config.exs` file:\n\n    config :logger,\n      handle_otp_reports: true,\n      handle_sasl_reports: true\n\nFurthermore, `Logger` allows messages sent by Erlang to be translated\ninto an Elixir format via translators. Translators can be added at any\ntime with the `add_translator/1` and `remove_translator/1` APIs. Check\n`Logger.Translator` for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Backends\n\n`Logger` supports different backends where log messages are written to.\n\nThe available backends by default are:\n\n  * `:console` - logs messages to the console (enabled by default).\n    `:console` is simply a shortcut for `Logger.Backends.Console`\n    (see its documentation for more information)\n\nDevelopers may also implement their own backends, an option that\nis explored in more detail below.\n\nThe initial backends are loaded via the `:backends` configuration,\nwhich must be set before the `:logger` application is started.\nHowever, by the time the Logger application starts, the code for your\nown and third-party backends may not yet be available. For this reason,\nit is preferred to add and remove backends via `add_backend/2` and\n`remove_backend/2` functions. This is often done in your\n`c:Application.start/2` callback:\n\n    @impl true\n    def start(_type, _args) do\n      Logger.add_backend(MyCustomBackend)\n\nThe backend can be configured either on the `add_backend/2` call:\n\n    @impl true\n    def start(_type, _args) do\n      Logger.add_backend(MyCustomBackend, some_config: ...)\n\nOr in your config files:\n\n    config :logger, MyCustomBackend,\n      some_config: ..."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Elixir custom backends\n\nAny developer can create their own `Logger` backend. Since `Logger`\nis an event manager powered by `:gen_event`, writing a new backend\nis a matter of creating an event handler, as described in the\n[`:gen_event`](`:gen_event`) documentation.\n\nFrom now on, we will be using the term \"event handler\" to refer\nto your custom backend, as we head into implementation details.\n\nOnce the `:logger` application starts, it installs all event handlers\nlisted under the `:backends` configuration into the `Logger` event\nmanager. The event manager and all added event handlers are automatically\nsupervised by `Logger`.\n\nNote that if a backend fails to start by returning `{:error, :ignore}`\nfrom its `init/1` callback, then it's not added to the backends but\nnothing fails. If a backend fails to start by returning `{:error, reason}`\nfrom its `init/1` callback, the `:logger` application will fail to start.\n\nOnce initialized, the handler should be designed to handle the\nfollowing events:\n\n  * `{level, group_leader, {Logger, message, timestamp, metadata}}` where:\n    * `level` is one of `:debug`, `:info`, `:warn`, or `:error`, as previously\n      described (for compatibility with pre 1.10 backends the `:notice` will\n      be translated to `:info` and all messages above `:error` will be translated\n      to `:error`)\n    * `group_leader` is the group leader of the process which logged the message\n    * `{Logger, message, timestamp, metadata}` is a tuple containing information\n      about the logged message:\n      * the first element is always the atom `Logger`\n      * `message` is the actual message (as chardata)\n      * `timestamp` is the timestamp for when the message was logged, as a\n        `{{year, month, day}, {hour, minute, second, millisecond}}` tuple\n      * `metadata` is a keyword list of metadata used when logging the message\n\n  * `:flush`\n\nIt is recommended that handlers ignore messages where the group\nleader is in a different node than the one where the handler is\ninstalled. For example:\n\n    def handle_event({_level, gl, {Logger, _, _, _}}, state)\n        when node(gl) != node() do\n      {:ok, state}\n    end\n\nIn the case of the event `:flush` handlers should flush any pending\ndata. This event is triggered by `Logger.flush/0`.\n\nFurthermore, backends can be configured via the `configure_backend/2`\nfunction which requires event handlers to handle calls of the\nfollowing format:\n\n    {:configure, options}\n\nwhere `options` is a keyword list. The result of the call is the result\nreturned by `configure_backend/2`. The recommended return value for\nsuccessful configuration is `:ok`. For example:\n\n    def handle_call({:configure, options}, state) do\n      new_state = reconfigure_state(state, options)\n      {:ok, :ok, new_state}\n    end\n\nIt is recommended that backends support at least the following configuration\noptions:\n\n  * `:level` - the logging level for that backend\n  * `:format` - the logging format for that backend\n  * `:metadata` - the metadata to include in that backend\n\nCheck the `Logger.Backends.Console` implementation in Elixir's codebase\nfor examples on how to handle the recommendations in this section and\nhow to process the existing options."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Erlang/OTP handlers\n\nWhile Elixir Logger provides backends, Erlang/OTP logger provides handlers.\nThey represent the same concept: the ability to integrate into the logging\nsystem to handle each logged message/event.\n\nHowever, implementation-wise, they have the following differences:\n\n  * Elixir backends run in a separate process which comes with overload\n    protection. However, because this process is a single GenEvent, any\n    long running action should be avoided, as it can lead to bottlenecks\n    in the system\n\n  * Erlang handlers run in the same process as the process logging the\n    message/event. This gives developers more flexibility but they should\n    avoid performing any long running action in such handlers, as it may\n    slow down the action being executed considerably. At the moment, there\n    is no built-in overload protection for Erlang handlers, so it is your\n    responsibility to implement it\n\nThe good news is that developers can use third-party implementations of\nboth Elixir backends and Erlang handlers. We have already covered Elixir\nbackends, so let's see how to add Erlang/OTP handlers.\n\nErlang/OTP handlers must be listed under your own application:\n\n    config :my_app, :logger, [\n      {:handler, :name_of_the_handler, ACustomHandler, configuration = %{}}\n    ]\n\nAnd then, explicitly attached in your `c:Application.start/2` callback:\n\n    :logger.add_handlers(:my_app)\n\nNote we do not recommend configuring Erlang/OTP's logger directly under\nthe `:kernel` application in your `config/config.exs`, like this:\n\n    # Not recommended:\n    config :kernel, :logger, ...\n\nThis is because by the time Elixir starts, Erlang's kernel has already\nbeen started, which means the configuration above would have no effect."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.App.stop() <response> Stops the application without sending messages to error logger."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.child_spec(init_arg) <response> Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.start_link(_) <response> Starts the backend supervisor."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.translate_backend(other) <response> Translates the shortcut backend name into its handler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.unwatch(backend) <response> Removes the given `backend`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.watch(backend) <response> Watches the given `backend`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Backends.Console.Elixir.Logger.Backends.Console <response> A logger backend that logs messages by printing them to the console."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Backends.Console.Elixir.Logger.Backends.Console <response> Options\n\n  * `:level` - the level to be logged by this backend.\n    Note that messages are filtered by the general\n    `:level` configuration for the `:logger` application first.\n\n  * `:format` - the format message used to print logs.\n    Defaults to: `\"\\n$time $metadata[$level] $message\\n\"`.\n    It may also be a `{module, function}` tuple that is invoked\n    with the log level, the message, the current timestamp and\n    the metadata and must return `t:IO.chardata/0`. See\n    `Logger.Formatter`.\n\n  * `:metadata` - the metadata to be printed by `$metadata`.\n    Defaults to an empty list (no metadata).\n    Setting `:metadata` to `:all` prints all metadata. See\n    the \"Metadata\" section for more information.\n\n  * `:colors` - a keyword list of coloring options.\n\n  * `:device` - the device to log error messages to. Defaults to\n    `:user` but can be changed to something else such as `:standard_error`.\n\n  * `:max_buffer` - maximum events to buffer while waiting\n    for a confirmation from the IO device (default: 32).\n    Once the buffer is full, the backend will block until\n    a confirmation is received.\n\nThe supported keys in the `:colors` keyword list are:\n\n  * `:enabled` - boolean value that allows for switching the\n    coloring on and off. Defaults to: `IO.ANSI.enabled?/0`\n\n  * `:debug` - color for debug messages. Defaults to: `:cyan`\n\n  * `:info` - color for info and notice messages. Defaults to: `:normal`\n\n  * `:warning` - color for warning messages. Defaults to: `:yellow`\n\n  * `:error` - color for error and higher messages. Defaults to: `:red`\n\nSee the `IO.ANSI` module for a list of colors and attributes.\n\nHere is an example of how to configure the `:console` backend in a\n`config/config.exs` file:\n\n    config :logger, :console,\n      format: \"\\n$time $metadata[$level] $message\\n\",\n      metadata: [:user_id]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Filter.filter_elixir_domain(map, extra) <response> Filter messages logged via `Logger` module when not logging OTP reports."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Filter.process_level(map, extra) <response> Filter out logs if current process opted out of certain levels."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Filter.silence_logger_exit(arg1, extra) <response> A filter that waits until Logger exits and then removes itself."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.compile(pattern) <response> Compiles a format string into a data structure that `format/5` can handle.\n\nCheck the module doc for documentation on the valid parameters that\nwill be interpolated in the pattern. If you pass `nil` as the pattern,\nthe pattern defaults to:\n\n    \"\\n$time $metadata[$level] $message\\n\"\n\nIf you want to customize formatting through a custom formatter, you can\npass a `{module, function}` tuple as the `pattern`.\n\n    iex> Logger.Formatter.compile(\"$time $metadata [$level] $message\\n\")\n    [:time, \" \", :metadata, \" [\", :level, \"] \", :message, \"\\n\"]\n\n    iex> Logger.Formatter.compile({MyLoggerFormatter, :format})\n    {MyLoggerFormatter, :format}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.format(pattern_or_function, level, message, timestamp, metadata) <response> Takes a compiled format and injects the level, timestamp, message, and\nmetadata keyword list and returns a properly formatted string.\n\nIf `pattern_or_function` is a `{module, function_name}` tuple,\nthen `module.function_name(level, message, timestamp, metadata)` is\ninvoked to get the message. See `Logger.Backends.Console` for more\ninformation on this.\n\n## Examples\n\n    iex> pattern = Logger.Formatter.compile(\"[$level] $message\")\n    iex> timestamp = {{1977, 01, 28}, {13, 29, 00, 000}}\n    iex> formatted = Logger.Formatter.format(pattern, :info, \"hello\", timestamp, [])\n    iex> IO.chardata_to_string(formatted)\n    \"[info] hello\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.format_date(arg) <response> Formats date as chardata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.format_time(arg) <response> Formats time as chardata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.prune(binary) <response> Prunes invalid Unicode code points from lists and invalid UTF-8 bytes.\n\nTypically called after formatting when the data cannot be printed."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Conveniences for formatting data for logs.\n\nThis module allows developers to specify a `{module, function}`\nor a string that serves as template for log messages."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Formatting string\n\nThe log messages can be controlled by a formatting string.\nHere is an example of how to configure the `:console` backend\nin a `config/config.exs` file:\n\nFor example:\n\n    config :logger, :console,\n      format: \"$time $metadata[$level] $message\\n\"\n\nThe above will print error messages as:\n\n    18:43:12.439 user_id=13 [error] Hello\\n\n\nThe valid parameters you can use are:\n\n  * `$time`     - the time the log message was sent\n  * `$date`     - the date the log message was sent\n  * `$message`  - the log message\n  * `$level`    - the log level\n  * `$node`     - the node that prints the message\n  * `$metadata` - user controlled data presented in `\"key=val key2=val2 \"` format\n\nBackends typically allow developers to supply such control\nstrings via configuration files. This module provides `compile/1`,\nwhich compiles the string into a format for fast operations at\nruntime and `format/5` to format the compiled pattern into an\nactual IO data."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Formatting function\n\nYou can also customize the format of your log messages to a\n`{module, function}` tuple if you wish to provide your own\nformat function. Here is an example of how to configure the\n`:console` backend in a `config/config.exs` file:\n\n    config :logger, :console,\n      format: {MyConsoleLogger, :format}\n\nAnd here is an example of how you can define `MyConsoleLogger.format/4`\nfrom the above configuration:\n\n    defmodule MyConsoleLogger do\n      @spec format(atom, term, Logger.Formatter.time(), keyword()) :: IO.chardata()\n      def format(level, message, timestamp, metadata) do\n        # Custom formatting logic that must return chardata.\n        # ...\n      end\n    end\n\n**The `format/4` function must not fail**. If it does, it will bring\nthat particular logger instance down, causing your system to temporarily\nlose log messages. If necessary, wrap the function in a `rescue` and\nlog a default message instead:\n\n    defmodule MyConsoleLogger do\n      def format(level, message, timestamp, metadata) do\n        # Custom formatting logic\n      rescue\n        _ -> \"could not format: #{inspect({level, message, metadata})}\"\n      end\n    end\n\nThe `{module, function}` will be invoked with four arguments:\n\n  * the log level: an atom (`t:atom/0`)\n  * the message: this is usually `t:IO.chardata/0`, but in some cases it\n    may contain invalid data. Since the formatting function must\n    *never* fail, you need to prepare for the message being anything\n  * the current timestamp: a term of type `t:Logger.Formatter.time/0`\n  * the metadata: a keyword list (`t:keyword/0`)\n\nThe `{module, function}` must return a term of type `t:IO.chardata/0`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Metadata\n\nMetadata to be sent to the logger can be read and written with\nthe `Logger.metadata/0` and `Logger.metadata/1` functions. For example,\nyou can set `Logger.metadata([user_id: 13])` to add user_id metadata\nto the current process. The user can configure the backend to choose\nwhich metadata it wants to print and it will replace the `$metadata`\nvalue."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Translator.translate(min_level, level, kind, message) <response> Built-in translation function."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Translator.Elixir.Logger.Translator <response> Default translation for Erlang log messages.\n\nLogger allows developers to rewrite log messages provided by\nOTP applications into a format more compatible with Elixir\nlog messages by providing a translator.\n\nA translator is simply a tuple containing a module and a function\nthat can be added and removed via the `Logger.add_translator/1` and\n`Logger.remove_translator/1` functions and is invoked for every Erlang\nmessage above the minimum log level with four arguments:\n\n  * `min_level` - the current Logger level\n  * `level` - the level of the message being translated\n  * `kind` - if the message is a `:report` or `:format`\n  * `message` - the message to format. If it is `:report`, it is a tuple\n    with `{report_type, report_data}`, if it is `:format`, it is a\n    tuple with `{format_message, format_args}`.\n\nThe function must return:\n\n  * `{:ok, chardata, metadata}` - if the message translation with its metadata\n  * `{:ok, chardata}` - the translated message\n  * `:skip` - if the message is not meant to be translated nor logged\n  * `:none` - if there is no translation, which triggers the next translator\n\nSee the function `translate/4` in this module for an example implementation\nand the default messages translated by Logger."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.scan_inspect(format, args, truncate, opts \\\\ %Inspect.Opts{}) <response> Receives a format string and arguments, scans them, and then replace `~p`,\n`~P`, `~w` and `~W` by its inspected variants.\n\nFor information about format scanning and how to consume them,\ncheck `:io_lib.scan_format/2`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.timestamp(timestamp \\\\ :os.system_time(:microsecond), utc_log?) <response> Returns a timestamp that includes milliseconds."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.truncate(chardata, n) <response> Truncates a `chardata` into `n` bytes.\n\nThere is a chance we truncate in the middle of a grapheme\ncluster but we never truncate in the middle of a binary\ncode point. For this reason, truncation is not exact."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Watcher.child_spec(init_arg) <response> Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Watcher.start_link(tuple) <response> Starts a watcher server.\n\nThis is useful when there is a need to start a handler\noutside of the handler supervision tree."}

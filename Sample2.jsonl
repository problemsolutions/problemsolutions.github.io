{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.chunk_every(enum, count, step, leftover \\\\ []) <response> Streams the enumerable in chunks, containing `count` elements each,\nwhere each new chunk starts `step` elements into the enumerable.\n\n`step` is optional and, if not passed, defaults to `count`, i.e.\nchunks do not overlap.\n\nIf the last chunk does not have `count` elements to fill the chunk,\nelements are taken from `leftover` to fill in the chunk. If `leftover`\ndoes not have enough elements to fill the chunk, then a partial chunk\nis returned with less than `count` elements.\n\nIf `:discard` is given in `leftover`, the last chunk is discarded\nunless it has exactly `count` elements.\n\n## Examples\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list()\n    [[1, 2], [3, 4], [5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list()\n    [[1, 2, 3], [4, 5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0])) |> Enum.to_list()\n    [[1, 2, 3], [4, 0, 0]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.chunk_while(enum, acc, chunk_fun, after_fun) <response> Chunks the `enum` with fine grained control when every chunk is emitted.\n\n`chunk_fun` receives the current element and the accumulator and\nmust return `{:cont, element, acc}` to emit the given chunk and\ncontinue with accumulator or `{:cont, acc}` to not emit any chunk\nand continue with the return accumulator.\n\n`after_fun` is invoked when iteration is done and must also return\n`{:cont, element, acc}` or `{:cont, acc}`.\n\n## Examples\n\n    iex> chunk_fun = fn element, acc ->\n    ...>   if rem(element, 2) == 0 do\n    ...>     {:cont, Enum.reverse([element | acc]), []}\n    ...>   else\n    ...>     {:cont, [element | acc]}\n    ...>   end\n    ...> end\n    iex> after_fun = fn\n    ...>   [] -> {:cont, []}\n    ...>   acc -> {:cont, Enum.reverse(acc), []}\n    ...> end\n    iex> stream = Stream.chunk_while(1..10, [], chunk_fun, after_fun)\n    iex> Enum.to_list(stream)\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.concat(enumerables) <response> Creates a stream that enumerates each enumerable in an enumerable.\n\n## Examples\n\n    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.concat(first, second) <response> Creates a stream that enumerates the first argument, followed by the second.\n\n## Examples\n\n    iex> stream = Stream.concat(1..3, 4..6)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> stream1 = Stream.cycle([1, 2, 3])\n    iex> stream2 = Stream.cycle([4, 5, 6])\n    iex> stream = Stream.concat(stream1, stream2)\n    iex> Enum.take(stream, 6)\n    [1, 2, 3, 1, 2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.cycle(enumerable) <response> Creates a stream that cycles through the given enumerable,\ninfinitely.\n\n## Examples\n\n    iex> stream = Stream.cycle([1, 2, 3])\n    iex> Enum.take(stream, 5)\n    [1, 2, 3, 1, 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.dedup(enum) <response> Creates a stream that only emits elements if they are different from the last emitted element.\n\nThis function only ever needs to store the last emitted element.\n\nElements are compared using `===/2`.\n\n## Examples\n\n    iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3, 2, 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.dedup_by(enum, fun) <response> Creates a stream that only emits elements if the result of calling `fun` on the element is\ndifferent from the (stored) result of calling `fun` on the last emitted element.\n\n## Examples\n\n    iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}, {1, :x}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.drop(enum, n) <response> Lazily drops the next `n` elements from the enumerable.\n\nIf a negative `n` is given, it will drop the last `n` elements from\nthe collection. Note that the mechanism by which this is implemented\nwill delay the emission of any element until `n` additional elements have\nbeen emitted by the enum.\n\n## Examples\n\n    iex> stream = Stream.drop(1..10, 5)\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]\n\n    iex> stream = Stream.drop(1..10, -5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.drop_every(enum, nth) <response> Creates a stream that drops every `nth` element from the enumerable.\n\nThe first element is always dropped, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.drop_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.drop_every(1..1000, 1)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.drop_every([1, 2, 3, 4, 5], 0)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.drop_while(enum, fun) <response> Lazily drops elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.duplicate(value, n) <response> Duplicates the given element `n` times in a stream.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty stream is returned.\n\n## Examples\n\n    iex> stream = Stream.duplicate(\"hello\", 0)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.duplicate(\"hi\", 1)\n    iex> Enum.to_list(stream)\n    [\"hi\"]\n\n    iex> stream = Stream.duplicate(\"bye\", 2)\n    iex> Enum.to_list(stream)\n    [\"bye\", \"bye\"]\n\n    iex> stream = Stream.duplicate([1, 2], 3)\n    iex> Enum.to_list(stream)\n    [[1, 2], [1, 2], [1, 2]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.each(enum, fun) <response> Executes the given function for each element.\n\nThe values in the stream do not change, therefore this\nfunction is useful for adding side effects (like printing)\nto a stream. See `map/2` if producing a different stream\nis desired.\n\n## Examples\n\n    iex> stream = Stream.each([1, 2, 3], fn x -> send(self(), x) end)\n    iex> Enum.to_list(stream)\n    iex> receive do: (x when is_integer(x) -> x)\n    1\n    iex> receive do: (x when is_integer(x) -> x)\n    2\n    iex> receive do: (x when is_integer(x) -> x)\n    3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.filter(enum, fun) <response> Creates a stream that filters elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.flat_map(enum, mapper) <response> Maps the given `fun` over `enumerable` and flattens the result.\n\nThis function returns a new stream built by appending the result of invoking `fun`\non each element of `enumerable` together.\n\n## Examples\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [x, x * 2] end)\n    iex> Enum.to_list(stream)\n    [1, 2, 2, 4, 3, 6]\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [[x]] end)\n    iex> Enum.to_list(stream)\n    [[1], [2], [3]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.intersperse(enumerable, intersperse_element) <response> Lazily intersperses `intersperse_element` between each element of the enumeration.\n\n## Examples\n\n    iex> Stream.intersperse([1, 2, 3], 0) |> Enum.to_list()\n    [1, 0, 2, 0, 3]\n\n    iex> Stream.intersperse([1], 0) |> Enum.to_list()\n    [1]\n\n    iex> Stream.intersperse([], 0) |> Enum.to_list()\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.interval(n) <response> Creates a stream that emits a value after the given period `n`\nin milliseconds.\n\nThe values emitted are an increasing counter starting at `0`.\nThis operation will block the caller by the given interval\nevery time a new element is streamed.\n\nDo not use this function to generate a sequence of numbers.\nIf blocking the caller process is not necessary, use\n`Stream.iterate(0, & &1 + 1)` instead.\n\n## Examples\n\n    iex> Stream.interval(10) |> Enum.take(10)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.into(enum, collectable, transform \\\\ fn x -> x end) <response> Injects the stream values into the given collectable as a side-effect.\n\nThis function is often used with `run/1` since any evaluation\nis delayed until the stream is executed. See `run/1` for an example."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.iterate(start_value, next_fun) <response> Emits a sequence of values, starting with `start_value`. Successive\nvalues are generated by calling `next_fun` on the previous value.\n\n## Examples\n\n    iex> Stream.iterate(0, &(&1 + 1)) |> Enum.take(5)\n    [0, 1, 2, 3, 4]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.map(enum, fun) <response> Creates a stream that will apply the given function on\nenumeration.\n\n## Examples\n\n    iex> stream = Stream.map([1, 2, 3], fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.map_every(enum, nth, fun) <response> Creates a stream that will apply the given function on\nevery `nth` element from the enumerable.\n\nThe first element is always passed to the given function.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.map_every(1..10, 2, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n\n    iex> stream = Stream.map_every([1, 2, 3, 4, 5], 1, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.map_every(1..5, 0, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.reject(enum, fun) <response> Creates a stream that will reject elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [1, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.repeatedly(generator_fun) <response> Returns a stream generated by calling `generator_fun` repeatedly.\n\n## Examples\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Stream.repeatedly(&:rand.uniform/0) |> Enum.take(3)\n    [0.5455598952593053, 0.6039309974353404, 0.6684893034823949]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.resource(start_fun, next_fun, after_fun) <response> Emits a sequence of values for the given resource.\n\nSimilar to `transform/3` but the initial accumulated value is\ncomputed lazily via `start_fun` and executes an `after_fun` at\nthe end of enumeration (both in cases of success and failure).\n\nSuccessive values are generated by calling `next_fun` with the\nprevious accumulator (the initial value being the result returned\nby `start_fun`) and it must return a tuple containing a list\nof elements to be emitted and the next accumulator. The enumeration\nfinishes if it returns `{:halt, acc}`.\n\nAs the name says, this function is useful to stream values from\nresources.\n\n## Examples\n\n    Stream.resource(\n      fn -> File.open!(\"sample\") end,\n      fn file ->\n        case IO.read(file, :line) do\n          data when is_binary(data) -> {[data], file}\n          _ -> {:halt, file}\n        end\n      end,\n      fn file -> File.close(file) end\n    )\n\n    iex> Stream.resource(\n    ...>  fn ->\n    ...>    {:ok, pid} = StringIO.open(\"string\")\n    ...>    pid\n    ...>  end,\n    ...>  fn pid ->\n    ...>    case IO.getn(pid, \"\", 1) do\n    ...>      :eof -> {:halt, pid}\n    ...>      char -> {[char], pid}\n    ...>    end\n    ...>  end,\n    ...>  fn pid -> StringIO.close(pid) end\n    ...> ) |> Enum.to_list()\n    [\"s\", \"t\", \"r\", \"i\", \"n\", \"g\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.run(stream) <response> Runs the given stream.\n\nThis is useful when a stream needs to be run, for side effects,\nand there is no interest in its return result.\n\n## Examples\n\nOpen up a file, replace all `#` by `%` and stream to another file\nwithout loading the whole file in memory:\n\n    File.stream!(\"/path/to/file\")\n    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n    |> Stream.into(File.stream!(\"/path/to/other/file\"))\n    |> Stream.run()\n\nNo computation will be done until we call one of the `Enum` functions\nor `run/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.scan(enum, fun) <response> Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the first element in the enumerable\nas the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.scan(enum, acc, fun) <response> Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the given `acc` as the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.take(enum, count) <response> Lazily takes the next `count` elements from the enumerable and stops\nenumeration.\n\nIf a negative `count` is given, the last `count` values will be taken.\nFor such, the collection is fully enumerated keeping up to `2 * count`\nelements in memory. Once the end of the collection is reached,\nthe last `count` elements will be executed. Therefore, using\na negative `count` on an infinite collection will never return.\n\n## Examples\n\n    iex> stream = Stream.take(1..100, 5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take(1..100, -5)\n    iex> Enum.to_list(stream)\n    [96, 97, 98, 99, 100]\n\n    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 1, 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.take_every(enum, nth) <response> Creates a stream that takes every `nth` element from the enumerable.\n\nThe first element is always included, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.take_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [1, 3, 5, 7, 9]\n\n    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take_every(1..1000, 0)\n    iex> Enum.to_list(stream)\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.take_while(enum, fun) <response> Lazily takes elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.timer(n) <response> Creates a stream that emits a single value after `n` milliseconds.\n\nThe value emitted is `0`. This operation will block the caller by\nthe given time until the element is streamed.\n\n## Examples\n\n    iex> Stream.timer(10) |> Enum.to_list()\n    [0]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.transform(enum, acc, reducer) <response> Transforms an existing stream.\n\nIt expects an accumulator and a function that receives two arguments,\nthe stream element and the updated accumulator. It must return a tuple,\nwhere the first element is a new stream (often a list) or the atom `:halt`,\nand the second element is the accumulator to be used by the next element.\n\nNote: this function is equivalent to `Enum.flat_map_reduce/3`, except this\nfunction does not return the accumulator once the stream is processed.\n\n## Examples\n\n`Stream.transform/3` is useful as it can be used as the basis to implement\nmany of the functions defined in this module. For example, we can implement\n`Stream.take(enum, n)` as follows:\n\n    iex> enum = 1001..9999\n    iex> n = 3\n    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n    ...> end)\n    iex> Enum.to_list(stream)\n    [1001, 1002, 1003]\n\n`Stream.transform/5` further generalizes this function to allow wrapping\naround resources."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.transform(enum, start_fun, reducer, after_fun) <response> Similar to `Stream.transform/5`, except `last_fun` is not supplied.\n\nThis function can be seen as a combination of `Stream.resource/3` with\n`Stream.transform/3`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.transform(enum, start_fun, reducer, last_fun, after_fun) <response> Transforms an existing stream with function-based start, last, and after\ncallbacks.\n\nOnce transformation starts, `start_fun` is invoked to compute the initial\naccumulator. Then, for each element in the enumerable, the `reducer` function\nis invoked with the element and the accumulator, returning new elements and a\nnew accumulator, as in `transform/3`.\n\nOnce the collection is done, `last_fun` is invoked with the accumulator to\nemit any remaining items. Then `after_fun` is invoked, to close any resource,\nbut not emitting any new items. `last_fun` is only invoked if the given\nenumerable terminates successfully (either because it is done or it halted\nitself). `after_fun` is always invoked, therefore `after_fun` must be the\none used for closing resources."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.unfold(next_acc, next_fun) <response> Emits a sequence of values for the given accumulator.\n\nSuccessive values are generated by calling `next_fun` with the previous\naccumulator and it must return a tuple with the current value and next\naccumulator. The enumeration finishes if it returns `nil`.\n\n## Examples\n\n    iex> Stream.unfold(5, fn\n    ...>   0 -> nil\n    ...>   n -> {n, n - 1}\n    ...> end) |> Enum.to_list()\n    [5, 4, 3, 2, 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.uniq(enum) <response> Creates a stream that only emits elements if they are unique.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Examples\n\n    iex> Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.uniq_by(enum, fun) <response> Creates a stream that only emits elements if they are unique, by removing the\nelements for which function `fun` returned duplicate elements.\n\nThe function `fun` maps every element to a term which is used to\ndetermine if two elements are duplicates.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Example\n\n    iex> Stream.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}]\n\n    iex> Stream.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end) |> Enum.to_list()\n    [a: {:tea, 2}, c: {:coffee, 1}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.with_index(enum, offset \\\\ 0) <response> Creates a stream where each element in the enumerable will\nbe wrapped in a tuple alongside its index.\n\nIf an `offset` is given, we will index from the given offset instead of from zero.\n\n## Examples\n\n    iex> stream = Stream.with_index([1, 2, 3])\n    iex> Enum.to_list(stream)\n    [{1, 0}, {2, 1}, {3, 2}]\n\n    iex> stream = Stream.with_index([1, 2, 3], 3)\n    iex> Enum.to_list(stream)\n    [{1, 3}, {2, 4}, {3, 5}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip(enumerables) <response> Zips corresponding elements from a finite collection of enumerables\ninto one stream of tuples.\n\nThe zipping finishes as soon as any enumerable in the given collection completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([\"foo\", \"bar\", \"baz\"])\n    iex> Stream.zip([concat, [:a, :b, :c], cycle]) |> Enum.to_list()\n    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip(enumerable1, enumerable2) <response> Zips two enumerables together, lazily.\n\nThe zipping finishes as soon as either enumerable completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([:a, :b, :c])\n    iex> Stream.zip(concat, cycle) |> Enum.to_list()\n    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip_with(enumerables, zip_fun) <response> Lazily zips corresponding elements from a finite collection of enumerables into a new\nenumerable, transforming them with the `zip_fun` function as it goes.\n\nThe first element from each of the enums in `enumerables` will be put into a list which is then passed to\nthe one-arity `zip_fun` function. Then, the second elements from each of the enums are put into a list and passed to\n`zip_fun`, and so on until any one of the enums in `enumerables` completes.\n\nReturns a new enumerable with the results of calling `zip_fun`.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat], fn [a, b] -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat, 1..3], fn [a, b, c] -> a + b + c end) |> Enum.to_list()\n    [3, 6, 9]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip_with(enumerable1, enumerable2, zip_fun) <response> Lazily zips corresponding elements from two enumerables into a new one, transforming them with\nthe `zip_fun` function as it goes.\n\nThe `zip_fun` will be called with the first element from `enumerable1` and the first\nelement from `enumerable2`, then with the second element from each, and so on until\neither one of the enumerables completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with(concat, concat, fn a, b -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.Elixir.Stream <response> Functions for creating and composing streams.\n\nStreams are composable, lazy enumerables (for an introduction on\nenumerables, see the `Enum` module). Any enumerable that generates\nelements one by one during enumeration is called a stream. For example,\nElixir's `Range` is a stream:\n\n    iex> range = 1..5\n    1..5\n    iex> Enum.map(range, &(&1 * 2))\n    [2, 4, 6, 8, 10]\n\nIn the example above, as we mapped over the range, the elements being\nenumerated were created one by one, during enumeration. The `Stream`\nmodule allows us to map the range, without triggering its enumeration:\n\n    iex> range = 1..3\n    iex> stream = Stream.map(range, &(&1 * 2))\n    iex> Enum.map(stream, &(&1 + 1))\n    [3, 5, 7]\n\nNote that we started with a range and then we created a stream that is\nmeant to multiply each element in the range by 2. At this point, no\ncomputation was done. Only when `Enum.map/2` is called we actually\nenumerate over each element in the range, multiplying it by 2 and adding 1.\nWe say the functions in `Stream` are *lazy* and the functions in `Enum`\nare *eager*.\n\nDue to their laziness, streams are useful when working with large\n(or even infinite) collections. When chaining many operations with `Enum`,\nintermediate lists are created, while `Stream` creates a recipe of\ncomputations that are executed at a later moment. Let's see another\nexample:\n\n    1..3\n    |> Enum.map(&IO.inspect(&1))\n    |> Enum.map(&(&1 * 2))\n    |> Enum.map(&IO.inspect(&1))\n    1\n    2\n    3\n    2\n    4\n    6\n    #=> [2, 4, 6]\n\nNote that we first printed each element in the list, then multiplied each\nelement by 2 and finally printed each new value. In this example, the list\nwas enumerated three times. Let's see an example with streams:\n\n    stream = 1..3\n    |> Stream.map(&IO.inspect(&1))\n    |> Stream.map(&(&1 * 2))\n    |> Stream.map(&IO.inspect(&1))\n    Enum.to_list(stream)\n    1\n    2\n    2\n    4\n    3\n    6\n    #=> [2, 4, 6]\n\nAlthough the end result is the same, the order in which the elements were\nprinted changed! With streams, we print the first element and then print\nits double. In this example, the list was enumerated just once!\n\nThat's what we meant when we said earlier that streams are composable,\nlazy enumerables. Note that we could call `Stream.map/2` multiple times,\neffectively composing the streams and keeping them lazy. The computations\nare only performed when you call a function from the `Enum` module.\n\nLike with `Enum`, the functions in this module work in linear time. This\nmeans that, the time it takes to perform an operation grows at the same\nrate as the length of the list. This is expected on operations such as\n`Stream.map/2`. After all, if we want to traverse every element on a\nstream, the longer the stream, the more elements we need to traverse,\nand the longer it will take."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.Elixir.Stream <response> Creating Streams\n\nThere are many functions in Elixir's standard library that return\nstreams, some examples are:\n\n  * `IO.stream/2`         - streams input lines, one by one\n  * `URI.query_decoder/1` - decodes a query string, pair by pair\n\nThis module also provides many convenience functions for creating streams,\nlike `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n\nNote the functions in this module are guaranteed to return enumerables.\nSince enumerables can have different shapes (structs, anonymous functions,\nand so on), the functions in this module may return any of those shapes\nand this may change at any time. For example, a function that today\nreturns an anonymous function may return a struct in future releases."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Chars.to_string(term) <response> Converts `term` to a string."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Chars.Elixir.String.Chars <response> The `String.Chars` protocol is responsible for\nconverting a structure to a binary (only if applicable).\n\nThe only function required to be implemented is\n`to_string/1`, which does the conversion.\n\nThe `to_string/1` function automatically imported\nby `Kernel` invokes this protocol. String\ninterpolation also invokes `to_string/1` in its\narguments. For example, `\"foo#{bar}\"` is the same\nas `\"foo\" <> to_string(bar)`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.at(string, position) <response> Returns the grapheme at the `position` of the given UTF-8 `string`.\nIf `position` is greater than `string` length, then it returns `nil`.\n\n## Examples\n\n    iex> String.at(\"elixir\", 0)\n    \"e\"\n\n    iex> String.at(\"elixir\", 1)\n    \"l\"\n\n    iex> String.at(\"elixir\", 10)\n    nil\n\n    iex> String.at(\"elixir\", -1)\n    \"r\"\n\n    iex> String.at(\"elixir\", -10)\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.bag_distance(string1, string2) <response> Computes the bag distance between two strings.\n\nReturns a float value between 0 and 1 representing the bag\ndistance between `string1` and `string2`.\n\nThe bag distance is meant to be an efficient approximation\nof the distance between two strings to quickly rule out strings\nthat are largely different.\n\nThe algorithm is outlined in the \"String Matching with Metric\nTrees Using an Approximate Distance\" paper by Ilaria Bartolini,\nPaolo Ciaccia, and Marco Patella.\n\n## Examples\n\n    iex> String.bag_distance(\"abc\", \"\")\n    0.0\n    iex> String.bag_distance(\"abcd\", \"a\")\n    0.25\n    iex> String.bag_distance(\"abcd\", \"ab\")\n    0.5\n    iex> String.bag_distance(\"abcd\", \"abc\")\n    0.75\n    iex> String.bag_distance(\"abcd\", \"abcd\")\n    1.0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.capitalize(string, mode \\\\ :default) <response> Converts the first character in the given string to\nuppercase and the remainder to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\ncapitalizes only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.capitalize(\"abcd\")\n    \"Abcd\"\n\n    iex> String.capitalize(\"ï¬n\")\n    \"Fin\"\n\n    iex> String.capitalize(\"olÃ¡\")\n    \"OlÃ¡\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.chunk(string, trait) <response> Splits the string into chunks of characters that share a common trait.\n\nThe trait can be one of two options:\n\n  * `:valid` - the string is split into chunks of valid and invalid\n    character sequences\n\n  * `:printable` - the string is split into chunks of printable and\n    non-printable character sequences\n\nReturns a list of binaries each of which contains only one kind of\ncharacters.\n\nIf the given string is empty, an empty list is returned.\n\n## Examples\n\n    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n    [\"abc\\0\"]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0xFFFF::utf16>>, :valid)\n    [\"abc\\0\", <<0xFFFF::utf16>>]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0FFFF::utf8>>, :printable)\n    [\"abc\", <<0, 0x0FFFF::utf8>>]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.codepoints(string) <response> Returns a list of code points encoded as strings.\n\nTo retrieve code points in their natural integer\nrepresentation, see `to_charlist/1`. For details about\ncode points and graphemes, see the `String` module\ndocumentation.\n\n## Examples\n\n    iex> String.codepoints(\"olÃ¡\")\n    [\"o\", \"l\", \"Ã¡\"]\n\n    iex> String.codepoints(\"Ð¾Ð¿ÑÐ¸Ð¼Ð¸ Ð·Ð°ÑÐ¸Ð¸\")\n    [\"Ð¾\", \"Ð¿\", \"Ñ\", \"Ð¸\", \"Ð¼\", \"Ð¸\", \" \", \"Ð·\", \"Ð°\", \"Ñ\", \"Ð¸\", \"Ð¸\"]\n\n    iex> String.codepoints(\"á¼á¼ªá¿¼\")\n    [\"á¼\", \"á¼ª\", \"á¿¼\"]\n\n    iex> String.codepoints(\"\\u00e9\")\n    [\"Ã©\"]\n\n    iex> String.codepoints(\"\\u0065\\u0301\")\n    [\"e\", \"Ì\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.contains?(string, contents) <response> Searches if `string` contains any of the given `contents`.\n\n`contents` can be either a string, a list of strings,\nor a compiled pattern. If `contents` is a list, this\nfunction will search if any of the strings in `contents`\nare part of `string`.\n\n> Note: if you want to check if `string` is listed in `contents`,\n> where `contents` is a list, use `Enum.member?(contents, string)`\n> instead.\n\n## Examples\n\n    iex> String.contains?(\"elixir of life\", \"of\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"life\", \"death\"])\n    true\n    iex> String.contains?(\"elixir of life\", [\"death\", \"mercury\"])\n    false\n\nThe argument can also be a compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\"life\", \"death\"])\n    iex> String.contains?(\"elixir of life\", pattern)\n    true\n\nAn empty string will always match:\n\n    iex> String.contains?(\"elixir of life\", \"\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.contains?(\"elixir of life\", [])\n    false\n\n    iex> String.contains?(\"\", [])\n    false\n\nBe aware that this function can match within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following returns `true`:\n\n    iex> String.contains?(String.normalize(\"Ã©\", :nfd), \"e\")\n    true\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it will return `false`:\n\n    iex> String.contains?(String.normalize(\"Ã©\", :nfc), \"e\")\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.downcase(string, mode \\\\ :default) <response> Converts all characters in the given string to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nlowercases only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.downcase(\"ABCD\")\n    \"abcd\"\n\n    iex> String.downcase(\"AB 123 XPTO\")\n    \"ab 123 xpto\"\n\n    iex> String.downcase(\"OLÃ\")\n    \"olÃ¡\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.downcase(\"OLÃ\", :ascii)\n    \"olÃ\"\n\nThe `:greek` mode properly handles the context sensitive sigma in Greek:\n\n    iex> String.downcase(\"Î£Î£\")\n    \"ÏÏ\"\n\n    iex> String.downcase(\"Î£Î£\", :greek)\n    \"ÏÏ\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.downcase(\"IÄ°\")\n    \"iiÌ\"\n\n    iex> String.downcase(\"IÄ°\", :turkic)\n    \"Ä±i\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.duplicate(subject, n) <response> Returns a string `subject` repeated `n` times.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.duplicate(\"abc\", 0)\n    \"\"\n\n    iex> String.duplicate(\"abc\", 1)\n    \"abc\"\n\n    iex> String.duplicate(\"abc\", 2)\n    \"abcabc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.ends_with?(string, suffix) <response> Returns `true` if `string` ends with any of the suffixes given.\n\n`suffixes` can be either a single suffix or a list of suffixes.\n\n## Examples\n\n    iex> String.ends_with?(\"language\", \"age\")\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"age\"])\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"elixir\"])\n    false\n\nAn empty suffix will always match:\n\n    iex> String.ends_with?(\"language\", \"\")\n    true\n    iex> String.ends_with?(\"language\", [\"\", \"other\"])\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.equivalent?(string1, string2) <response> Returns `true` if `string1` is canonically equivalent to `string2`.\n\nIt performs Normalization Form Canonical Decomposition (NFD) on the\nstrings before comparing them. This function is equivalent to:\n\n    String.normalize(string1, :nfd) == String.normalize(string2, :nfd)\n\nIf you plan to compare multiple strings, multiple times in a row, you\nmay normalize them upfront and compare them directly to avoid multiple\nnormalization passes.\n\n## Examples\n\n    iex> String.equivalent?(\"abc\", \"abc\")\n    true\n\n    iex> String.equivalent?(\"man\\u0303ana\", \"maÃ±ana\")\n    true\n\n    iex> String.equivalent?(\"abc\", \"ABC\")\n    false\n\n    iex> String.equivalent?(\"nÃ¸\", \"nÃ³\")\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.first(string) <response> Returns the first grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\n## Examples\n\n    iex> String.first(\"elixir\")\n    \"e\"\n\n    iex> String.first(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    \"Õ¥\"\n\n    iex> String.first(\"\")\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.graphemes(string) <response> Returns Unicode graphemes in the string as per Extended Grapheme\nCluster algorithm.\n\nThe algorithm is outlined in the [Unicode Standard Annex #29,\nUnicode Text Segmentation](https://www.unicode.org/reports/tr29/).\n\nFor details about code points and graphemes, see the `String` module documentation.\n\n## Examples\n\n    iex> String.graphemes(\"ÅaÃ¯ve\")\n    [\"Å\", \"a\", \"Ã¯\", \"v\", \"e\"]\n\n    iex> String.graphemes(\"\\u00e9\")\n    [\"Ã©\"]\n\n    iex> String.graphemes(\"\\u0065\\u0301\")\n    [\"eÌ\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.jaro_distance(string1, string2) <response> Computes the Jaro distance (similarity) between two strings.\n\nReturns a float value between `0.0` (equates to no similarity) and `1.0`\n(is an exact match) representing [Jaro](https://en.wikipedia.org/wiki/Jaro-Winkler_distance)\ndistance between `string1` and `string2`.\n\nThe Jaro distance metric is designed and best suited for short\nstrings such as person names. Elixir itself uses this function\nto provide the \"did you mean?\" functionality. For instance, when you\nare calling a function in a module and you have a typo in the\nfunction name, we attempt to suggest the most similar function\nname available, if any, based on the `jaro_distance/2` score.\n\n## Examples\n\n    iex> String.jaro_distance(\"Dwayne\", \"Duane\")\n    0.8222222222222223\n    iex> String.jaro_distance(\"even\", \"odd\")\n    0.0\n    iex> String.jaro_distance(\"same\", \"same\")\n    1.0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.last(string) <response> Returns the last grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\nIt traverses the whole string to find its last grapheme.\n\n## Examples\n\n    iex> String.last(\"\")\n    nil\n\n    iex> String.last(\"elixir\")\n    \"r\"\n\n    iex> String.last(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    \"Õ«\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.length(string) <response> Returns the number of Unicode graphemes in a UTF-8 string.\n\n## Examples\n\n    iex> String.length(\"elixir\")\n    6\n\n    iex> String.length(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    5"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.match?(string, regex) <response> Checks if `string` matches the given regular expression.\n\n## Examples\n\n    iex> String.match?(\"foo\", ~r/foo/)\n    true\n\n    iex> String.match?(\"bar\", ~r/foo/)\n    false\n\nElixir also provides text-based match operator `=~/2` and function `Regex.match?/2` as\nalternatives to test strings against regular expressions."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.myers_difference(string1, string2) <response> Returns a keyword list that represents an edit script.\n\nCheck `List.myers_difference/2` for more information.\n\n## Examples\n\n    iex> string1 = \"fox hops over the dog\"\n    iex> string2 = \"fox jumps over the lazy cat\"\n    iex> String.myers_difference(string1, string2)\n    [eq: \"fox \", del: \"ho\", ins: \"jum\", eq: \"ps over the \", del: \"dog\", ins: \"lazy cat\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.next_codepoint(arg) <response> Returns the next code point in a string.\n\nThe result is a tuple with the code point and the\nremainder of the string or `nil` in case\nthe string reached its end.\n\nAs with other functions in the `String` module, `next_codepoint/1`\nworks with binaries that are invalid UTF-8. If the string starts\nwith a sequence of bytes that is not valid in UTF-8 encoding, the\nfirst element of the returned tuple is a binary with the first byte.\n\n## Examples\n\n    iex> String.next_codepoint(\"olÃ¡\")\n    {\"o\", \"lÃ¡\"}\n\n    iex> invalid = \"\\x80\\x80OK\" # first two bytes are invalid in UTF-8\n    iex> {_, rest} = String.next_codepoint(invalid)\n    {<<128>>, <<128, 79, 75>>}\n    iex> String.next_codepoint(rest)\n    {<<128>>, \"OK\"}\n\n## Comparison with binary pattern matching\n\nBinary pattern matching provides a similar way to decompose\na string:\n\n    iex> <<codepoint::utf8, rest::binary>> = \"Elixir\"\n    \"Elixir\"\n    iex> codepoint\n    69\n    iex> rest\n    \"lixir\"\n\nthough not entirely equivalent because `codepoint` comes as\nan integer, and the pattern won't match invalid UTF-8.\n\nBinary pattern matching, however, is simpler and more efficient,\nso pick the option that better suits your use case."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.next_grapheme(string) <response> Returns the next grapheme in a string.\n\nThe result is a tuple with the grapheme and the\nremainder of the string or `nil` in case\nthe String reached its end.\n\n## Examples\n\n    iex> String.next_grapheme(\"olÃ¡\")\n    {\"o\", \"lÃ¡\"}\n\n    iex> String.next_grapheme(\"\")\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.normalize(string, form) <response> Converts all characters in `string` to Unicode normalization\nform identified by `form`.\n\nInvalid Unicode codepoints are skipped and the remaining of\nthe string is converted. If you want the algorithm to stop\nand return on invalid codepoint, use `:unicode.characters_to_nfd_binary/1`,\n`:unicode.characters_to_nfc_binary/1`, `:unicode.characters_to_nfkd_binary/1`,\nand `:unicode.characters_to_nfkc_binary/1` instead.\n\nNormalization forms `:nfkc` and `:nfkd` should not be blindly applied\nto arbitrary text. Because they erase many formatting distinctions,\nthey will prevent round-trip conversion to and from many legacy\ncharacter sets.\n\n## Forms\n\nThe supported forms are:\n\n  * `:nfd` - Normalization Form Canonical Decomposition.\n    Characters are decomposed by canonical equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfc` - Normalization Form Canonical Composition.\n    Characters are decomposed and then recomposed by canonical equivalence.\n\n  * `:nfkd` - Normalization Form Compatibility Decomposition.\n    Characters are decomposed by compatibility equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfkc` - Normalization Form Compatibility Composition.\n    Characters are decomposed and then recomposed by compatibility equivalence.\n\n## Examples\n\n    iex> String.normalize(\"yÃªsÌÌ£\", :nfd)\n    \"yeÌsÌ£Ì\"\n\n    iex> String.normalize(\"lenÌa\", :nfc)\n    \"leÃ±a\"\n\n    iex> String.normalize(\"ï¬\", :nfkd)\n    \"fi\"\n\n    iex> String.normalize(\"fi\", :nfkc)\n    \"fi\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.pad_leading(string, count, padding \\\\ [\" \"]) <response> Returns a new string padded with a leading filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_leading(\"abc\", 5)\n    \"  abc\"\n\n    iex> String.pad_leading(\"abc\", 4, \"12\")\n    \"1abc\"\n\n    iex> String.pad_leading(\"abc\", 6, \"12\")\n    \"121abc\"\n\n    iex> String.pad_leading(\"abc\", 5, [\"1\", \"23\"])\n    \"123abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.pad_trailing(string, count, padding \\\\ [\" \"]) <response> Returns a new string padded with a trailing filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_trailing(\"abc\", 5)\n    \"abc  \"\n\n    iex> String.pad_trailing(\"abc\", 4, \"12\")\n    \"abc1\"\n\n    iex> String.pad_trailing(\"abc\", 6, \"12\")\n    \"abc121\"\n\n    iex> String.pad_trailing(\"abc\", 5, [\"1\", \"23\"])\n    \"abc123\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.printable?(string, character_limit \\\\ :infinity) <response> Checks if a string contains only printable characters up to `character_limit`.\n\nTakes an optional `character_limit` as a second argument. If `character_limit` is `0`, this\nfunction will return `true`.\n\n## Examples\n\n    iex> String.printable?(\"abc\")\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>)\n    false\n\n    iex> String.printable?(\"abc\" <> <<0>>, 2)\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>, 0)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace(subject, pattern, replacement, options \\\\ []) <response> Returns a new string created by replacing occurrences of `pattern` in\n`subject` with `replacement`.\n\nThe `subject` is always a string.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe `replacement` may be a string or a function that receives the matched\npattern and must return the replacement as a string or iodata.\n\nBy default it replaces all occurrences but this behaviour can be controlled\nthrough the `:global` option; see the \"Options\" section below.\n\n## Options\n\n  * `:global` - (boolean) if `true`, all occurrences of `pattern` are replaced\n    with `replacement`, otherwise only the first occurrence is\n    replaced. Defaults to `true`\n\n## Examples\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\")\n    \"a-b-c\"\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n    \"a-b,c\"\n\nThe pattern may also be a list of strings and the replacement may also\nbe a function that receives the matches:\n\n    iex> String.replace(\"a,b,c\", [\"a\", \"c\"], fn <<char>> -> <<char + 1>> end)\n    \"b,b,d\"\n\nWhen the pattern is a regular expression, one can give `\\N` or\n`\\g{N}` in the `replacement` string to access a specific capture in the\nregular expression:\n\n    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\g{1}\")\n    \"a,bb,cc\"\n\nNote that we had to escape the backslash escape character (i.e., we used `\\\\N`\ninstead of just `\\N` to escape the backslash; same thing for `\\\\g{N}`). By\ngiving `\\0`, one can inject the whole match in the replacement string.\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern(\",\")\n    iex> String.replace(\"a,b,c\", pattern, \"[]\")\n    \"a[]b[]c\"\n\nWhen an empty string is provided as a `pattern`, the function will treat it as\nan implicit empty string between each grapheme and the string will be\ninterspersed. If an empty string is provided as `replacement` the `subject`\nwill be returned:\n\n    iex> String.replace(\"ELIXIR\", \"\", \".\")\n    \".E.L.I.X.I.R.\"\n\n    iex> String.replace(\"ELIXIR\", \"\", \"\")\n    \"ELIXIR\"\n\nBe aware that this function can replace within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following will replace only the letter \"e\",\nmoving the accent to the letter \"o\":\n\n    iex> String.replace(String.normalize(\"Ã©\", :nfd), \"e\", \"o\")\n    \"oÌ\"\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it won't be replaced at all:\n\n    iex> String.replace(String.normalize(\"Ã©\", :nfc), \"e\", \"o\")\n    \"Ã©\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_leading(string, match, replacement) <response> Replaces all leading occurrences of `match` by `replacement` of `match` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe beginning of `string`, and it's impossible to replace \"multiple\"\noccurrences of `\"\"`.\n\n## Examples\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"\")\n    \"world\"\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"ola \")\n    \"ola ola world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_prefix(string, match, replacement) <response> Replaces prefix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just prepended to `string`.\n\n## Examples\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"\")\n    \"hello world\"\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"ola \")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"ola \")\n    \"ola hello world\"\n\n    iex> String.replace_prefix(\"world\", \"\", \"hello \")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_suffix(string, match, replacement) <response> Replaces suffix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just appended to `string`.\n\n## Examples\n\n    iex> String.replace_suffix(\"hello\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \"\")\n    \"hello world\"\n\n    iex> String.replace_suffix(\"hello\", \" world\", \" mundo\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \" mundo\")\n    \"hello world mundo\"\n\n    iex> String.replace_suffix(\"hello\", \"\", \" world\")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_trailing(string, match, replacement) <response> Replaces all trailing occurrences of `match` by `replacement` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe end of `string`, and it's impossible to replace \"multiple\" occurrences of\n`\"\"`.\n\n## Examples\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \"\")\n    \"hello\"\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \" mundo\")\n    \"hello mundo mundo\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.reverse(string) <response> Reverses the graphemes in given string.\n\n## Examples\n\n    iex> String.reverse(\"abcd\")\n    \"dcba\"\n\n    iex> String.reverse(\"hello world\")\n    \"dlrow olleh\"\n\n    iex> String.reverse(\"hello âog\")\n    \"goâ olleh\"\n\nKeep in mind reversing the same string twice does\nnot necessarily yield the original string:\n\n    iex> \"Ìe\"\n    \"Ìe\"\n    iex> String.reverse(\"Ìe\")\n    \"eÌ\"\n    iex> String.reverse(String.reverse(\"Ìe\"))\n    \"eÌ\"\n\nIn the first example the accent is before the vowel, so\nit is considered two graphemes. However, when you reverse\nit once, you have the vowel followed by the accent, which\nbecomes one grapheme. Reversing it again will keep it as\none single grapheme."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.slice(string, range) <response> Returns a substring from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nIf the start of the range is not a valid offset for the given\nstring or if the range is in reverse order, returns `\"\"`.\n\nIf the start or end of the range is negative, the whole string\nis traversed first in order to convert the negative indices into\npositive ones.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or\n`Kernel.binary_slice/2` instead\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> String.slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -100..100)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> String.slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole string as is:\n\n    iex> String.slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the string:\n\n    iex> String.slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> String.slice(\"elixir\", 10..3)\n    \"\"\n    iex> String.slice(\"a\", 1..1500)\n    \"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.slice(string, start, length) <response> Returns a substring starting at the offset `start`, and of the given `length`.\n\nIf the offset is greater than string length, then it returns `\"\"`.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or `Kernel.binary_slice/3`\ninstead.\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1, 3)\n    \"lix\"\n\n    iex> String.slice(\"elixir\", 1, 10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", 10, 3)\n    \"\"\n\nIf the start position is negative, it is normalized\nagainst the string length and clamped to 0:\n\n    iex> String.slice(\"elixir\", -4, 4)\n    \"ixir\"\n\n    iex> String.slice(\"elixir\", -10, 3)\n    \"eli\"\n\nIf start is more than the string length, an empty\nstring is returned:\n\n    iex> String.slice(\"elixir\", 10, 1500)\n    \"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.split(binary) <response> Divides a string into substrings at each Unicode whitespace\noccurrence with leading and trailing whitespace ignored. Groups\nof whitespace are treated as a single occurrence. Divisions do\nnot occur on non-breaking whitespace.\n\n## Examples\n\n    iex> String.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\" foo   bar \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"no\\u00a0break\")\n    [\"no\\u00a0break\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.split(string, pattern, options \\\\ []) <response> Divides a string into parts based on a pattern.\n\nReturns a list of these parts.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe string is split into as many parts as possible by\ndefault, but can be controlled via the `:parts` option.\n\nEmpty strings are only removed from the result if the\n`:trim` option is set to `true`.\n\nWhen the pattern used is a regular expression, the string is\nsplit using `Regex.split/3`.\n\n## Options\n\n  * `:parts` (positive integer or `:infinity`) - the string\n    is split into at most as many parts as this option specifies.\n    If `:infinity`, the string will be split into all possible\n    parts. Defaults to `:infinity`.\n\n  * `:trim` (boolean) - if `true`, empty strings are removed from\n    the resulting list.\n\nThis function also accepts all options accepted by `Regex.split/3`\nif `pattern` is a regular expression.\n\n## Examples\n\nSplitting with a string pattern:\n\n    iex> String.split(\"a,b,c\", \",\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", \",\", parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", \" \", trim: true)\n    [\"a\", \"b\", \"c\"]\n\nA list of patterns:\n\n    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n    [\"1\", \"2\", \"3\", \"4\"]\n\nA regular expression:\n\n    iex> String.split(\"a,b,c\", ~r{,})\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", ~r{b}, include_captures: true)\n    [\"a\", \"b\", \"c\"]\n\nA compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.split(\"1,2 3,4\", pattern)\n    [\"1\", \"2\", \"3\", \"4\"]\n\nSplitting on empty string returns graphemes:\n\n    iex> String.split(\"abc\", \"\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> String.split(\"abc\", \"\", trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", \"\", parts: 1)\n    [\"abc\"]\n\n    iex> String.split(\"abc\", \"\", parts: 3)\n    [\"\", \"a\", \"bc\"]\n\nBe aware that this function can split within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following will split the string into two parts:\n\n    iex> String.split(String.normalize(\"Ã©\", :nfd), \"e\")\n    [\"\", \"Ì\"]\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it will split the string into just one part:\n\n    iex> String.split(String.normalize(\"Ã©\", :nfc), \"e\")\n    [\"Ã©\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.split_at(string, position) <response> Splits a string into two at the specified offset. When the offset given is\nnegative, location is counted from the end of the string.\n\nThe offset is capped to the length of the string. Returns a tuple with\ntwo elements.\n\nNote: keep in mind this function splits on graphemes and for such it\nhas to linearly traverse the string. If you want to split a string or\na binary based on the number of bytes, use `Kernel.binary_part/3`\ninstead.\n\n## Examples\n\n    iex> String.split_at(\"sweetelixir\", 5)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"sweetelixir\", -6)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"abc\", 0)\n    {\"\", \"abc\"}\n\n    iex> String.split_at(\"abc\", 1000)\n    {\"abc\", \"\"}\n\n    iex> String.split_at(\"abc\", -1000)\n    {\"\", \"abc\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.splitter(string, pattern, options \\\\ []) <response> Returns an enumerable that splits a string on demand.\n\nThis is in contrast to `split/3` which splits the\nentire string upfront.\n\nThis function does not support regular expressions\nby design. When using regular expressions, it is often\nmore efficient to have the regular expressions traverse\nthe string at once than in parts, like this function does.\n\n## Options\n\n  * :trim - when `true`, does not emit empty patterns\n\n## Examples\n\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", [\" \", \",\"]) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]\n\n    iex> String.splitter(\"abcd\", \"\") |> Enum.take(10)\n    [\"\", \"a\", \"b\", \"c\", \"d\", \"\"]\n\n    iex> String.splitter(\"abcd\", \"\", trim: true) |> Enum.take(10)\n    [\"a\", \"b\", \"c\", \"d\"]\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", pattern) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.starts_with?(string, prefix) <response> Returns `true` if `string` starts with any of the prefixes given.\n\n`prefix` can be either a string, a list of strings, or a compiled\npattern.\n\n## Examples\n\n    iex> String.starts_with?(\"elixir\", \"eli\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"elixir\"])\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"ruby\"])\n    false\n\nAn empty string will always match:\n\n    iex> String.starts_with?(\"elixir\", \"\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.starts_with?(\"elixir\", [])\n    false\n\n    iex> String.starts_with?(\"\", [])\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_atom(string) <response> Converts a string to an atom.\n\nWarning: this function creates atoms dynamically and atoms are\nnot garbage-collected. Therefore, `string` should not be an\nuntrusted value, such as input received from a socket or during\na web request. Consider using `to_existing_atom/1` instead.\n\nBy default, the maximum number of atoms is `1_048_576`. This limit\ncan be raised or lowered using the VM option `+t`.\n\nThe maximum atom size is of 255 Unicode code points.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_atom(\"my_atom\")\n    :my_atom"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_charlist(string) <response> Converts a string into a charlist.\n\nSpecifically, this function takes a UTF-8 encoded binary and returns a list of its integer\ncode points. It is similar to `codepoints/1` except that the latter returns a list of code points as\nstrings.\n\nIn case you need to work with bytes, take a look at the\n[`:binary` module](`:binary`).\n\n## Examples\n\n    iex> String.to_charlist(\"Ã¦Ã\")\n    'Ã¦Ã'"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_existing_atom(string) <response> Converts a string to an existing atom.\n\nThe maximum atom size is of 255 Unicode code points.\nRaises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `String.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.\n\n## Examples\n\n    iex> _ = :my_atom\n    iex> String.to_existing_atom(\"my_atom\")\n    :my_atom"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_float(string) <response> Returns a float whose text representation is `string`.\n\n`string` must be the string representation of a float including a decimal point.\nIn order to parse a string without decimal point as a float then `Float.parse/1`\nshould be used. Otherwise, an `ArgumentError` will be raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_float(\"2.2017764e+0\")\n    2.2017764\n\n    iex> String.to_float(\"3.0\")\n    3.0\n\n    String.to_float(\"3\")\n    ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_integer(string) <response> Returns an integer whose text representation is `string`.\n\n`string` must be the string representation of an integer.\nOtherwise, an `ArgumentError` will be raised. If you want\nto parse a string that may contain an ill-formatted integer,\nuse `Integer.parse/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"123\")\n    123\n\nPassing a string that does not represent an integer leads to an error:\n\n    String.to_integer(\"invalid data\")\n    ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_integer(string, base) <response> Returns an integer whose text representation is `string` in base `base`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"3FF\", 16)\n    1023"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim(string) <response> Returns a string where all leading and trailing Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim(\"\\n  abc\\n  \")\n    \"abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim(string, to_trim) <response> Returns a string where all leading and trailing `to_trim` characters have been\nremoved.\n\n## Examples\n\n    iex> String.trim(\"a  abc  a\", \"a\")\n    \"  abc  \""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_leading(string) <response> Returns a string where all leading Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"\\n  abc   \")\n    \"abc   \""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_leading(string, to_trim) <response> Returns a string where all leading `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"__ abc _\", \"_\")\n    \" abc _\"\n\n    iex> String.trim_leading(\"1 abc\", \"11\")\n    \"1 abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_trailing(string) <response> Returns a string where all trailing Unicode whitespaces\nhas been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"   abc\\n  \")\n    \"   abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_trailing(string, to_trim) <response> Returns a string where all trailing `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"_ abc __\", \"_\")\n    \"_ abc \"\n\n    iex> String.trim_trailing(\"abc 1\", \"11\")\n    \"abc 1\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.upcase(string, mode \\\\ :default) <response> Converts all characters in the given string to uppercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nuppercases only the letters a to z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.upcase(\"abcd\")\n    \"ABCD\"\n\n    iex> String.upcase(\"ab 123 xpto\")\n    \"AB 123 XPTO\"\n\n    iex> String.upcase(\"olÃ¡\")\n    \"OLÃ\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.upcase(\"olÃ¡\", :ascii)\n    \"OLÃ¡\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.upcase(\"Ä±i\")\n    \"II\"\n\n    iex> String.upcase(\"Ä±i\", :turkic)\n    \"IÄ°\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.valid?(string) <response> Checks whether `string` contains only valid characters.\n\n## Examples\n\n    iex> String.valid?(\"a\")\n    true\n\n    iex> String.valid?(\"Ã¸\")\n    true\n\n    iex> String.valid?(<<0xFFFF::16>>)\n    false\n\n    iex> String.valid?(<<0xEF, 0xB7, 0x90>>)\n    true\n\n    iex> String.valid?(\"asd\" <> <<0xFFFF::16>>)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Strings in Elixir are UTF-8 encoded binaries.\n\nStrings in Elixir are a sequence of Unicode characters,\ntypically written between double quoted strings, such\nas `\"hello\"` and `\"hÃ©llÃ²\"`.\n\nIn case a string must have a double-quote in itself,\nthe double quotes must be escaped with a backslash,\nfor example: `\"this is a string with \\\"double quotes\\\"\"`.\n\nYou can concatenate two strings with the `<>/2` operator:\n\n    iex> \"hello\" <> \" \" <> \"world\"\n    \"hello world\"\n\nThe functions in this module act according to\n[The Unicode Standard, Version 14.0.0](http://www.unicode.org/versions/Unicode14.0.0/)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Interpolation\n\nStrings in Elixir also support interpolation. This allows\nyou to place some value in the middle of a string by using\nthe `#{}` syntax:\n\n    iex> name = \"joe\"\n    iex> \"hello #{name}\"\n    \"hello joe\"\n\nAny Elixir expression is valid inside the interpolation.\nIf a string is given, the string is interpolated as is.\nIf any other value is given, Elixir will attempt to convert\nit to a string using the `String.Chars` protocol. This\nallows, for example, to output an integer from the interpolation:\n\n    iex> \"2 + 2 = #{2 + 2}\"\n    \"2 + 2 = 4\"\n\nIn case the value you want to interpolate cannot be\nconverted to a string, because it doesn't have a human\ntextual representation, a protocol error will be raised."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Escape characters\n\nBesides allowing double-quotes to be escaped with a backslash,\nstrings also support the following escape characters:\n\n  * `\\0` - Null byte\n  * `\\a` - Bell\n  * `\\b` - Backspace\n  * `\\t` - Horizontal tab\n  * `\\n` - Line feed (New lines)\n  * `\\v` - Vertical tab\n  * `\\f` - Form feed\n  * `\\r` - Carriage return\n  * `\\e` - Command Escape\n  * `\\s` - Space\n  * `\\#` - Returns the `#` character itself, skipping interpolation\n  * `\\\\` - Single backslash\n  * `\\xNN` - A byte represented by the hexadecimal `NN`\n  * `\\uNNNN` - A Unicode code point represented by `NNNN`\n\nNote it is generally not advised to use `\\xNN` in Elixir\nstrings, as introducing an invalid byte sequence would\nmake the string invalid. If you have to introduce a\ncharacter by its hexadecimal representation, it is best\nto work with Unicode code points, such as `\\uNNNN`. In fact,\nunderstanding Unicode code points can be essential when doing\nlow-level manipulations of string, so let's explore them in\ndetail next."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Unicode and code points\n\nIn order to facilitate meaningful communication between computers\nacross multiple languages, a standard is required so that the ones\nand zeros on one machine mean the same thing when they are transmitted\nto another. The Unicode Standard acts as an official registry of\nvirtually all the characters we know: this includes characters from\nclassical and historical texts, emoji, and formatting and control\ncharacters as well.\n\nUnicode organizes all of the characters in its repertoire into code\ncharts, and each character is given a unique numerical index. This\nnumerical index is known as a Code Point.\n\nIn Elixir you can use a `?` in front of a character literal to reveal\nits code point:\n\n    iex> ?a\n    97\n    iex> ?Å\n    322\n\nNote that most Unicode code charts will refer to a code point by its\nhexadecimal (hex) representation, e.g. `97` translates to `0061` in hex,\nand we can represent any Unicode character in an Elixir string by\nusing the `\\u` escape character followed by its code point number:\n\n    iex> \"\\u0061\" === \"a\"\n    true\n    iex> 0x0061 = 97 = ?a\n    97\n\nThe hex representation will also help you look up information about a\ncode point, e.g. [https://codepoints.net/U+0061](https://codepoints.net/U+0061)\nhas a data sheet all about the lower case `a`, a.k.a. code point 97.\nRemember you can get the hex presentation of a number by calling\n`Integer.to_string/2`:\n\n    iex> Integer.to_string(?a, 16)\n    \"61\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Watcher.start_link(tuple) <response> Starts a watcher server.\n\nThis is useful when there is a need to start a handler\noutside of the handler supervision tree."}

{"text":"Can you write a docstring for this Elixir function name? Elixir.Float.Elixir.Float <response> Kernel functions\n\nThere are functions related to floating-point numbers on the `Kernel` module\ntoo. Here is a list of them:\n\n  * `Kernel.round/1`: rounds a number to the nearest integer.\n  * `Kernel.trunc/1`: returns the integer part of a number."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Float.Elixir.Float <response> Known issues\n\nThere are some very well known problems with floating-point numbers\nand arithmetic due to the fact most decimal fractions cannot be\nrepresented by a floating-point binary and most operations are not exact,\nbut operate on approximations. Those issues are not specific\nto Elixir, they are a property of floating point representation itself.\n\nFor example, the numbers 0.1 and 0.01 are two of them, what means the result\nof squaring 0.1 does not give 0.01 neither the closest representable. Here is\nwhat happens in this case:\n\n  * The closest representable number to 0.1 is 0.1000000014\n  * The closest representable number to 0.01 is 0.0099999997\n  * Doing 0.1 * 0.1 should return 0.01, but because 0.1 is actually 0.1000000014,\n    the result is 0.010000000000000002, and because this is not the closest\n    representable number to 0.01, you'll get the wrong result for this operation\n\nThere are also other known problems like flooring or rounding numbers. See\n`round/2` and `floor/2` for more details about them.\n\nTo learn more about floating-point arithmetic visit:\n\n  * [0.30000000000000004.com](http://0.30000000000000004.com/)\n  * [What Every Programmer Should Know About Floating-Point Arithmetic](https://floating-point-gui.de/)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Function.capture(module, function_name, arity) <response> Captures the given function.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Function.capture(String, :length, 1)\n    &String.length/1"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Function.identity(value) <response> Returns its input `value`. This function can be passed as an anonymous function\nto transformation functions.\n\n## Examples\n\n    iex> Function.identity(\"Hello world!\")\n    \"Hello world!\"\n\n    iex> 'abcdaabccc' |> Enum.sort() |> Enum.chunk_by(&Function.identity/1)\n    ['aaa', 'bb', 'cccc', 'd']\n\n    iex> Enum.group_by('abracadabra', &Function.identity/1)\n    %{97 => 'aaaaa', 98 => 'bb', 99 => 'c', 100 => 'd', 114 => 'rr'}\n\n    iex> Enum.map([1, 2, 3, 4], &Function.identity/1)\n    [1, 2, 3, 4]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Function.info(fun) <response> Returns a keyword list with information about a function.\n\nThe returned keys (with the corresponding possible values) for\nall types of functions (local and external) are the following:\n\n  * `:type` - `:local` (for anonymous functions) or `:external` (for\n    named functions).\n\n  * `:module` - an atom which is the module where the function is defined when\n  anonymous or the module which the function refers to when it's a named function.\n\n  * `:arity` - (integer) the number of arguments the function is to be called with.\n\n  * `:name` - (atom) the name of the function.\n\n  * `:env` - a list of the environment or free variables. For named\n    functions, the returned list is always empty.\n\nWhen `fun` is an anonymous function (that is, the type is `:local`), the following\nadditional keys are returned:\n\n  * `:pid` - PID of the process that originally created the function.\n\n  * `:index` - (integer) an index into the module function table.\n\n  * `:new_index` - (integer) an index into the module function table.\n\n  * `:new_uniq` - (binary) a unique value for this function. It's\n    calculated from the compiled code for the entire module.\n\n  * `:uniq` - (integer) a unique value for this function. This integer is\n    calculated from the compiled code for the entire module.\n\n**Note**: this function must be used only for debugging purposes.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> fun = fn x -> x end\n    iex> info = Function.info(fun)\n    iex> Keyword.get(info, :arity)\n    1\n    iex> Keyword.get(info, :type)\n    :local\n\n    iex> fun = &String.length/1\n    iex> info = Function.info(fun)\n    iex> Keyword.get(info, :type)\n    :external\n    iex> Keyword.get(info, :name)\n    :length"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Function.info(fun, item) <response> Returns a specific information about the function.\n\nThe returned information is a two-element tuple in the shape of\n`{info, value}`.\n\nFor any function, the information asked for can be any of the atoms\n`:module`, `:name`, `:arity`, `:env`, or `:type`.\n\nFor anonymous functions, there is also information about any of the\natoms `:index`, `:new_index`, `:new_uniq`, `:uniq`, and `:pid`.\nFor a named function, the value of any of these items is always the\natom `:undefined`.\n\nFor more information on each of the possible returned values, see\n`info/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> f = fn x -> x end\n    iex> Function.info(f, :arity)\n    {:arity, 1}\n    iex> Function.info(f, :type)\n    {:type, :local}\n\n    iex> fun = &String.length/1\n    iex> Function.info(fun, :name)\n    {:name, :length}\n    iex> Function.info(fun, :pid)\n    {:pid, :undefined}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Function.Elixir.Function <response> A set of functions for working with functions.\n\nAnonymous functions are typically created by using `fn`:\n\n    iex> add = fn a, b -> a + b end\n    iex> add.(1, 2)\n    3\n\nAnonymous functions can also have multiple clauses. All clauses\nshould expect the same number of arguments:\n\n    iex> negate = fn\n    ...>   true -> false\n    ...>   false -> true\n    ...> end\n    iex> negate.(false)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Function.Elixir.Function <response> The capture operator\n\nIt is also possible to capture public module functions and pass them\naround as if they were anonymous functions by using the capture\noperator `&/1`:\n\n    iex> add = &Kernel.+/2\n    iex> add.(1, 2)\n    3\n\n    iex> length = &String.length/1\n    iex> length.(\"hello\")\n    5\n\nTo capture a definition within the current module, you can skip the\nmodule prefix, such as `&my_fun/2`. In those cases, the captured\nfunction can be public (`def`) or private (`defp`).\n\nThe capture operator can also be used to create anonymous functions\nthat expect at least one argument:\n\n    iex> add = &(&1 + &2)\n    iex> add.(1, 2)\n    3\n\nIn such cases, using the capture operator is no different than using `fn`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Function.Elixir.Function <response> Internal and external functions\n\nWe say that functions that point to definitions residing in modules, such\nas `&String.length/1`, are **external** functions. All other functions are\n**local** and they are always bound to the file or module that defined them.\n\nBesides the functions in this module to work with functions, `Kernel` also\nhas an `apply/2` function that invokes a function with a dynamic number of\narguments, as well as `is_function/1` and `is_function/2`, to check\nrespectively if a given value is a function or a function of a given arity."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenEvent.Elixir.GenEvent <response> An event manager with event handlers behaviour.\n\nIf you are interested in implementing an event manager, please read the\n\"Alternatives\" section below. If you have to implement an event handler to\nintegrate with an existing system, such as Elixir's Logger, please use\n[`:gen_event`](`:gen_event`) instead."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenEvent.Elixir.GenEvent <response> Alternatives\n\nThere are a few suitable alternatives to replace GenEvent. Each of them can be\nthe most beneficial based on the use case."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenEvent.Elixir.GenEvent <response> # Supervisor and GenServers\n\nOne alternative to GenEvent is a very minimal solution consisting of using a\nsupervisor and multiple GenServers started under it. The supervisor acts as\nthe \"event manager\" and the children GenServers act as the \"event handlers\".\nThis approach has some shortcomings (it provides no backpressure for example)\nbut can still replace GenEvent for low-profile usages of it. [This blog post\nby JosÃ©\nValim](http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/)\nhas more detailed information on this approach."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenEvent.Elixir.GenEvent <response> # GenStage\n\nIf the use case where you were using GenEvent requires more complex logic,\n[GenStage](https://github.com/elixir-lang/gen_stage) provides a great\nalternative. GenStage is an external Elixir library maintained by the Elixir\nteam; it provides a tool to implement systems that exchange events in a\ndemand-driven way with built-in support for backpressure. See the [GenStage\ndocumentation](https://hexdocs.pm/gen_stage) for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenEvent.Elixir.GenEvent <response> # `:gen_event`\n\nIf your use case requires exactly what GenEvent provided, or you have to\nintegrate with an existing `:gen_event`-based system, you can still use the\n[`:gen_event`](`:gen_event`) Erlang module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.abcast(nodes \\\\ [node() | Node.list()], name, request) <response> Casts all servers locally registered as `name` at the specified nodes.\n\nThis function returns immediately and ignores nodes that do not exist, or where the\nserver name does not exist.\n\nSee `multi_call/4` for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.call(server, request, timeout \\\\ 5000) <response> Makes a synchronous call to the `server` and waits for its reply.\n\nThe client sends the given `request` to the server and waits until a reply\narrives or a timeout occurs. `c:handle_call/3` will be called on the server\nto handle the request.\n\n`server` can be any of the values described in the \"Name registration\"\nsection of the documentation for this module.\n\n## Timeouts\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds to wait for a reply, or the atom `:infinity` to wait\nindefinitely. The default value is `5000`. If no reply is received within\nthe specified time, the function call fails and the caller exits. If the\ncaller catches the failure and continues running, and the server is just late\nwith the reply, it may arrive at any time later into the caller's message\nqueue. The caller must in this case be prepared for this and discard any such\ngarbage messages that are two-element tuples with a reference as the first\nelement."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.cast(server, request) <response> Sends an asynchronous request to the `server`.\n\nThis function always returns `:ok` regardless of whether\nthe destination `server` (or node) exists. Therefore it\nis unknown whether the destination `server` successfully\nhandled the message.\n\n`server` can be any of the values described in the \"Name registration\"\nsection of the documentation for this module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.multi_call(nodes \\\\ [node() | Node.list()], name, request, timeout \\\\ :infinity) <response> Calls all servers locally registered as `name` at the specified `nodes`.\n\nFirst, the `request` is sent to every node in `nodes`; then, the caller waits\nfor the replies. This function returns a two-element tuple `{replies,\nbad_nodes}` where:\n\n  * `replies` - is a list of `{node, reply}` tuples where `node` is the node\n    that replied and `reply` is its reply\n  * `bad_nodes` - is a list of nodes that either did not exist or where a\n    server with the given `name` did not exist or did not reply\n\n`nodes` is a list of node names to which the request is sent. The default\nvalue is the list of all known nodes (including this node).\n\nTo avoid that late answers (after the timeout) pollute the caller's message\nqueue, a middleman process is used to do the actual calls. Late answers will\nthen be discarded when they arrive to a terminated process.\n\n## Examples\n\nAssuming the `Stack` GenServer mentioned in the docs for the `GenServer`\nmodule is registered as `Stack` in the `:\"foo@my-machine\"` and\n`:\"bar@my-machine\"` nodes:\n\n    GenServer.multi_call(Stack, :pop)\n    #=> {[{:\"foo@my-machine\", :hello}, {:\"bar@my-machine\", :world}], []}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.reply(client, reply) <response> Replies to a client.\n\nThis function can be used to explicitly send a reply to a client that called\n`call/3` or `multi_call/4` when the reply cannot be specified in the return\nvalue of `c:handle_call/3`.\n\n`client` must be the `from` argument (the second argument) accepted by\n`c:handle_call/3` callbacks. `reply` is an arbitrary term which will be given\nback to the client as the return value of the call.\n\nNote that `reply/2` can be called from any process, not just the GenServer\nthat originally received the call (as long as that GenServer communicated the\n`from` argument somehow).\n\nThis function always returns `:ok`.\n\n## Examples\n\n    def handle_call(:reply_in_one_second, from, state) do\n      Process.send_after(self(), {:reply, from}, 1_000)\n      {:noreply, state}\n    end\n\n    def handle_info({:reply, from}, state) do\n      GenServer.reply(from, :one_second_has_passed)\n      {:noreply, state}\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.start(module, init_arg, options \\\\ []) <response> Starts a `GenServer` process without links (outside of a supervision tree).\n\nSee `start_link/3` for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.start_link(module, init_arg, options \\\\ []) <response> Starts a `GenServer` process linked to the current process.\n\nThis is often used to start the `GenServer` as part of a supervision tree.\n\nOnce the server is started, the `c:init/1` function of the given `module` is\ncalled with `init_arg` as its argument to initialize the server. To ensure a\nsynchronized start-up procedure, this function does not return until `c:init/1`\nhas returned.\n\nNote that a `GenServer` started with `start_link/3` is linked to the\nparent process and will exit in case of crashes from the parent. The GenServer\nwill also exit due to the `:normal` reasons in case it is configured to trap\nexits in the `c:init/1` callback.\n\n## Options\n\n  * `:name` - used for name registration as described in the \"Name\n    registration\" section in the documentation for `GenServer`\n\n  * `:timeout` - if present, the server is allowed to spend the given number of\n    milliseconds initializing or it will be terminated and the start function\n    will return `{:error, :timeout}`\n\n  * `:debug` - if present, the corresponding function in the [`:sys` module](`:sys`) is invoked\n\n  * `:spawn_opt` - if present, its value is passed as options to the\n    underlying process as in `Process.spawn/4`\n\n  * `:hibernate_after` - if present, the GenServer process awaits any message for\n    the given number of milliseconds and if no message is received, the process goes\n    into hibernation automatically (by calling `:proc_lib.hibernate/3`).\n\n## Return values\n\nIf the server is successfully created and initialized, this function returns\n`{:ok, pid}`, where `pid` is the PID of the server. If a process with the\nspecified server name already exists, this function returns\n`{:error, {:already_started, pid}}` with the PID of that process.\n\nIf the `c:init/1` callback fails with `reason`, this function returns\n`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\nor `:ignore`, the process is terminated and this function returns\n`{:error, reason}` or `:ignore`, respectively."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.stop(server, reason \\\\ :normal, timeout \\\\ :infinity) <response> Synchronously stops the server with the given `reason`.\n\nThe `c:terminate/2` callback of the given `server` will be invoked before\nexiting. This function returns `:ok` if the server terminates with the\ngiven reason; if it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.whereis(server) <response> Returns the `pid` or `{name, node}` of a GenServer process, `nil` otherwise.\n\nTo be precise, `nil` is returned whenever a `pid` or `{name, node}` cannot\nbe returned. Note there is no guarantee the returned `pid` or `{name, node}`\nis alive, as a process could terminate immediately after it is looked up.\n\n## Examples\n\nFor example, to lookup a server process, monitor it and send a cast to it:\n\n    process = GenServer.whereis(server)\n    monitor = Process.monitor(process)\n    GenServer.cast(process, :hello)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.Elixir.GenServer <response> A behaviour module for implementing the server of a client-server relation.\n\nA GenServer is a process like any other Elixir process and it can be used\nto keep state, execute code asynchronously and so on. The advantage of using\na generic server process (GenServer) implemented using this module is that it\nwill have a standard set of interface functions and include functionality for\ntracing and error reporting. It will also fit into a supervision tree."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.Elixir.GenServer <response> Example\n\nThe GenServer behaviour abstracts the common client-server interaction.\nDevelopers are only required to implement the callbacks and functionality\nthey are interested in.\n\nLet's start with a code example and then explore the available callbacks.\nImagine we want a GenServer that works like a stack, allowing us to push\nand pop elements:\n\n    defmodule Stack do\n      use GenServer\n\n      # Callbacks\n\n      @impl true\n      def init(stack) do\n        {:ok, stack}\n      end\n\n      @impl true\n      def handle_call(:pop, _from, [head | tail]) do\n        {:reply, head, tail}\n      end\n\n      @impl true\n      def handle_cast({:push, element}, state) do\n        {:noreply, [element | state]}\n      end\n    end\n\n    # Start the server\n    {:ok, pid} = GenServer.start_link(Stack, [:hello])\n\n    # This is the client\n    GenServer.call(pid, :pop)\n    #=> :hello\n\n    GenServer.cast(pid, {:push, :world})\n    #=> :ok\n\n    GenServer.call(pid, :pop)\n    #=> :world\n\nWe start our `Stack` by calling `start_link/2`, passing the module\nwith the server implementation and its initial argument (a list\nrepresenting the stack containing the element `:hello`). We can primarily\ninteract with the server by sending two types of messages. **call**\nmessages expect a reply from the server (and are therefore synchronous)\nwhile **cast** messages do not.\n\nEvery time you do a `GenServer.call/3`, the client will send a message\nthat must be handled by the `c:handle_call/3` callback in the GenServer.\nA `cast/2` message must be handled by `c:handle_cast/2`. There are 8 possible\ncallbacks to be implemented when you use a `GenServer`. The only required\ncallback is `c:init/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.Elixir.GenServer <response> Client / Server APIs\n\nAlthough in the example above we have used `GenServer.start_link/3` and\nfriends to directly start and communicate with the server, most of the\ntime we don't call the `GenServer` functions directly. Instead, we wrap\nthe calls in new functions representing the public API of the server.\n\nHere is a better implementation of our Stack module:\n\n    defmodule Stack do\n      use GenServer\n\n      # Client\n\n      def start_link(default) when is_list(default) do\n        GenServer.start_link(__MODULE__, default)\n      end\n\n      def push(pid, element) do\n        GenServer.cast(pid, {:push, element})\n      end\n\n      def pop(pid) do\n        GenServer.call(pid, :pop)\n      end\n\n      # Server (callbacks)\n\n      @impl true\n      def init(stack) do\n        {:ok, stack}\n      end\n\n      @impl true\n      def handle_call(:pop, _from, [head | tail]) do\n        {:reply, head, tail}\n      end\n\n      @impl true\n      def handle_cast({:push, element}, state) do\n        {:noreply, [element | state]}\n      end\n    end\n\nIn practice, it is common to have both server and client functions in\nthe same module. If the server and/or client implementations are growing\ncomplex, you may want to have them in different modules."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.Elixir.GenServer <response> How to supervise\n\nA `GenServer` is most commonly started under a supervision tree.\nWhen we invoke `use GenServer`, it automatically defines a `child_spec/1`\nfunction that allows us to start the `Stack` directly under a supervisor.\nTo start a default stack of `[:hello]` under a supervisor, one may do:\n\n    children = [\n      {Stack, [:hello]}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nNote you can also start it simply as `Stack`, which is the same as\n`{Stack, []}`:\n\n    children = [\n      Stack # The same as {Stack, []}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nIn both cases, `Stack.start_link/1` is always invoked.\n\n`use GenServer` also accepts a list of options which configures the\nchild specification and therefore how it runs under a supervisor.\nThe generated `child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:permanent`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nFor example:\n\n    use GenServer, restart: :transient, shutdown: 10_000\n\nSee the \"Child specification\" section in the `Supervisor` module for more\ndetailed information. The `@doc` annotation immediately preceding\n`use GenServer` will be attached to the generated `child_spec/1` function.\n\nWhen stopping the GenServer, for example by returning a `{:stop, reason, new_state}`\ntuple from a callback, the exit reason is used by the supervisor to determine\nwhether the GenServer needs to be restarted. See the \"Exit reasons and restarts\"\nsection in the `Supervisor` module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.Elixir.GenServer <response> Name registration\n\nBoth `start_link/3` and `start/3` support the `GenServer` to register\na name on start via the `:name` option. Registered names are also\nautomatically cleaned up on termination. The supported values are:\n\n  * an atom - the GenServer is registered locally (to the current node)\n    with the given name using `Process.register/2`.\n\n  * `{:global, term}` - the GenServer is registered globally with the given\n    term using the functions in the [`:global` module](`:global`).\n\n  * `{:via, module, term}` - the GenServer is registered with the given\n    mechanism and name. The `:via` option expects a module that exports\n    `register_name/2`, `unregister_name/1`, `whereis_name/1` and `send/2`.\n    One such example is the [`:global` module](`:global`) which uses these functions\n    for keeping the list of names of processes and their associated PIDs\n    that are available globally for a network of Elixir nodes. Elixir also\n    ships with a local, decentralized and scalable registry called `Registry`\n    for locally storing names that are generated dynamically.\n\nFor example, we could start and register our `Stack` server locally as follows:\n\n    # Start the server and register it locally with name MyStack\n    {:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n\n    # Now messages can be sent directly to MyStack\n    GenServer.call(MyStack, :pop)\n    #=> :hello\n\nOnce the server is started, the remaining functions in this module (`call/3`,\n`cast/2`, and friends) will also accept an atom, or any `{:global, ...}` or\n`{:via, ...}` tuples. In general, the following formats are supported:\n\n  * a PID\n  * an atom if the server is locally registered\n  * `{atom, node}` if the server is locally registered at another node\n  * `{:global, term}` if the server is globally registered\n  * `{:via, module, name}` if the server is registered through an alternative\n    registry\n\nIf there is an interest to register dynamic names locally, do not use\natoms, as atoms are never garbage-collected and therefore dynamically\ngenerated atoms won't be garbage-collected. For such cases, you can\nset up your own local registry by using the `Registry` module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.Elixir.GenServer <response> Receiving \"regular\" messages\n\nThe goal of a `GenServer` is to abstract the \"receive\" loop for developers,\nautomatically handling system messages, supporting code change, synchronous\ncalls and more. Therefore, you should never call your own \"receive\" inside\nthe GenServer callbacks as doing so will cause the GenServer to misbehave.\n\nBesides the synchronous and asynchronous communication provided by `call/3`\nand `cast/2`, \"regular\" messages sent by functions such as `send/2`,\n`Process.send_after/4` and similar, can be handled inside the `c:handle_info/2`\ncallback.\n\n`c:handle_info/2` can be used in many situations, such as handling monitor\nDOWN messages sent by `Process.monitor/1`. Another use case for `c:handle_info/2`\nis to perform periodic work, with the help of `Process.send_after/4`:\n\n    defmodule MyApp.Periodically do\n      use GenServer\n\n      def start_link(_) do\n        GenServer.start_link(__MODULE__, %{})\n      end\n\n      @impl true\n      def init(state) do\n        # Schedule work to be performed on start\n        schedule_work()\n\n        {:ok, state}\n      end\n\n      @impl true\n      def handle_info(:work, state) do\n        # Do the desired work here\n        # ...\n\n        # Reschedule once more\n        schedule_work()\n\n        {:noreply, state}\n      end\n\n      defp schedule_work do\n        # We schedule the work to happen in 2 hours (written in milliseconds).\n        # Alternatively, one might write :timer.hours(2)\n        Process.send_after(self(), :work, 2 * 60 * 60 * 1000)\n      end\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.Elixir.GenServer <response> Timeouts\n\nThe return value of `c:init/1` or any of the `handle_*` callbacks may include\na timeout value in milliseconds; if not, `:infinity` is assumed.\nThe timeout can be used to detect a lull in incoming messages.\n\nThe `timeout()` value is used as follows:\n\n  * If the process has any message already waiting when the `timeout()` value\n    is returned, the timeout is ignored and the waiting message is handled as\n    usual. This means that even a timeout of `0` milliseconds is not guaranteed\n    to execute (if you want to take another action immediately and unconditionally,\n    use a `:continue` instruction instead).\n\n  * If any message arrives before the specified number of milliseconds\n    elapse, the timeout is cleared and that message is handled as usual.\n\n  * Otherwise, when the specified number of milliseconds have elapsed with no\n    message arriving, `handle_info/2` is called with `:timeout` as the first\n    argument."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.Elixir.GenServer <response> When (not) to use a GenServer\n\nSo far, we have learned that a `GenServer` can be used as a supervised process\nthat handles sync and async calls. It can also handle system messages, such as\nperiodic messages and monitoring events. GenServer processes may also be named.\n\nA GenServer, or a process in general, must be used to model runtime characteristics\nof your system. A GenServer must never be used for code organization purposes.\n\nIn Elixir, code organization is done by modules and functions, processes are not\nnecessary. For example, imagine you are implementing a calculator and you decide\nto put all the calculator operations behind a GenServer:\n\n    def add(a, b) do\n      GenServer.call(__MODULE__, {:add, a, b})\n    end\n\n    def subtract(a, b) do\n      GenServer.call(__MODULE__, {:subtract, a, b})\n    end\n\n    def handle_call({:add, a, b}, _from, state) do\n      {:reply, a + b, state}\n    end\n\n    def handle_call({:subtract, a, b}, _from, state) do\n      {:reply, a - b, state}\n    end\n\nThis is an anti-pattern not only because it convolutes the calculator logic but\nalso because you put the calculator logic behind a single process that will\npotentially become a bottleneck in your system, especially as the number of\ncalls grow. Instead just define the functions directly:\n\n    def add(a, b) do\n      a + b\n    end\n\n    def subtract(a, b) do\n      a - b\n    end\n\nIf you don't need a process, then you don't need a process. Use processes only to\nmodel runtime properties, such as mutable state, concurrency and failures, never\nfor code organization."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.Elixir.GenServer <response> Debugging with the :sys module\n\nGenServers, as [special processes](https://www.erlang.org/doc/design_principles/spec_proc.html),\ncan be debugged using the [`:sys` module](`:sys`).\nThrough various hooks, this module allows developers to introspect the state of\nthe process and trace system events that happen during its execution, such as\nreceived messages, sent replies and state changes.\n\nLet's explore the basic functions from the\n[`:sys` module](`:sys`) used for debugging:\n\n  * `:sys.get_state/2` - allows retrieval of the state of the process.\n    In the case of a GenServer process, it will be the callback module state,\n    as passed into the callback functions as last argument.\n  * `:sys.get_status/2` - allows retrieval of the status of the process.\n    This status includes the process dictionary, if the process is running\n    or is suspended, the parent PID, the debugger state, and the state of\n    the behaviour module, which includes the callback module state\n    (as returned by `:sys.get_state/2`). It's possible to change how this\n    status is represented by defining the optional `c:GenServer.format_status/2`\n    callback.\n  * `:sys.trace/3` - prints all the system events to `:stdio`.\n  * `:sys.statistics/3` - manages collection of process statistics.\n  * `:sys.no_debug/2` - turns off all debug handlers for the given process.\n    It is very important to switch off debugging once we're done. Excessive\n    debug handlers or those that should be turned off, but weren't, can\n    seriously damage the performance of the system.\n  * `:sys.suspend/2` - allows to suspend a process so that it only\n    replies to system messages but no other messages. A suspended process\n    can be reactivated via `:sys.resume/2`.\n\nLet's see how we could use those functions for debugging the stack server\nwe defined earlier.\n\n    iex> {:ok, pid} = Stack.start_link([])\n    iex> :sys.statistics(pid, true) # turn on collecting process statistics\n    iex> :sys.trace(pid, true) # turn on event printing\n    iex> Stack.push(pid, 1)\n    *DBG* <0.122.0> got cast {push,1}\n    *DBG* <0.122.0> new state [1]\n    :ok\n\n    iex> :sys.get_state(pid)\n    [1]\n\n    iex> Stack.pop(pid)\n    *DBG* <0.122.0> got call pop from <0.80.0>\n    *DBG* <0.122.0> sent 1 to <0.80.0>, new state []\n    1\n\n    iex> :sys.statistics(pid, :get)\n    {:ok,\n     [\n       start_time: {{2016, 7, 16}, {12, 29, 41}},\n       current_time: {{2016, 7, 16}, {12, 29, 50}},\n       reductions: 117,\n       messages_in: 2,\n       messages_out: 0\n     ]}\n\n    iex> :sys.no_debug(pid) # turn off all debug handlers\n    :ok\n\n    iex> :sys.get_status(pid)\n    {:status, #PID<0.122.0>, {:module, :gen_server},\n     [\n       [\n         \"$initial_call\": {Stack, :init, 1},            # process dictionary\n         \"$ancestors\": [#PID<0.80.0>, #PID<0.51.0>]\n       ],\n       :running,                                        # :running | :suspended\n       #PID<0.80.0>,                                    # parent\n       [],                                              # debugger state\n       [\n         header: 'Status for generic server <0.122.0>', # module status\n         data: [\n           {'Status', :running},\n           {'Parent', #PID<0.80.0>},\n           {'Logged events', []}\n         ],\n         data: [{'State', [1]}]\n       ]\n     ]}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.GenServer.Elixir.GenServer <response> Learn more\n\nIf you wish to find out more about GenServers, the Elixir Getting Started\nguide provides a tutorial-like introduction. The documentation and links\nin Erlang can also provide extra insight.\n\n  * [GenServer - Elixir's Getting Started Guide](https://elixir-lang.org/getting-started/mix-otp/genserver.html)\n  * [`:gen_server` module documentation](`:gen_server`)\n  * [gen_server Behaviour - OTP Design Principles](https://www.erlang.org/doc/design_principles/gen_server_concepts.html)\n  * [Clients and Servers - Learn You Some Erlang for Great Good!](http://learnyousomeerlang.com/clients-and-servers)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.HashDict.new() <response> Creates a new empty dict."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.HashDict.Elixir.HashDict <response> Tuple-based HashDict implementation.\n\nThis module is deprecated. Use the `Map` module instead."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.HashSet.Elixir.HashSet <response> Tuple-based HashSet implementation.\n\nThis module is deprecated. Use the `MapSet` module instead."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.Docs.default_options() <response> The default options used by this module.\n\nThe supported keys are:\n\n  * `:enabled`           - toggles coloring on and off (true)\n  * `:doc_bold`          - bold text (bright)\n  * `:doc_code`          - code blocks (cyan)\n  * `:doc_headings`      - h1, h2, h3, h4, h5, h6 headings (yellow)\n  * `:doc_metadata`      - documentation metadata keys (yellow)\n  * `:doc_quote`         - leading quote character `> ` (light black)\n  * `:doc_inline_code`   - inline code (cyan)\n  * `:doc_table_heading` - the style for table headings\n  * `:doc_title`         - top level heading (reverse, yellow)\n  * `:doc_underline`     - underlined text (underline)\n  * `:width`             - the width to format the text (80)\n\nValues for the color settings are strings with\ncomma-separated ANSI values."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.Docs.print(doc, format, options \\\\ []) <response> Prints the documentation body `doc` according to `format`.\n\nIt takes a set of `options` defined in `default_options/0`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.Docs.print_headings(headings, options \\\\ []) <response> Prints the head of the documentation (i.e. the function signature).\n\nSee `default_options/0` for docs on the supported options."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.Docs.print_metadata(metadata, options \\\\ []) <response> Prints documentation metadata (only `delegate_to`, `deprecated`, `guard`, and `since` for now).\n\nSee `default_options/0` for docs on the supported options."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.black() <response> Sets foreground color to black."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.black_background() <response> Sets background color to black."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.blink_off() <response> Blink: off."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.blink_rapid() <response> Blink: rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.blink_slow() <response> Blink: slow. Less than 150 per minute."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.blue() <response> Sets foreground color to blue."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.blue_background() <response> Sets background color to blue."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.bright() <response> Bright (increased intensity) or bold."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.clear() <response> Clears screen."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.clear_line() <response> Clears line."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.color(code) <response> Sets foreground color."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.color(r, g, b) <response> Sets the foreground color from individual RGB values.\n\nValid values for each color are in the range 0 to 5."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.color_background(code) <response> Sets background color."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.color_background(r, g, b) <response> Sets the background color from individual RGB values.\n\nValid values for each color are in the range 0 to 5."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.conceal() <response> Conceal. Not widely supported."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.crossed_out() <response> Crossed-out. Characters legible, but marked for deletion. Not widely supported."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.cursor(line, column) <response> Sends cursor to the absolute position specified by `line` and `column`.\n\nLine `0` and column `0` would mean the top left corner."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.cursor_down(lines \\\\ 1) <response> Sends cursor `lines` down."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.cursor_left(columns \\\\ 1) <response> Sends cursor `columns` to the left."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.cursor_right(columns \\\\ 1) <response> Sends cursor `columns` to the right."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.cursor_up(lines \\\\ 1) <response> Sends cursor `lines` up."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.cyan() <response> Sets foreground color to cyan."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.cyan_background() <response> Sets background color to cyan."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.default_background() <response> Default background color."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.default_color() <response> Default text color."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.enabled?() <response> Checks if ANSI coloring is supported and enabled on this machine.\n\nThis function simply reads the configuration value for\n`:ansi_enabled` in the `:elixir` application. The value is by\ndefault `false` unless Elixir can detect during startup that\nboth `stdout` and `stderr` are terminals."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.encircled() <response> Encircled."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.faint() <response> Faint (decreased intensity). Not widely supported."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.font_1() <response> Sets alternative font 1."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.font_2() <response> Sets alternative font 2."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.font_3() <response> Sets alternative font 3."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.font_4() <response> Sets alternative font 4."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.font_5() <response> Sets alternative font 5."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.font_6() <response> Sets alternative font 6."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.font_7() <response> Sets alternative font 7."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.font_8() <response> Sets alternative font 8."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.font_9() <response> Sets alternative font 9."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.format(ansidata, emit? \\\\ enabled?()) <response> Formats a chardata-like argument by converting named ANSI sequences into actual\nANSI codes.\n\nThe named sequences are represented by atoms.\n\nIt will also append an `IO.ANSI.reset/0` to the chardata when a conversion is\nperformed. If you don't want this behaviour, use `format_fragment/2`.\n\nAn optional boolean parameter can be passed to enable or disable\nemitting actual ANSI codes. When `false`, no ANSI codes will be emitted.\nBy default checks if ANSI is enabled using the `enabled?/0` function.\n\n## Examples\n\n    iex> IO.ANSI.format([\"Hello, \", :red, :bright, \"world!\"], true)\n    [[[[[[], \"Hello, \"] | \"\\e[31m\"] | \"\\e[1m\"], \"world!\"] | \"\\e[0m\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.format_fragment(ansidata, emit? \\\\ enabled?()) <response> Formats a chardata-like argument by converting named ANSI sequences into actual\nANSI codes.\n\nThe named sequences are represented by atoms.\n\nAn optional boolean parameter can be passed to enable or disable\nemitting actual ANSI codes. When `false`, no ANSI codes will be emitted.\nBy default checks if ANSI is enabled using the `enabled?/0` function.\n\n## Examples\n\n    iex> IO.ANSI.format_fragment([:bright, 'Word'], true)\n    [[[[[[] | \"\\e[1m\"], 87], 111], 114], 100]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.framed() <response> Framed."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.green() <response> Sets foreground color to green."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.green_background() <response> Sets background color to green."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.home() <response> Sends cursor home."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.inverse() <response> Image: negative. Swap foreground and background."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.inverse_off() <response> Image: positive. Normal foreground and background."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.italic() <response> Italic: on. Not widely supported. Sometimes treated as inverse."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_black() <response> Sets foreground color to light black."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_black_background() <response> Sets background color to light black."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_blue() <response> Sets foreground color to light blue."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_blue_background() <response> Sets background color to light blue."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_cyan() <response> Sets foreground color to light cyan."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_cyan_background() <response> Sets background color to light cyan."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_green() <response> Sets foreground color to light green."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_green_background() <response> Sets background color to light green."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_magenta() <response> Sets foreground color to light magenta."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_magenta_background() <response> Sets background color to light magenta."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_red() <response> Sets foreground color to light red."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_red_background() <response> Sets background color to light red."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_white() <response> Sets foreground color to light white."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_white_background() <response> Sets background color to light white."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_yellow() <response> Sets foreground color to light yellow."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.light_yellow_background() <response> Sets background color to light yellow."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.magenta() <response> Sets foreground color to magenta."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.magenta_background() <response> Sets background color to magenta."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.no_underline() <response> Underline: none."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.normal() <response> Normal color or intensity."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.not_framed_encircled() <response> Not framed or encircled."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.not_italic() <response> Not italic."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.not_overlined() <response> Not overlined."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.overlined() <response> Overlined."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.primary_font() <response> Sets primary (default) font."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.red() <response> Sets foreground color to red."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.red_background() <response> Sets background color to red."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.reset() <response> Resets all attributes."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.reverse() <response> Image: negative. Swap foreground and background."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.reverse_off() <response> Image: positive. Normal foreground and background."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.syntax_colors() <response> Syntax colors to be used by `Inspect`.\n\nThose colors are used throughout Elixir's standard library,\nsuch as `dbg/2` and `IEx`.\n\nThe colors can be changed by setting the `:ansi_syntax_colors`\nin the `:elixir` application configuration. Configuration for\nmost built-in data types are supported: `:atom`, `:binary`,\n`:boolean`, `:charlist`, `:list`, `:map`, `:nil`, `:number`,\n`:string`, and `:tuple`. The default is:\n\n    [\n      atom: :cyan\n      boolean: :magenta,\n      charlist: :yellow,\n      nil: :magenta,\n      number: :yellow,\n      string: :green\n    ]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.underline() <response> Underline: single."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.white() <response> Sets foreground color to white."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.white_background() <response> Sets background color to white."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.yellow() <response> Sets foreground color to yellow."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.yellow_background() <response> Sets background color to yellow."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.Elixir.IO.ANSI <response> Functionality to render ANSI escape sequences.\n\n[ANSI escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code)\nare characters embedded in text used to control formatting, color, and\nother output options on video text terminals.\n\nANSI escapes are typically enabled on all Unix terminals. They are also\navailable on Windows consoles from Windows 10, although it must be\nexplicitly enabled for the current user in the registry by running the\nfollowing command:\n\n    reg add HKCU\\Console /v VirtualTerminalLevel /t REG_DWORD /d 1\n\nAfter running the command above, you must restart your current console."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.ANSI.Elixir.IO.ANSI <response> Examples\n\nBecause the ANSI escape sequences are embedded in text, the normal usage of\nthese functions is to concatenate their output with text.\n\n    formatted_text = IO.ANSI.blue_background() <> \"Example\" <> IO.ANSI.reset()\n    IO.puts(formatted_text)\n\nA higher level and more convenient API is also available via `IO.ANSI.format/1`,\nwhere you use atoms to represent each ANSI escape sequence and by default\nchecks if ANSI is enabled:\n\n    IO.puts(IO.ANSI.format([:blue_background, \"Example\"]))\n\nIn case ANSI is disabled, the ANSI escape sequences are simply discarded."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.Stream.Elixir.IO.Stream <response> Defines an `IO.Stream` struct returned by `IO.stream/2` and `IO.binstream/2`.\n\nThe following fields are public:\n\n  * `device`        - the IO device\n  * `raw`           - a boolean indicating if bin functions should be used\n  * `line_or_bytes` - if reading should read lines or a given number of bytes\n\nIt is worth noting that an IO stream has side effects and every time you go\nover the stream you may get different results."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.binread(device \\\\ :stdio, line_or_chars) <response> Reads from the IO `device`. The operation is Unicode unsafe.\n\nThe `device` is iterated as specified by the `line_or_chars` argument:\n\n  * if `line_or_chars` is an integer, it represents a number of bytes. The device is\n    iterated by that number of bytes.\n\n  * if `line_or_chars` is `:line`, the device is iterated line by line.\n\n  * if `line_or_chars` is `:eof`, the device is iterated until `:eof`. `line_or_chars`\n    can only be `:eof` since Elixir 1.13.0. `:eof` replaces the deprecated `:all`,\n    with the difference that `:all` returns `\"\"` on end of file, while `:eof` returns\n    `:eof` itself.\n\nIt returns:\n\n  * `data` - the output bytes\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\nNote: do not use this function on IO devices in Unicode mode\nas it will return the wrong result."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.binstream() <response> Returns a raw, line-based `IO.Stream` on `:stdio`. The operation is Unicode unsafe.\n\nThis is equivalent to:\n\n    IO.binstream(:stdio, :line)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.binstream(device \\\\ :stdio, line_or_bytes) <response> Converts the IO `device` into an `IO.Stream`. The operation is Unicode unsafe.\n\nAn `IO.Stream` implements both `Enumerable` and\n`Collectable`, allowing it to be used for both read\nand write.\n\nThe `device` is iterated by the given number of bytes or line by line if\n`:line` is given. This reads from the IO device as a raw binary.\n\nNote that an IO stream has side effects and every time\nyou go over the stream you may get different results.\n\nFinally, do not use this function on IO devices in Unicode\nmode as it will return the wrong result.\n\n`binstream/0` has been introduced in Elixir v1.12.0,\nwhile `binstream/2` has been available since v1.0.0."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.binwrite(device \\\\ :stdio, iodata) <response> Writes `iodata` to the given `device`.\n\nThis operation is meant to be used with \"raw\" devices\nthat are started without an encoding. The given `iodata`\nis written as is to the device, without conversion. For\nmore information on IO data, see the \"IO data\" section in\nthe module documentation.\n\nUse `write/2` for devices with encoding.\n\nImportant: do **not** use this function on IO devices in\nUnicode mode as it will write the wrong data. In particular,\nthe standard IO device is set to Unicode by default, so writing\nto stdio with this function will likely result in the wrong data\nbeing sent down the wire."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.chardata_to_string(chardata) <response> Converts chardata into a string.\n\nFor more information about chardata, see the [\"Chardata\"](#module-chardata)\nsection in the module documentation.\n\nIn case the conversion fails, it raises an `UnicodeConversionError`.\nIf a string is given, it returns the string itself.\n\n## Examples\n\n    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n    \"Ã¦Ã\"\n\n    iex> IO.chardata_to_string([0x0061, \"bc\"])\n    \"abc\"\n\n    iex> IO.chardata_to_string(\"string\")\n    \"string\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.getn(prompt, count \\\\ 1) <response> Gets a number of bytes from IO device `:stdio`.\n\nIf `:stdio` is a Unicode device, `count` implies\nthe number of Unicode code points to be retrieved.\nOtherwise, `count` is the number of raw bytes to be retrieved.\n\nSee `IO.getn/3` for a description of return values."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.getn(device, prompt, count) <response> Gets a number of bytes from the IO `device`.\n\nIf the IO `device` is a Unicode device, `count` implies\nthe number of Unicode code points to be retrieved.\nOtherwise, `count` is the number of raw bytes to be retrieved.\n\nIt returns:\n\n  * `data` - the input characters\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.gets(device \\\\ :stdio, prompt) <response> Reads a line from the IO `device`.\n\nIt returns:\n\n  * `data` - the characters in the line terminated\n    by a line-feed (LF) or end of file (EOF)\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\n## Examples\n\nTo display \"What is your name?\" as a prompt and await user input:\n\n    IO.gets(\"What is your name?\\n\")"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.inspect(item, opts \\\\ []) <response> Inspects and writes the given `item` to the device.\n\nIt's important to note that it returns the given `item` unchanged.\nThis makes it possible to \"spy\" on values by inserting an\n`IO.inspect/2` call almost anywhere in your code, for example,\nin the middle of a pipeline.\n\nIt enables pretty printing by default with width of\n80 characters. The width can be changed by explicitly\npassing the `:width` option.\n\nThe output can be decorated with a label, by providing the `:label`\noption to easily distinguish it from other `IO.inspect/2` calls.\nThe label will be printed before the inspected `item`.\n\nSee `Inspect.Opts` for a full list of remaining formatting options.\n\n## Examples\n\n    IO.inspect(<<0, 1, 2>>, width: 40)\n\nPrints:\n\n    <<0, 1, 2>>\n\nWe can use the `:label` option to decorate the output:\n\n    IO.inspect(1..100, label: \"a wonderful range\")\n\nPrints:\n\n    a wonderful range: 1..100\n\nThe `:label` option is especially useful with pipelines:\n\n    [1, 2, 3]\n    |> IO.inspect(label: \"before\")\n    |> Enum.map(&(&1 * 2))\n    |> IO.inspect(label: \"after\")\n    |> Enum.sum()\n\nPrints:\n\n    before: [1, 2, 3]\n    after: [2, 4, 6]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.inspect(device, item, opts) <response> Inspects `item` according to the given options using the IO `device`.\n\nSee `inspect/2` for a full list of options."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.iodata_length(iodata) <response> Returns the size of an IO data.\n\nFor more information about IO data, see the [\"IO data\"](#module-io-data)\nsection in the module documentation.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> IO.iodata_length([1, 2 | <<3, 4>>])\n    4"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.iodata_to_binary(iodata) <response> Converts IO data into a binary\n\nThe operation is Unicode unsafe.\n\nNote that this function treats integers in the given IO data as\nraw bytes and does not perform any kind of encoding conversion.\nIf you want to convert from a charlist to a UTF-8-encoded string,\nuse `chardata_to_string/1` instead. For more information about\nIO data and chardata, see the [\"IO data\"](#module-io-data) section in the\nmodule documentation.\n\nIf this function receives a binary, the same binary is returned.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> bin1 = <<1, 2, 3>>\n    iex> bin2 = <<4, 5>>\n    iex> bin3 = <<6>>\n    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4 | bin3])\n    <<1, 2, 3, 1, 2, 3, 4, 5, 4, 6>>\n\n    iex> bin = <<1, 2, 3>>\n    iex> IO.iodata_to_binary(bin)\n    <<1, 2, 3>>"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.puts(device \\\\ :stdio, item) <response> Writes `item` to the given `device`, similar to `write/2`,\nbut adds a newline at the end.\n\nBy default, the `device` is the standard output. It returns `:ok`\nif it succeeds.\n\n## Examples\n\n    IO.puts(\"Hello World!\")\n    #=> Hello World!\n\n    IO.puts(:stderr, \"error\")\n    #=> error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.read(device \\\\ :stdio, line_or_chars) <response> Reads from the IO `device`.\n\nThe `device` is iterated by the given number of characters, line by line if\n`:line` is given, or until `:eof`.\n\nIt returns:\n\n  * `data` - the output characters\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.stream() <response> Returns a line-based `IO.Stream` on `:stdio`.\n\nThis is equivalent to:\n\n    IO.stream(:stdio, :line)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.stream(device \\\\ :stdio, line_or_codepoints) <response> Converts the IO `device` into an `IO.Stream`.\n\nAn `IO.Stream` implements both `Enumerable` and\n`Collectable`, allowing it to be used for both read\nand write.\n\nThe `device` is iterated by the given number of characters or line by line if\n`:line` is given.\n\nThis reads from the IO as UTF-8. Check out\n`IO.binstream/2` to handle the IO as a raw binary.\n\nNote that an IO stream has side effects and every time\nyou go over the stream you may get different results.\n\n`stream/0` has been introduced in Elixir v1.12.0,\nwhile `stream/2` has been available since v1.0.0.\n\n## Examples\n\nHere is an example on how we mimic an echo server\nfrom the command line:\n\n    Enum.each(IO.stream(:stdio, :line), &IO.write(&1))"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.warn(message) <response> Writes a `message` to stderr, along with the current stacktrace.\n\nIt returns `:ok` if it succeeds.\n\nDo not call this function at the tail of another function. Due to tail\ncall optimization, a stacktrace entry would not be added and the\nstacktrace would be incorrectly trimmed. Therefore make sure at least\none expression (or an atom such as `:ok`) follows the `IO.warn/1` call.\n\n## Examples\n\n    IO.warn(\"variable bar is unused\")\n    #=> warning: variable bar is unused\n    #=>   (iex) evaluator.ex:108: IEx.Evaluator.eval/4"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.warn(message, stacktrace_info) <response> Writes a `message` to stderr, along with the given `stacktrace_info`.\n\nThe `stacktrace_info` must be one of:\n\n  * a `__STACKTRACE__`, where all entries in the stacktrace will be\n    included in the error message\n\n  * a `Macro.Env` structure (since v1.14.0), where a single stacktrace\n    entry from the compilation environment will be used\n\n  * a keyword list with at least the `:file` option representing\n    a single stacktrace entry (since v1.14.0). The `:line`, `:module`,\n    `:function` options are also supported\n\nThis function also notifies the compiler a warning was printed\n(in case --warnings-as-errors was enabled). It returns `:ok`\nif it succeeds.\n\n## Examples\n\n    stacktrace = [{MyApp, :main, 1, [file: 'my_app.ex', line: 4]}]\n    IO.warn(\"variable bar is unused\", stacktrace)\n    #=> warning: variable bar is unused\n    #=>   my_app.ex:4: MyApp.main/1"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.write(device \\\\ :stdio, chardata) <response> Writes `chardata` to the given `device`.\n\nBy default, the `device` is the standard output.\n\n## Examples\n\n    IO.write(\"sample\")\n    #=> sample\n\n    IO.write(:stderr, \"error\")\n    #=> error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.Elixir.IO <response> Functions handling input/output (IO).\n\nMany functions in this module expect an IO device as an argument.\nAn IO device must be a PID or an atom representing a process.\nFor convenience, Elixir provides `:stdio` and `:stderr` as\nshortcuts to Erlang's `:standard_io` and `:standard_error`.\n\nThe majority of the functions expect chardata. In case another type is given,\nfunctions will convert those types to string via the `String.Chars` protocol\n(as shown in typespecs). For more information on chardata, see the\n\"IO data\" section below."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.Elixir.IO <response> IO devices\n\nAn IO device may be an atom or a PID. In case it is an atom,\nthe atom must be the name of a registered process. In addition,\nElixir provides two shortcuts:\n\n  * `:stdio` - a shortcut for `:standard_io`, which maps to\n    the current `Process.group_leader/0` in Erlang\n\n  * `:stderr` - a shortcut for the named process `:standard_error`\n    provided in Erlang\n\nIO devices maintain their position, which means subsequent calls to any\nreading or writing functions will start from the place where the device\nwas last accessed. The position of files can be changed using the\n`:file.position/2` function."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.Elixir.IO <response> IO data\n\nIO data is a data type that can be used as a more efficient alternative to binaries\nin certain situations.\n\nA term of type **IO data** is a binary or a list containing bytes (integers within the `0..255` range)\nor nested IO data. The type is recursive. Let's see an example of one of\nthe possible IO data representing the binary `\"hello\"`:\n\n    [?h, \"el\", [\"l\", [?o]]]\n\nThe built-in `t:iodata/0` type is defined in terms of `t:iolist/0`. An IO list is\nthe same as IO data but it doesn't allow for a binary at the top level (but binaries\nare still allowed in the list itself)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.Elixir.IO <response> # Use cases for IO data\n\nIO data exists because often you need to do many append operations\non smaller chunks of binaries in order to create a bigger binary. However, in\nErlang and Elixir concatenating binaries will copy the concatenated binaries\ninto a new binary.\n\n    def email(username, domain) do\n      username <> \"@\" <> domain\n    end\n\nIn this function, creating the email address will copy the `username` and `domain`\nbinaries. Now imagine you want to use the resulting email inside another binary:\n\n    def welcome_message(name, username, domain) do\n      \"Welcome #{name}, your email is: #{email(username, domain)}\"\n    end\n\n    IO.puts(welcome_message(\"Meg\", \"meg\", \"example.com\"))\n    #=> \"Welcome Meg, your email is: meg@example.com\"\n\nEvery time you concatenate binaries or use interpolation (`#{}`) you are making\ncopies of those binaries. However, in many cases you don't need the complete\nbinary while you create it, but only at the end to print it out or send it\nsomewhere. In such cases, you can construct the binary by creating IO data:\n\n    def email(username, domain) do\n      [username, ?@, domain]\n    end\n\n    def welcome_message(name, username, domain) do\n      [\"Welcome \", name, \", your email is: \", email(username, domain)]\n    end\n\n    IO.puts(welcome_message(\"Meg\", \"meg\", \"example.com\"))\n    #=> \"Welcome Meg, your email is: meg@example.com\"\n\nBuilding IO data is cheaper than concatenating binaries. Concatenating multiple\npieces of IO data just means putting them together inside a list since IO data\ncan be arbitrarily nested, and that's a cheap and efficient operation. Most of\nthe IO-based APIs, such as `:gen_tcp` and `IO`, receive IO data and write it\nto the socket directly without converting it to binary.\n\nOne drawback of IO data is that you can't do things like pattern match on the\nfirst part of a piece of IO data like you can with a binary, because you usually\ndon't know the shape of the IO data. In those cases, you may need to convert it\nto a binary by calling `iodata_to_binary/1`, which is reasonably efficient\nsince it's implemented natively in C. Other functionality, like computing the\nlength of IO data, can be computed directly on the iodata by calling `iodata_length/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.IO.Elixir.IO <response> # Chardata\n\nErlang and Elixir also have the idea of `t:chardata/0`. Chardata is very\nsimilar to IO data: the only difference is that integers in IO data represent\nbytes while integers in chardata represent Unicode code points. Bytes\n(`t:byte/0`) are integers within the `0..255` range, while Unicode code points\n(`t:char/0`) are integers within the `0..0x10FFFF` range. The `IO` module provides\nthe `chardata_to_string/1` function for chardata as the \"counter-part\" of the\n`iodata_to_binary/1` function for IO data.\n\nIf you try to use `iodata_to_binary/1` on chardata, it will result in an\nargument error. For example, let's try to put a code point that is not\nrepresentable with one byte, like `?Ï`, inside IO data:\n\n    IO.iodata_to_binary([\"The symbol for pi is: \", ?Ï])\n    #=> ** (ArgumentError) argument error\n\nIf we use chardata instead, it will work as expected:\n\n    iex> IO.chardata_to_string([\"The symbol for pi is: \", ?Ï])\n    \"The symbol for pi is: Ï\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.break(string \\\\ \" \") <response> Returns a break document based on the given `string`.\n\nThis break can be rendered as a linebreak or as the given `string`,\ndepending on the `mode` of the chosen layout.\n\n## Examples\n\nLet's create a document by concatenating two strings with a break between\nthem:\n\n    iex> doc = Inspect.Algebra.concat([\"a\", Inspect.Algebra.break(\"\\t\"), \"b\"])\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \"\\t\", \"b\"]\n\nNote that the break was represented with the given string, because we didn't\nreach a line limit. Once we do, it is replaced by a newline:\n\n    iex> break = Inspect.Algebra.break(\"\\t\")\n    iex> doc = Inspect.Algebra.concat([String.duplicate(\"a\", 20), break, \"b\"])\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 10)\n    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.collapse_lines(max) <response> Collapse any new lines and whitespace following this\nnode, emitting up to `max` new lines."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.color(doc, color_key, opts) <response> Colors a document if the `color_key` has a color in the options."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.concat(docs) <response> Concatenates a list of documents returning a new document.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.concat([\"a\", \"b\", \"c\"])\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \"b\", \"c\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.concat(doc1, doc2) <response> Concatenates two document entities returning a new document.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.concat(\"hello\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \"world\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.container_doc(left, collection, right, inspect_opts, fun, opts \\\\ []) <response> Wraps `collection` in `left` and `right` according to limit and contents.\n\nIt uses the given `left` and `right` documents as surrounding and the\nseparator document `separator` to separate items in `docs`. If all entries\nin the collection are simple documents (texts or strings), then this function\nattempts to put as much as possible on the same line. If they are not simple,\nonly one entry is shown per line if they do not fit.\n\nThe limit in the given `inspect_opts` is respected and when reached this\nfunction stops processing and outputs `\"...\"` instead.\n\n## Options\n\n  * `:separator` - the separator used between each doc\n  * `:break` - If `:strict`, always break between each element. If `:flex`,\n    breaks only when necessary. If `:maybe`, chooses `:flex` only if all\n    elements are text-based, otherwise is `:strict`\n\n## Examples\n\n    iex> inspect_opts = %Inspect.Opts{limit: :infinity}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun)\n    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary()\n    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n\n    iex> inspect_opts = %Inspect.Opts{limit: 3}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun)\n    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary()\n    \"[1, 2, 3, ...]\"\n\n    iex> inspect_opts = %Inspect.Opts{limit: 3}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> opts = [separator: \"!\"]\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun, opts)\n    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary()\n    \"[1! 2! 3! ...]\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.empty() <response> Returns a document entity used to represent nothingness.\n\n## Examples\n\n    iex> Inspect.Algebra.empty()\n    :doc_nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.flex_break(string \\\\ \" \") <response> Returns a flex break document based on the given `string`.\n\nA flex break still causes a group to break, like `break/1`,\nbut it is re-evaluated when the documented is rendered.\n\nFor example, take a group document represented as `[1, 2, 3]`\nwhere the space after every comma is a break. When the document\nabove does not fit a single line, all breaks are enabled,\ncausing the document to be rendered as:\n\n    [1,\n     2,\n     3]\n\nHowever, if flex breaks are used, then each break is re-evaluated\nwhen rendered, so the document could be possible rendered as:\n\n    [1, 2,\n     3]\n\nHence the name \"flex\". they are more flexible when it comes\nto the document fitting. On the other hand, they are more expensive\nsince each break needs to be re-evaluated.\n\nThis function is used by `container_doc/6` and friends to the\nmaximum number of entries on the same line."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.flex_glue(doc1, break_string \\\\ \" \", doc2) <response> Glues two documents (`doc1` and `doc2`) inserting a\n`flex_break/1` given by `break_string` between them.\n\nThis function is used by `container_doc/6` and friends\nto the maximum number of entries on the same line."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.fold_doc(docs, folder_fun) <response> Folds a list of documents into a document using the given folder function.\n\nThe list of documents is folded \"from the right\"; in that, this function is\nsimilar to `List.foldr/3`, except that it doesn't expect an initial\naccumulator and uses the last element of `docs` as the initial accumulator.\n\n## Examples\n\n    iex> docs = [\"A\", \"B\", \"C\"]\n    iex> docs =\n    ...>   Inspect.Algebra.fold_doc(docs, fn doc, acc ->\n    ...>     Inspect.Algebra.concat([doc, \"!\", acc])\n    ...>   end)\n    iex> Inspect.Algebra.format(docs, 80)\n    [\"A\", \"!\", \"B\", \"!\", \"C\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.force_unfit(doc) <response> Forces the current group to be unfit."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.format(doc, width) <response> Formats a given document for a given width.\n\nTakes the maximum width and a document to print as its arguments\nand returns an IO data representation of the best layout for the\ndocument to fit in the given width.\n\nThe document starts flat (without breaks) until a group is found.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \" \", \"world\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> doc |> Inspect.Algebra.format(30) |> IO.iodata_to_binary()\n    \"hello world\"\n    iex> doc |> Inspect.Algebra.format(10) |> IO.iodata_to_binary()\n    \"hello\\nworld\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.glue(doc1, break_string \\\\ \" \", doc2) <response> Glues two documents (`doc1` and `doc2`) inserting the given\nbreak `break_string` between them.\n\nFor more information on how the break is inserted, see `break/1`.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \" \", \"world\"]\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \"\\t\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \"\\t\", \"world\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.group(doc, mode \\\\ :self) <response> Returns a group containing the specified document `doc`.\n\nDocuments in a group are attempted to be rendered together\nto the best of the renderer ability.\n\nThe group mode can also be set to `:inherit`, which means it\nautomatically breaks if the parent group has broken too.\n\n## Examples\n\n    iex> doc =\n    ...>   Inspect.Algebra.group(\n    ...>     Inspect.Algebra.concat(\n    ...>       Inspect.Algebra.group(\n    ...>         Inspect.Algebra.concat(\n    ...>           \"Hello,\",\n    ...>           Inspect.Algebra.concat(\n    ...>             Inspect.Algebra.break(),\n    ...>             \"A\"\n    ...>           )\n    ...>         )\n    ...>       ),\n    ...>       Inspect.Algebra.concat(\n    ...>         Inspect.Algebra.break(),\n    ...>         \"B\"\n    ...>       )\n    ...>     )\n    ...>   )\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n    iex> Inspect.Algebra.format(doc, 6)\n    [\"Hello,\", \"\\n\", \"A\", \"\\n\", \"B\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.line() <response> A mandatory linebreak.\n\nA group with linebreaks will fit if all lines in the group fit.\n\n## Examples\n\n    iex> doc =\n    ...>   Inspect.Algebra.concat(\n    ...>     Inspect.Algebra.concat(\n    ...>       \"Hughes\",\n    ...>       Inspect.Algebra.line()\n    ...>     ),\n    ...>     \"Wadler\"\n    ...>   )\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hughes\", \"\\n\", \"Wadler\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.line(doc1, doc2) <response> Inserts a mandatory linebreak between two documents.\n\nSee `line/0`.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.line(\"Hughes\", \"Wadler\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hughes\", \"\\n\", \"Wadler\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.nest(doc, level, mode \\\\ :always) <response> Nests the given document at the given `level`.\n\nIf `level` is an integer, that's the indentation appended\nto line breaks whenever they occur. If the level is `:cursor`,\nthe current position of the \"cursor\" in the document becomes\nthe nesting. If the level is `:reset`, it is set back to 0.\n\n`mode` can be `:always`, which means nesting always happen,\nor `:break`, which means nesting only happens inside a group\nthat has been broken.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world\"), 5)\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 5)\n    [\"hello\", \"\\n     \", \"world\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.next_break_fits(doc, mode \\\\ :enabled) <response> Considers the next break as fit.\n\n`mode` can be `:enabled` or `:disabled`. When `:enabled`,\nit will consider the document as fit as soon as it finds\nthe next break, effectively cancelling the break. It will\nalso ignore any `force_unfit/1` in search of the next break.\n\nWhen disabled, it behaves as usual and it will ignore\nany further `next_break_fits/2` instruction.\n\n## Examples\n\nThis is used by Elixir's code formatter to avoid breaking\ncode at some specific locations. For example, consider this\ncode:\n\n    some_function_call(%{..., key: value, ...})\n\nNow imagine that this code does not fit its line. The code\nformatter introduces breaks inside `(` and `)` and inside\n`%{` and `}`. Therefore the document would break as:\n\n    some_function_call(\n      %{\n        ...,\n        key: value,\n        ...\n      }\n    )\n\nThe formatter wraps the algebra document representing the\nmap in `next_break_fits/1` so the code is formatted as:\n\n    some_function_call(%{\n      ...,\n      key: value,\n      ...\n    })"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.space(doc1, doc2) <response> Inserts a mandatory single space between two documents.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.space(\"Hughes\", \"Wadler\")\n    iex> Inspect.Algebra.format(doc, 5)\n    [\"Hughes\", \" \", \"Wadler\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.string(string) <response> Creates a document represented by string.\n\nWhile `Inspect.Algebra` accepts binaries as documents,\nthose are counted by binary size. On the other hand,\n`string` documents are measured in terms of graphemes\ntowards the document size.\n\n## Examples\n\nThe following document has 10 bytes and therefore it\ndoes not format to width 9 without breaks:\n\n    iex> doc = Inspect.Algebra.glue(\"olÃ¡\", \" \", \"mundo\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 9)\n    [\"olÃ¡\", \"\\n\", \"mundo\"]\n\nHowever, if we use `string`, then the string length is\nused, instead of byte size, correctly fitting:\n\n    iex> string = Inspect.Algebra.string(\"olÃ¡\")\n    iex> doc = Inspect.Algebra.glue(string, \" \", \"mundo\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 9)\n    [\"olÃ¡\", \" \", \"mundo\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.to_doc(term, opts) <response> Converts an Elixir term to an algebra document\naccording to the `Inspect` protocol."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.Elixir.Inspect.Algebra <response> A set of functions for creating and manipulating algebra\ndocuments.\n\nThis module implements the functionality described in\n[\"Strictly Pretty\" (2000) by Christian Lindig][0] with small\nadditions, like support for binary nodes and a break mode that\nmaximises use of horizontal space.\n\n    iex> Inspect.Algebra.empty()\n    :doc_nil\n\n    iex> \"foo\"\n    \"foo\"\n\nWith the functions in this module, we can concatenate different\nelements together and render them:\n\n    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty(), \"foo\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"foo\"]\n\nThe functions `nest/2`, `space/2` and `line/2` help you put the\ndocument together into a rigid structure. However, the document\nalgebra gets interesting when using functions like `glue/3` and\n`group/1`. A glue inserts a break between two documents. A group\nindicates a document that must fit the current line, otherwise\nbreaks are rendered as new lines. Let's glue two docs together\nwith a break, group it and then render it:\n\n    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \" \", \"b\"]\n\nNote that the break was represented as is, because we haven't reached\na line limit. Once we do, it is replaced by a newline:\n\n    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 10)\n    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n\nThis module uses the byte size to compute how much space there is\nleft. If your document contains strings, then those need to be\nwrapped in `string/1`, which then relies on `String.length/1` to\nprecompute the document size.\n\nFinally, this module also contains Elixir related functions, a bit\ntied to Elixir formatting, such as `to_doc/2`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Algebra.Elixir.Inspect.Algebra <response> Implementation details\n\nThe implementation of `Inspect.Algebra` is based on the Strictly Pretty\npaper by [Lindig][0] which builds on top of previous pretty printing\nalgorithms but is tailored to strict languages, such as Elixir.\nThe core idea in the paper is the use of explicit document groups which\nare rendered as flat (breaks as spaces) or as break (breaks as newlines).\n\nThis implementation provides two types of breaks: `:strict` and `:flex`.\nWhen a group does not fit, all strict breaks are treated as newlines.\nFlex breaks however are re-evaluated on every occurrence and may still\nbe rendered flat. See `break/1` and `flex_break/1` for more information.\n\nThis implementation also adds `force_unfit/1` and `next_break_fits/2` which\ngive more control over the document fitting.\n\n  [0]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Error.Elixir.Inspect.Error <response> Raised when a struct cannot be inspected."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Opts.default_inspect_fun() <response> Returns the default inspect function."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Opts.default_inspect_fun(fun) <response> Sets the default inspect function.\n\nSet this option with care as it will change how all values\nin the system are inspected. The main use of this functionality\nis to provide an entry point to filter inspected values,\nin order for entities to comply with rules and legislations\non data security and data privacy.\n\nIt is **extremely discouraged** for libraries to set their own\nfunction as this must be controlled by applications. Libraries\nshould instead define their own structs with custom inspect\nimplementations. If a library must change the default inspect\nfunction, then it is best to define to ask users of your library\nto explicitly call `default_inspect_fun/1` with your function of\nchoice.\n\nThe default is `Inspect.inspect/2`.\n\n## Examples\n\n    previous_fun = Inspect.Opts.default_inspect_fun()\n\n    Inspect.Opts.default_inspect_fun(fn\n      %{address: _} = map, opts ->\n        previous_fun.(%{map | address: \"[REDACTED]\"}, opts)\n\n      value, opts ->\n        previous_fun.(value, opts)\n    end)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Opts.new(opts) <response> Builds an `Inspect.Opts` struct."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Opts.Elixir.Inspect.Opts <response> Defines the options used by the `Inspect` protocol.\n\nThe following fields are available:\n\n  * `:base` - prints integers as `:binary`, `:octal`, `:decimal`, or `:hex`,\n    defaults to `:decimal`. When inspecting binaries any `:base` other than\n    `:decimal` implies `binaries: :as_binaries`.\n\n  * `:binaries` - when `:as_binaries` all binaries will be printed in bit\n    syntax.\n\n    When `:as_strings` all binaries will be printed as strings, non-printable\n    bytes will be escaped.\n\n    When the default `:infer`, the binary will be printed as a string if it\n    is printable, otherwise in bit syntax. See `String.printable?/1` to learn\n    when a string is printable.\n\n  * `:charlists` - when `:as_charlists` all lists will be printed as charlists,\n    non-printable elements will be escaped.\n\n    When `:as_lists` all lists will be printed as lists.\n\n    When the default `:infer`, the list will be printed as a charlist if it\n    is printable, otherwise as list. See `List.ascii_printable?/1` to learn\n    when a charlist is printable.\n\n  * `:custom_options` (since v1.9.0) - a keyword list storing custom user-defined\n    options. Useful when implementing the `Inspect` protocol for nested structs\n    to pass the custom options through.\n\n  * `:inspect_fun` (since v1.9.0) - a function to build algebra documents.\n    Defaults to `Inspect.Opts.default_inspect_fun/0`.\n\n  * `:limit` - limits the number of items that are inspected for tuples,\n    bitstrings, maps, lists and any other collection of items, with the exception of\n    printable strings and printable charlists which use the `:printable_limit` option.\n    If you don't want to limit the number of items to a particular number,\n    use `:infinity`. It accepts a positive integer or `:infinity`.\n    Defaults to `50`.\n\n  * `:pretty` - if set to `true` enables pretty printing. Defaults to `false`.\n\n  * `:printable_limit` - limits the number of characters that are inspected\n    on printable strings and printable charlists. You can use `String.printable?/1`\n    and `List.ascii_printable?/1` to check if a given string or charlist is\n    printable. If you don't want to limit the number of characters to a particular\n    number, use `:infinity`. It accepts a positive integer or `:infinity`.\n    Defaults to `4096`.\n\n  * `:safe` - when `false`, failures while inspecting structs will be raised\n    as errors instead of being wrapped in the `Inspect.Error` exception. This\n    is useful when debugging failures and crashes for custom inspect\n    implementations. Defaults to `true`.\n\n  * `:structs` - when `false`, structs are not formatted by the inspect\n    protocol, they are instead printed as maps. Defaults to `true`.\n\n  * `:syntax_colors` - when set to a keyword list of colors the output is\n    colorized. The keys are types and the values are the colors to use for\n    each type (for example, `[number: :red, atom: :blue]`). Types can include\n    `:atom`, `:binary`, `:boolean`, `:list`, `:map`, `:number`, `:regex`,\n    `:string`, and `:tuple`. Custom data types may provide their own options.\n    Colors can be any `t:IO.ANSI.ansidata/0` as accepted by `IO.ANSI.format/1`.\n    A default list of colors can be retrieved from `IO.ANSI.syntax_colors/0`.\n\n  * `:width` - number of characters per line used when pretty is `true` or when\n    printing to IO devices. Set to `0` to force each item to be printed on its\n    own line. If you don't want to limit the number of items to a particular\n    number, use `:infinity`. Defaults to `80`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.inspect(term, opts) <response> Converts `term` into an algebra document.\n\nThis function shouldn't be invoked directly, unless when implementing\na custom `inspect_fun` to be given to `Inspect.Opts`. Everywhere else,\n`Inspect.Algebra.to_doc/2` should be preferred as it handles structs\nand exceptions."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Elixir.Inspect <response> The `Inspect` protocol converts an Elixir data structure into an\nalgebra document.\n\nThis is typically done when you want to customize how your own\nstructs are inspected in logs and the terminal.\n\nThis documentation refers to implementing the `Inspect` protocol\nfor your own data structures. To learn more about using inspect,\nsee `Kernel.inspect/2` and `IO.inspect/2`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Elixir.Inspect <response> Inspect representation\n\nThere are typically three choices of inspect representation. In order\nto understand them, let's imagine we have the following `User` struct:\n\n    defmodule User do\n      defstruct [:id, :name, :address]\n    end\n\nOur choices are:\n\n  1. Print the struct using Elixir's struct syntax, for example:\n     `%User{address: \"Earth\", id: 13, name: \"Jane\"}`. This is the\n     default representation and best choice if all struct fields\n     are public.\n\n  2. Print using the `#User<...>` notation, for example: `#User<id: 13, name: \"Jane\", ...>`.\n     This notation does not emit valid Elixir code and is typically\n     used when the struct has private fields (for example, you may want\n     to hide the field `:address` to redact person identifiable information).\n\n  3. Print the struct using the expression syntax, for example:\n     `User.new(13, \"Jane\", \"Earth\")`. This assumes there is a `User.new/3`\n     function. This option is mostly used as an alternative to option 2\n     for representing custom data structures, such as `MapSet`, `Date.Range`,\n     and others.\n\nYou can implement the Inspect protocol for your own structs while\nadhering to the conventions above. Option 1 is the default representation\nand you can quickly achieve option 2 by deriving the `Inspect` protocol.\nFor option 3, you need your custom implementation."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Elixir.Inspect <response> Deriving\n\nThe `Inspect` protocol can be derived to customize the order of fields\n(the default is alphabetical) and hide certain fields from structs,\nso they don't show up in logs, inspects and similar. The latter is\nespecially useful for fields containing private information.\n\nThe supported options are:\n\n  * `:only` - only include the given fields when inspecting.\n\n  * `:except` - remove the given fields when inspecting.\n\n  * `:optional` - (since v1.14.0) do not include a field if it\n    matches its default value. This can be used to simplify the\n    struct representation at the cost of hiding information.\n\nWhenever `:only` or `:except` are used to restrict fields,\nthe struct will be printed using the `#User<...>` notation,\nas the struct can no longer be copy and pasted as valid Elixir\ncode. Let's see an example:\n\n    defmodule User do\n      @derive {Inspect, only: [:id, :name]}\n      defstruct [:id, :name, :address]\n    end\n\n    inspect(%User{id: 1, name: \"Jane\", address: \"Earth\"})\n    #=> #User<id: 1, name: \"Jane\", ...>\n\nIf you use only the `:optional` option, the struct will still be\nprinted as `%User{...}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Elixir.Inspect <response> Custom implementation\n\nYou can also define your custom protocol implementation by\ndefining the `inspect/2` function. The function receives the\nentity to be inspected followed by the inspecting options,\nrepresented by the struct `Inspect.Opts`. Building of the\nalgebra document is done with `Inspect.Algebra`.\n\nMany times, inspecting a structure can be implemented in function\nof existing entities. For example, here is `MapSet`'s `inspect/2`\nimplementation:\n\n    defimpl Inspect, for: MapSet do\n      import Inspect.Algebra\n\n      def inspect(map_set, opts) do\n        concat([\"MapSet.new(\", Inspect.List.inspect(MapSet.to_list(map_set), opts), \")\"])\n      end\n    end\n\nThe [`concat/1`](`Inspect.Algebra.concat/1`) function comes from\n`Inspect.Algebra` and it concatenates algebra documents together.\nIn the example above it is concatenating the string `\"MapSet.new(\"`,\nthe document returned by `Inspect.Algebra.to_doc/2`, and the final\nstring `\")\"`. Therefore, the MapSet with the numbers 1, 2, and 3\nwill be printed as:\n\n    iex> MapSet.new([1, 2, 3], fn x -> x * 2 end)\n    MapSet.new([2, 4, 6])\n\nIn other words, `MapSet`'s inspect representation returns an expression\nthat, when evaluated, builds the `MapSet` itself."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Inspect.Elixir.Inspect <response> # Error handling\n\nIn case there is an error while your structure is being inspected,\nElixir will raise an `ArgumentError` error and will automatically fall back\nto a raw representation for printing the structure.\n\nYou can however access the underlying error by invoking the `Inspect`\nimplementation directly. For example, to test `Inspect.MapSet` above,\nyou can invoke it as:\n\n    Inspect.MapSet.inspect(MapSet.new(), %Inspect.Opts{})"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Integer.digits(integer, base \\\\ 10) <response> Returns the ordered digits for the given `integer`.\n\nAn optional `base` value may be provided representing the radix for the returned\ndigits. This one must be an integer >= 2.\n\n## Examples\n\n    iex> Integer.digits(123)\n    [1, 2, 3]\n\n    iex> Integer.digits(170, 2)\n    [1, 0, 1, 0, 1, 0, 1, 0]\n\n    iex> Integer.digits(-170, 2)\n    [-1, 0, -1, 0, -1, 0, -1, 0]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Integer.extended_gcd(a, b) <response> Returns the extended greatest common divisor of the two given integers.\n\nThis function uses the extended Euclidean algorithm to return a three-element tuple with the `gcd`\nand the coefficients `m` and `n` of BÃ©zout's identity such that:\n\n    gcd(a, b) = m*a + n*b\n\nBy convention, `extended_gcd(0, 0)` returns `{0, 0, 0}`.\n\n## Examples\n\n    iex> Integer.extended_gcd(240, 46)\n    {2, -9, 47}\n    iex> Integer.extended_gcd(46, 240)\n    {2, 47, -9}\n    iex> Integer.extended_gcd(-46, 240)\n    {2, -47, -9}\n    iex> Integer.extended_gcd(-46, -240)\n    {2, -47, 9}\n\n    iex> Integer.extended_gcd(14, 21)\n    {7, -1, 1}\n\n    iex> Integer.extended_gcd(10, 0)\n    {10, 1, 0}\n    iex> Integer.extended_gcd(0, 10)\n    {10, 0, 1}\n    iex> Integer.extended_gcd(0, 0)\n    {0, 0, 0}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Integer.floor_div(dividend, divisor) <response> Performs a floored integer division.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\nThis function performs a *floored* integer division, which means that\nthe result will always be rounded towards negative infinity.\n\nIf you want to perform truncated integer division (rounding towards zero),\nuse `Kernel.div/2` instead.\n\n## Examples\n\n    iex> Integer.floor_div(5, 2)\n    2\n    iex> Integer.floor_div(6, -4)\n    -2\n    iex> Integer.floor_div(-99, 2)\n    -50"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Integer.gcd(integer1, integer2) <response> Returns the greatest common divisor of the two given integers.\n\nThe greatest common divisor (GCD) of `integer1` and `integer2` is the largest positive\ninteger that divides both `integer1` and `integer2` without leaving a remainder.\n\nBy convention, `gcd(0, 0)` returns `0`.\n\n## Examples\n\n    iex> Integer.gcd(2, 3)\n    1\n\n    iex> Integer.gcd(8, 12)\n    4\n\n    iex> Integer.gcd(8, -12)\n    4\n\n    iex> Integer.gcd(10, 0)\n    10\n\n    iex> Integer.gcd(7, 7)\n    7\n\n    iex> Integer.gcd(0, 0)\n    0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Integer.mod(dividend, divisor) <response> Computes the modulo remainder of an integer division.\n\nThis function performs a [floored division](`floor_div/2`), which means that\nthe result will always have the sign of the `divisor`.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\n## Examples\n\n    iex> Integer.mod(5, 2)\n    1\n    iex> Integer.mod(6, -4)\n    -2"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Integer.parse(binary, base \\\\ 10) <response> Parses a text representation of an integer.\n\nAn optional `base` to the corresponding integer can be provided.\nIf `base` is not given, 10 will be used.\n\nIf successful, returns a tuple in the form of `{integer, remainder_of_binary}`.\nOtherwise `:error`.\n\nRaises an error if `base` is less than 2 or more than 36.\n\nIf you want to convert a string-formatted integer directly to an integer,\n`String.to_integer/1` or `String.to_integer/2` can be used instead.\n\n## Examples\n\n    iex> Integer.parse(\"34\")\n    {34, \"\"}\n\n    iex> Integer.parse(\"34.5\")\n    {34, \".5\"}\n\n    iex> Integer.parse(\"three\")\n    :error\n\n    iex> Integer.parse(\"34\", 10)\n    {34, \"\"}\n\n    iex> Integer.parse(\"f4\", 16)\n    {244, \"\"}\n\n    iex> Integer.parse(\"Awww++\", 36)\n    {509216, \"++\"}\n\n    iex> Integer.parse(\"fab\", 10)\n    :error\n\n    iex> Integer.parse(\"a2\", 38)\n    ** (ArgumentError) invalid base 38"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Integer.pow(base, exponent) <response> Computes `base` raised to power of `exponent`.\n\nBoth `base` and `exponent` must be integers.\nThe exponent must be zero or positive.\n\nSee `Float.pow/2` for exponentiation of negative\nexponents as well as floats.\n\n## Examples\n\n    iex> Integer.pow(2, 0)\n    1\n    iex> Integer.pow(2, 1)\n    2\n    iex> Integer.pow(2, 10)\n    1024\n    iex> Integer.pow(2, 11)\n    2048\n    iex> Integer.pow(2, 64)\n    0x10000000000000000\n\n    iex> Integer.pow(3, 4)\n    81\n    iex> Integer.pow(4, 3)\n    64\n\n    iex> Integer.pow(-2, 3)\n    -8\n    iex> Integer.pow(-2, 4)\n    16\n\n    iex> Integer.pow(2, -2)\n    ** (ArithmeticError) bad argument in arithmetic expression"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Integer.to_charlist(integer, base \\\\ 10) <response> Returns a charlist which corresponds to the text representation\nof `integer` in the given `base`.\n\n`base` can be an integer between 2 and 36. If no `base` is given,\nit defaults to `10`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Integer.to_charlist(123)\n    '123'\n\n    iex> Integer.to_charlist(+456)\n    '456'\n\n    iex> Integer.to_charlist(-789)\n    '-789'\n\n    iex> Integer.to_charlist(0123)\n    '123'\n\n    iex> Integer.to_charlist(100, 16)\n    '64'\n\n    iex> Integer.to_charlist(-100, 16)\n    '-64'\n\n    iex> Integer.to_charlist(882_681_651, 36)\n    'ELIXIR'"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Integer.to_string(integer, base \\\\ 10) <response> Returns a binary which corresponds to the text representation\nof `integer` in the given `base`.\n\n`base` can be an integer between 2 and 36. If no `base` is given,\nit defaults to `10`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Integer.to_string(123)\n    \"123\"\n\n    iex> Integer.to_string(+456)\n    \"456\"\n\n    iex> Integer.to_string(-789)\n    \"-789\"\n\n    iex> Integer.to_string(0123)\n    \"123\"\n\n    iex> Integer.to_string(100, 16)\n    \"64\"\n\n    iex> Integer.to_string(-100, 16)\n    \"-64\"\n\n    iex> Integer.to_string(882_681_651, 36)\n    \"ELIXIR\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Integer.undigits(digits, base \\\\ 10) <response> Returns the integer represented by the ordered `digits`.\n\nAn optional `base` value may be provided representing the radix for the `digits`.\nBase has to be an integer greater than or equal to `2`.\n\n## Examples\n\n    iex> Integer.undigits([1, 2, 3])\n    123\n\n    iex> Integer.undigits([1, 4], 16)\n    20\n\n    iex> Integer.undigits([])\n    0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Integer.Elixir.Integer <response> Functions for working with integers.\n\nSome functions that work on integers are found in `Kernel`:\n\n  * `Kernel.abs/1`\n  * `Kernel.div/2`\n  * `Kernel.max/2`\n  * `Kernel.min/2`\n  * `Kernel.rem/2`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.CLI.format_error(kind, reason, stacktrace) <response> Shared helper for error formatting on CLI tools."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.CLI.main(argv) <response> This is the API invoked by Elixir boot process."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.CLI.parse_argv(argv) <response> Parses the CLI arguments. Made public for testing."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.CLI.process_commands(config) <response> Process CLI commands. Made public for testing."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.CLI.rpc_eval(expr) <response> Function invoked across nodes for `--rpc-eval`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.CLI.run(fun) <response> Runs the given function by catching any failure\nand printing them to stdout. `at_exit` hooks are\nalso invoked before exiting.\n\nThis function is used by Elixir's CLI and also\nby escripts generated by Elixir."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.LexicalTracker.references(pid) <response> Returns all references in this lexical scope."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.ParallelCompiler.async(fun) <response> Starts a task for parallel compilation.\n\nIf you have a file that needs to compile other modules in parallel,\nthe spawned processes need to be aware of the compiler environment.\nThis function allows a developer to create a task that is aware of\nthose environments.\n\nSee `Task.async/1` for more information. The task spawned must be\nalways awaited on by calling `Task.await/1`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.ParallelCompiler.compile(files, options \\\\ []) <response> Compiles the given files.\n\nThose files are compiled in parallel and can automatically\ndetect dependencies between them. Once a dependency is found,\nthe current file stops being compiled until the dependency is\nresolved.\n\nIt returns `{:ok, modules, warnings}` or `{:error, errors, warnings}`.\n\nBoth errors and warnings are a list of three-element tuples containing\nthe file, line and the formatted error/warning.\n\n## Options\n\n  * `:each_file` - for each file compiled, invokes the callback passing the\n    file\n\n  * `:each_long_compilation` - for each file that takes more than a given\n    timeout (see the `:long_compilation_threshold` option) to compile, invoke\n    this callback passing the file as its argument\n\n  * `:each_module` - for each module compiled, invokes the callback passing\n    the file, module and the module bytecode\n\n  * `:each_cycle` - after the given files are compiled, invokes this function\n    that should return the following values:\n    * `{:compile, modules, warnings}` - to continue compilation with a list of\n      further modules to compile\n    * `{:runtime, modules, warnings}` - to stop compilation and verify the list\n      of modules because dependent modules have changed\n\n  * `:long_compilation_threshold` - the timeout (in seconds) to check for modules\n    taking too long to compile. For each file that exceeds the threshold, the\n    `:each_long_compilation` callback is invoked. From Elixir v1.11, only the time\n    spent compiling the actual module is taken into account by the threshold, the\n    time spent waiting is not considered. Defaults to `10` seconds.\n\n  * `:profile` - if set to `:time` measure the compilation time of each compilation cycle\n     and group pass checker\n\n  * `:dest` - the destination directory for the BEAM files. When using `compile/2`,\n    this information is only used to properly annotate the BEAM files before\n    they are loaded into memory. If you want a file to actually be written to\n    `dest`, use `compile_to_path/3` instead.\n\n  * `:beam_timestamp` - the modification timestamp to give all BEAM files"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.ParallelCompiler.compile_to_path(files, path, options \\\\ []) <response> Compiles the given files and writes resulting BEAM files into path.\n\nSee `compile/2` for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.ParallelCompiler.print_warning(arg) <response> Prints a warning returned by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.ParallelCompiler.require(files, options \\\\ []) <response> Requires the given files in parallel.\n\nOpposite to compile, dependencies are not attempted to be\nautomatically solved between files.\n\nIt returns `{:ok, modules, warnings}` or `{:error, errors, warnings}`.\n\nBoth errors and warnings are a list of three-element tuples containing\nthe file, line and the formatted error/warning.\n\n## Options\n\n  * `:each_file` - for each file compiled, invokes the callback passing the\n    file\n\n  * `:each_module` - for each module compiled, invokes the callback passing\n    the file, module and the module bytecode"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.ParallelCompiler.Elixir.Kernel.ParallelCompiler <response> A module responsible for compiling and requiring files in parallel."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.SpecialForms.Elixir.Kernel.SpecialForms <response> Special forms are the basic building blocks of Elixir, and therefore\ncannot be overridden by the developer.\n\nThe `Kernel.SpecialForms` module consists solely of macros that can be\ninvoked anywhere in Elixir code without the use of the\n`Kernel.SpecialForms.` prefix. This is possible because they all have\nbeen automatically imported, in the same fashion as the functions and\nmacros from the `Kernel` module.\n\nThese building blocks are defined in this module. Some of these special forms are lexical (such as\n`alias/2` and `case/2`). The macros `{}/1` and `<<>>/1` are also special\nforms used to define tuple and binary data structures respectively.\n\nThis module also documents macros that return information about Elixir's\ncompilation environment, such as (`__ENV__/0`, `__MODULE__/0`, `__DIR__/0`,\n`__STACKTRACE__/0`, and `__CALLER__/0`).\n\nAdditionally, it documents two special forms, `__block__/1` and\n`__aliases__/1`, which are not intended to be called directly by the\ndeveloper but they appear in quoted contents since they are essential\nin Elixir's constructs."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Typespec.deftypespec(kind, expr, line, file, module, pos) <response> Defines a typespec.\n\nInvoked by `@/1` expansion."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Utils.announce_struct(module) <response> Announcing callback for defstruct."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Utils.defdelegate_all(funs, opts, env) <response> Callback for defdelegate entry point."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Utils.defdelegate_each(fun, opts) <response> Callback for each function in defdelegate."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Utils.defstruct(module, fields, bootstrapped?) <response> Callback for defstruct."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Utils.destructure(list, count) <response> Callback for destructure."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Utils.raise(msg) <response> Callback for raise."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left != right <response> Not equal to operator.\n\nReturns `true` if the two terms are not equal.\n\nThis operator considers 1 and 1.0 to be equal. For match\ncomparison, use `!==/2` instead.\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 != 2\n    true\n\n    iex> 1 != 1.0\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left !== right <response> Strictly not equal to operator.\n\nReturns `true` if the two terms are not exactly equal.\nSee `===/2` for a definition of what is considered \"exactly equal\".\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 !== 2\n    true\n\n    iex> 1 !== 1.0\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left * right <response> Arithmetic multiplication operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 * 2\n    2"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.base ** exponent <response> Power operator.\n\nIt expects two numbers are input. If the left-hand side is an integer\nand the right-hand side is more than or equal to 0, then the result is\ninteger. Otherwise it returns a float.\n\n## Examples\n\n    iex> 2 ** 2\n    4\n    iex> 2 ** -4\n    0.0625\n\n    iex> 2.0 ** 2\n    4.0\n    iex> 2 ** 2.0\n    4.0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.+value <response> Arithmetic positive unary operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> +1\n    1"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left + right <response> Arithmetic addition operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 + 2\n    3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left ++ right <response> List concatenation operator. Concatenates a proper list and a term, returning a list.\n\nThe complexity of `a ++ b` is proportional to `length(a)`, so avoid repeatedly\nappending to lists of arbitrary length, for example, `list ++ [element]`.\nInstead, consider prepending via `[element | rest]` and then reversing.\n\nIf the `right` operand is not a proper list, it returns an improper list.\nIf the `left` operand is not a proper list, it raises `ArgumentError`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> [1] ++ [2, 3]\n    [1, 2, 3]\n\n    iex> 'foo' ++ 'bar'\n    'foobar'\n\n    # returns an improper list\n    iex> [1] ++ 2\n    [1 | 2]\n\n    # returns a proper list\n    iex> [1] ++ [2]\n    [1, 2]\n\n    # improper list on the right will return an improper list\n    iex> [1] ++ [2 | 3]\n    [1, 2 | 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.-value <response> Arithmetic negative unary operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> -2\n    -2"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left - right <response> Arithmetic subtraction operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 - 2\n    -1"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left -- right <response> List subtraction operator. Removes the first occurrence of an element\non the left list for each element on the right.\n\nThis function is optimized so the complexity of `a -- b` is proportional\nto `length(a) * log(length(b))`. See also the [Erlang efficiency\nguide](https://www.erlang.org/doc/efficiency_guide/retired_myths.html).\n\nInlined by the compiler.\n\n## Examples\n\n    iex> [1, 2, 3] -- [1, 2]\n    [3]\n\n    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n    [3, 1]\n\nThe `--/2` operator is right associative, meaning:\n\n    iex> [1, 2, 3] -- [2] -- [3]\n    [1, 3]\n\nAs it is equivalent to:\n\n    iex> [1, 2, 3] -- ([2] -- [3])\n    [1, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left / right <response> Arithmetic division operator.\n\nThe result is always a float. Use `div/2` and `rem/2` if you want\nan integer division or the remainder.\n\nRaises `ArithmeticError` if `right` is 0 or 0.0.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    1 / 2\n    #=> 0.5\n\n    -3.0 / 2.0\n    #=> -1.5\n\n    5 / 1\n    #=> 5.0\n\n    7 / 0\n    ** (ArithmeticError) bad argument in arithmetic expression"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left < right <response> Less-than operator.\n\nReturns `true` if `left` is less than `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 < 2\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left <= right <response> Less-than or equal to operator.\n\nReturns `true` if `left` is less than or equal to `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 <= 2\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left == right <response> Equal to operator. Returns `true` if the two terms are equal.\n\nThis operator considers 1 and 1.0 to be equal. For stricter\nsemantics, use `===/2` instead.\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 == 2\n    false\n\n    iex> 1 == 1.0\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left === right <response> Strictly equal to operator.\n\nReturns `true` if the two terms are exactly equal.\n\nThe terms are only considered to be exactly equal if they\nhave the same value and are of the same type. For example,\n`1 == 1.0` returns `true`, but since they are of different\ntypes, `1 === 1.0` returns `false`.\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 === 2\n    false\n\n    iex> 1 === 1.0\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left =~ right <response> Text-based match operator. Matches the term on the `left`\nagainst the regular expression or string on the `right`.\n\nIf `right` is a regular expression, returns `true` if `left` matches right.\n\nIf `right` is a string, returns `true` if `left` contains `right`.\n\n## Examples\n\n    iex> \"abcd\" =~ ~r/c(d)/\n    true\n\n    iex> \"abcd\" =~ ~r/e/\n    false\n\n    iex> \"abcd\" =~ ~r//\n    true\n\n    iex> \"abcd\" =~ \"bc\"\n    true\n\n    iex> \"abcd\" =~ \"ad\"\n    false\n\n    iex> \"abcd\" =~ \"abcd\"\n    true\n\n    iex> \"abcd\" =~ \"\"\n    true\n\nFor more information about regular expressions, please check the `Regex` module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left > right <response> Greater-than operator.\n\nReturns `true` if `left` is more than `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 > 2\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.left >= right <response> Greater-than or equal to operator.\n\nReturns `true` if `left` is more than or equal to `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 >= 2\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.abs(number) <response> Returns an integer or float which is the arithmetical absolute value of `number`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> abs(-3.33)\n    3.33\n\n    iex> abs(-3)\n    3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.apply(fun, args) <response> Invokes the given anonymous function `fun` with the list of\narguments `args`.\n\nIf the number of arguments is known at compile time, prefer\n`fun.(arg_1, arg_2, ..., arg_n)` as it is clearer than\n`apply(fun, [arg_1, arg_2, ..., arg_n])`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> apply(fn x -> x * 2 end, [2])\n    4"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.apply(module, function_name, args) <response> Invokes the given function from `module` with the list of\narguments `args`.\n\n`apply/3` is used to invoke functions where the module, function\nname or arguments are defined dynamically at runtime. For this\nreason, you can't invoke macros using `apply/3`, only functions.\n\nIf the number of arguments and the function name are known at compile time,\nprefer `module.function(arg_1, arg_2, ..., arg_n)` as it is clearer than\n`apply(module, :function, [arg_1, arg_2, ..., arg_n])`.\n\n`apply/3` cannot be used to call private functions.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> apply(Enum, :reverse, [[1, 2, 3]])\n    [3, 2, 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.binary_part(binary, start, length) <response> Extracts the part of the binary starting at `start` with length `length`.\nBinaries are zero-indexed.\n\nIf `start` or `length` reference in any way outside the binary, an\n`ArgumentError` exception is raised.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> binary_part(\"foo\", 1, 2)\n    \"oo\"\n\nA negative `length` can be used to extract bytes that come *before* the byte\nat `start`:\n\n    iex> binary_part(\"Hello\", 5, -3)\n    \"llo\"\n\nAn `ArgumentError` is raised when the length is outside of the binary:\n\n    binary_part(\"Hello\", 0, 10)\n    ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.binary_slice(binary, range) <response> Returns a binary from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nIf the start or end of the range are negative, they are converted\ninto positive indices based on the binary size. For example,\n`-1` means the last byte of the binary.\n\nThis is similar to `binary_part/3` except that it works with ranges\nand it is not allowed in guards.\n\nThis function works with bytes. For a slicing operation that\nconsiders characters, see `String.slice/2`.\n\n## Examples\n\n    iex> binary_slice(\"elixir\", 0..5)\n    \"elixir\"\n    iex> binary_slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> binary_slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> binary_slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", -10..10)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> binary_slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole binary as is:\n\n    iex> binary_slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the binary:\n\n    iex> binary_slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> binary_slice(\"elixir\", 10..3//1)\n    \"\"\n    iex> binary_slice(\"elixir\", -10..-7)\n    \"\"\n    iex> binary_slice(\"a\", 1..1500)\n    \"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.binary_slice(binary, start, size) <response> Returns a binary starting at the offset `start` and of the given `size`.\n\nThis is similar to `binary_part/3` except that if `start + size`\nis greater than the binary size, it automatically clips it to\nthe binary size instead of raising. Opposite to `binary_part/3`,\nthis function is not allowed in guards.\n\nThis function works with bytes. For a slicing operation that\nconsiders characters, see `String.slice/3`.\n\n## Examples\n\n    iex> binary_slice(\"elixir\", 0, 6)\n    \"elixir\"\n    iex> binary_slice(\"elixir\", 0, 5)\n    \"elixi\"\n    iex> binary_slice(\"elixir\", 1, 4)\n    \"lixi\"\n    iex> binary_slice(\"elixir\", 0, 10)\n    \"elixir\"\n\nIf `start` is negative, it is normalized against the binary\nsize and clamped to 0:\n\n    iex> binary_slice(\"elixir\", -3, 10)\n    \"xir\"\n    iex> binary_slice(\"elixir\", -10, 10)\n    \"elixir\"\n\nIf the `size` is zero, an empty binary is returned:\n\n    iex> binary_slice(\"elixir\", 1, 0)\n    \"\"\n\nIf `start` is greater than or equal to the binary size,\nan empty binary is returned:\n\n    iex> binary_slice(\"elixir\", 10, 10)\n    \"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.bit_size(bitstring) <response> Returns an integer which is the size in bits of `bitstring`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bit_size(<<433::16, 3::3>>)\n    19\n\n    iex> bit_size(<<1, 2, 3>>)\n    24"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.byte_size(bitstring) <response> Returns the number of bytes needed to contain `bitstring`.\n\nThat is, if the number of bits in `bitstring` is not divisible by 8, the\nresulting number of bytes will be rounded up (by excess). This operation\nhappens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> byte_size(<<433::16, 3::3>>)\n    3\n\n    iex> byte_size(<<1, 2, 3>>)\n    3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.ceil(number) <response> Returns the smallest integer greater than or equal to `number`.\n\nIf you want to perform ceil operation on other decimal places,\nuse `Float.ceil/2` instead.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.div(dividend, divisor) <response> Performs an integer division.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\n`div/2` performs *truncated* integer division. This means that\nthe result is always rounded towards zero.\n\nIf you want to perform floored integer division (rounding towards negative infinity),\nuse `Integer.floor_div/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    div(5, 2)\n    #=> 2\n\n    div(6, -4)\n    #=> -1\n\n    div(-99, 2)\n    #=> -49\n\n    div(100, 0)\n    ** (ArithmeticError) bad argument in arithmetic expression"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.elem(tuple, index) <response> Gets the element at the zero-based `index` in `tuple`.\n\nIt raises `ArgumentError` when index is negative or it is out of range of the tuple elements.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    tuple = {:foo, :bar, 3}\n    elem(tuple, 1)\n    #=> :bar\n\n    elem({}, 0)\n    ** (ArgumentError) argument error\n\n    elem({:foo, :bar}, 2)\n    ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.exit(reason) <response> Stops the execution of the calling process with the given reason.\n\nSince evaluating this function causes the process to terminate,\nit has no return value.\n\nInlined by the compiler.\n\n## Examples\n\nWhen a process reaches its end, by default it exits with\nreason `:normal`. You can also call `exit/1` explicitly if you\nwant to terminate a process but not signal any failure:\n\n    exit(:normal)\n\nIn case something goes wrong, you can also use `exit/1` with\na different reason:\n\n    exit(:seems_bad)\n\nIf the exit reason is not `:normal`, all the processes linked to the process\nthat exited will crash (unless they are trapping exits).\n\n## OTP exits\n\nExits are used by the OTP to determine if a process exited abnormally\nor not. The following exits are considered \"normal\":\n\n  * `exit(:normal)`\n  * `exit(:shutdown)`\n  * `exit({:shutdown, term})`\n\nExiting with any other reason is considered abnormal and treated\nas a crash. This means the default supervisor behaviour kicks in,\nerror reports are emitted, and so forth.\n\nThis behaviour is relied on in many different places. For example,\n`ExUnit` uses `exit(:shutdown)` when exiting the test process to\nsignal linked processes, supervision trees and so on to politely\nshut down too.\n\n## CLI exits\n\nBuilding on top of the exit signals mentioned above, if the\nprocess started by the command line exits with any of the three\nreasons above, its exit is considered normal and the Operating\nSystem process will exit with status 0.\n\nIt is, however, possible to customize the operating system exit\nsignal by invoking:\n\n    exit({:shutdown, integer})\n\nThis will cause the operating system process to exit with the status given by\n`integer` while signaling all linked Erlang processes to politely\nshut down.\n\nAny other exit reason will cause the operating system process to exit with\nstatus `1` and linked Erlang processes to crash."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.floor(number) <response> Returns the largest integer smaller than or equal to `number`.\n\nIf you want to perform floor operation on other decimal places,\nuse `Float.floor/2` instead.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.function_exported?(module, function, arity) <response> Returns `true` if `module` is loaded and contains a\npublic `function` with the given `arity`, otherwise `false`.\n\nNote that this function does not load the module in case\nit is not loaded. Check `Code.ensure_loaded/1` for more\ninformation.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> function_exported?(Enum, :map, 2)\n    true\n\n    iex> function_exported?(Enum, :map, 10)\n    false\n\n    iex> function_exported?(List, :to_string, 1)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.get_and_update_in(data, keys, fun) <response> Gets a value and updates a nested structure.\n\n`data` is a nested structure (that is, a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nThe `fun` argument receives the value of `key` (or `nil` if `key`\nis not present) and must return one of the following values:\n\n  * a two-element tuple `{current_value, new_value}`. In this case,\n    `current_value` is the retrieved value which can possibly be operated on before\n    being returned. `new_value` is the new value to be stored under `key`.\n\n  * `:pop`, which implies that the current value under `key`\n    should be removed from the structure and returned.\n\nThis function uses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a function,\nwhich is detailed in a later section.\n\n## Examples\n\nThis function is useful when there is a need to retrieve the current\nvalue (or something calculated in function of the current value) and\nupdate it at the same time. For example, it could be used to read the\ncurrent age of a user while increasing it by one in one pass:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n\nNote the current value given to the anonymous function may be `nil`.\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users, [\"jane\", :age], &{&1, &1 + 1})\n    ** (ArgumentError) could not put/update key :age on a nil value\n\n## Functions as keys\n\nIf a key is a function, the function will be invoked passing three\narguments:\n\n  * the operation (`:get_and_update`)\n  * the data to be accessed\n  * a function to be invoked next\n\nThis means `get_and_update_in/3` can be extended to provide custom\nlookups. The downside is that functions cannot be stored as keys\nin the accessed data structures.\n\nWhen one of the keys is a function, the function is invoked.\nIn the example below, we use a function to get and increment all\nages inside a list:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> all = fn :get_and_update, data, next ->\n    ...>   data |> Enum.map(next) |> Enum.unzip()\n    ...> end\n    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n\nIf the previous value before invoking the function is `nil`,\nthe function *will* receive `nil` as a value and must handle it\naccordingly (be it by failing or providing a sane default).\n\nThe `Access` module ships with many convenience accessor functions,\nlike the `all` anonymous function defined above. See `Access.all/0`,\n`Access.key/2`, and others as examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.get_in(data, keys) <response> Gets a value from a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction, which is detailed in a later section.\n\nNote that if none of the given keys are functions,\nthere is rarely a reason to use `get_in` over\nwriting \"regular\" Elixir code using `[]`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users, [\"john\", :age])\n    27\n    iex> # Equivalent to:\n    iex> users[\"john\"][:age]\n    27\n\n`get_in/2` can also use the accessors in the `Access` module\nto traverse more complex data structures. For example, here we\nuse `Access.all/0` to traverse a list:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> get_in(users, [Access.all(), :age])\n    [27, 23]\n\nIn case any of the components returns `nil`, `nil` will be returned\nand `get_in/2` won't traverse any further:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users, [\"unknown\", :age])\n    nil\n    iex> # Equivalent to:\n    iex> users[\"unknown\"][:age]\n    nil\n\n    iex> users = nil\n    iex> get_in(users, [Access.all(), :age])\n    nil\n\nAlternatively, if you need to access complex data-structures, you can\nuse pattern matching:\n\n    case users do\n      %{\"john\" => %{age: age}} -> age\n      _ -> default_value\n    end\n\n## Functions as keys\n\nIf a key given to `get_in/2` is a function, the function will be invoked\npassing three arguments:\n\n  * the operation (`:get`)\n  * the data to be accessed\n  * a function to be invoked next\n\nThis means `get_in/2` can be extended to provide custom lookups.\nThat's precisely how the `Access.all/0` key in the previous section\nbehaves. For example, we can manually implement such traversal as\nfollows:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> all = fn :get, data, next -> Enum.map(data, next) end\n    iex> get_in(users, [all, :age])\n    [27, 23]\n\nThe `Access` module ships with many convenience accessor functions.\nSee `Access.all/0`, `Access.key/2`, and others as examples.\n\n## Working with structs\n\nBy default, structs do not implement the `Access` behaviour required\nby this function. Therefore, you can't do this:\n\n    get_in(some_struct, [:some_key, :nested_key])\n\nThe good news is that structs have predefined shape. Therefore,\nyou can write instead:\n\n    some_struct.some_key.nested_key\n\nIf, by any chance, `some_key` can return nil, you can always\nfallback to pattern matching to provide nested struct handling:\n\n    case some_struct do\n      %{some_key: %{nested_key: value}} -> value\n      %{} -> nil\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.hd(list) <response> Returns the head of a list. Raises `ArgumentError` if the list is empty.\n\nThe head of a list is its first element.\n\nIt works with improper lists.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    hd([1, 2, 3, 4])\n    #=> 1\n\n    hd([1 | 2])\n    #=> 1\n\nGiving it an empty list raises:\n\n    hd([])\n    #=> ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.inspect(term, opts \\\\ []) <response> Inspects the given argument according to the `Inspect` protocol.\nThe second argument is a keyword list with options to control\ninspection.\n\n## Options\n\n`inspect/2` accepts a list of options that are internally\ntranslated to an `Inspect.Opts` struct. Check the docs for\n`Inspect.Opts` to see the supported options.\n\n## Examples\n\n    iex> inspect(:foo)\n    \":foo\"\n\n    iex> inspect([1, 2, 3, 4, 5], limit: 3)\n    \"[1, 2, 3, ...]\"\n\n    iex> inspect([1, 2, 3], pretty: true, width: 0)\n    \"[1,\\n 2,\\n 3]\"\n\n    iex> inspect(\"olÃ¡\" <> <<0>>)\n    \"<<111, 108, 195, 161, 0>>\"\n\n    iex> inspect(\"olÃ¡\" <> <<0>>, binaries: :as_strings)\n    \"\\\"olÃ¡\\\\0\\\"\"\n\n    iex> inspect(\"olÃ¡\", binaries: :as_binaries)\n    \"<<111, 108, 195, 161>>\"\n\n    iex> inspect('bar')\n    \"'bar'\"\n\n    iex> inspect([0 | 'bar'])\n    \"[0, 98, 97, 114]\"\n\n    iex> inspect(100, base: :octal)\n    \"0o144\"\n\n    iex> inspect(100, base: :hex)\n    \"0x64\"\n\nNote that the `Inspect` protocol does not necessarily return a valid\nrepresentation of an Elixir term. In such cases, the inspected result\nmust start with `#`. For example, inspecting a function will return:\n\n    inspect(fn a, b -> a + b end)\n    #=> #Function<...>\n\nThe `Inspect` protocol can be derived to hide certain fields\nfrom structs, so they don't show up in logs, inspects and similar.\nSee the \"Deriving\" section of the documentation of the `Inspect`\nprotocol for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_atom(term) <response> Returns `true` if `term` is an atom; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_atom(false)\n    true\n\n    iex> is_atom(:name)\n    true\n\n    iex> is_atom(AnAtom)\n    true\n\n    iex> is_atom(\"true\")\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_binary(term) <response> Returns `true` if `term` is a binary; otherwise returns `false`.\n\nA binary always contains a complete number of bytes.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_binary(\"foo\")\n    true\n    iex> is_binary(<<1::3>>)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_bitstring(term) <response> Returns `true` if `term` is a bitstring (including a binary); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_bitstring(\"foo\")\n    true\n    iex> is_bitstring(<<1::3>>)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_boolean(term) <response> Returns `true` if `term` is either the atom `true` or the atom `false` (i.e.,\na boolean); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_boolean(false)\n    true\n\n    iex> is_boolean(true)\n    true\n\n    iex> is_boolean(:test)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_float(term) <response> Returns `true` if `term` is a floating-point number; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_function(term) <response> Returns `true` if `term` is a function; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_function(fn x -> x + x end)\n    true\n\n    iex> is_function(\"not a function\")\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_function(term, arity) <response> Returns `true` if `term` is a function that can be applied with `arity` number of arguments;\notherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_function(fn x -> x * 2 end, 1)\n    true\n    iex> is_function(fn x -> x * 2 end, 2)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_integer(term) <response> Returns `true` if `term` is an integer; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_list(term) <response> Returns `true` if `term` is a list with zero or more elements; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_map(term) <response> Returns `true` if `term` is a map; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_map_key(map, key) <response> Returns `true` if `key` is a key in `map`; otherwise returns `false`.\n\nIt raises `BadMapError` if the first element is not a map.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_number(term) <response> Returns `true` if `term` is either an integer or a floating-point number;\notherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_pid(term) <response> Returns `true` if `term` is a PID (process identifier); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_port(term) <response> Returns `true` if `term` is a port identifier; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_reference(term) <response> Returns `true` if `term` is a reference; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.is_tuple(term) <response> Returns `true` if `term` is a tuple; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.length(list) <response> Returns the length of `list`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    9"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.macro_exported?(module, macro, arity) <response> Returns `true` if `module` is loaded and contains a\npublic `macro` with the given `arity`, otherwise `false`.\n\nNote that this function does not load the module in case\nit is not loaded. Check `Code.ensure_loaded/1` for more\ninformation.\n\nIf `module` is an Erlang module (as opposed to an Elixir module), this\nfunction always returns `false`.\n\n## Examples\n\n    iex> macro_exported?(Kernel, :use, 2)\n    true\n\n    iex> macro_exported?(:erlang, :abs, 1)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.make_ref() <response> Returns an almost unique reference.\n\nThe returned reference will re-occur after approximately 2^82 calls;\ntherefore it is unique enough for practical purposes.\n\nInlined by the compiler.\n\n## Examples\n\n    make_ref()\n    #=> #Reference<0.0.0.135>"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.map_size(map) <response> Returns the size of a map.\n\nThe size of a map is the number of key-value pairs that the map contains.\n\nThis operation happens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> map_size(%{a: \"foo\", b: \"bar\"})\n    2"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.max(first, second) <response> Returns the biggest of the two given terms according to\ntheir structural comparison.\n\nIf the terms compare equal, the first one is returned.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> max(1, 2)\n    2\n    iex> max(:a, :b)\n    :b"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.min(first, second) <response> Returns the smallest of the two given terms according to\ntheir structural comparison.\n\nIf the terms compare equal, the first one is returned.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> min(1, 2)\n    1\n    iex> min(\"foo\", \"bar\")\n    \"bar\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.node() <response> Returns an atom representing the name of the local node.\nIf the node is not alive, `:nonode@nohost` is returned instead.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.node(arg) <response> Returns the node where the given argument is located.\nThe argument can be a PID, a reference, or a port.\nIf the local node is not alive, `:nonode@nohost` is returned.\n\nAllowed in guard tests. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.not value <response> Strictly boolean \"not\" operator.\n\n`value` must be a boolean; if it's not, an `ArgumentError` exception is raised.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> not false\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.pop_in(data, keys) <response> Pops a key from the given nested structure.\n\nUses the `Access` protocol to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users, [\"john\", :age])\n    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n\nIn case any entry returns `nil`, its key will be removed\nand the deletion will be considered a success.\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users, [\"jane\", :age])\n    {nil, %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.put_elem(tuple, index, value) <response> Puts `value` at the given zero-based `index` in `tuple`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, 3}\n    iex> put_elem(tuple, 0, :baz)\n    {:baz, :bar, 3}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.put_in(data, keys, value) <response> Puts a value in a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users, [\"john\", :age], 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users, [\"jane\", :age], \"oops\")\n    ** (ArgumentError) could not put/update key :age on a nil value"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.rem(dividend, divisor) <response> Computes the remainder of an integer division.\n\n`rem/2` uses truncated division, which means that\nthe result will always have the sign of the `dividend`.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> rem(5, 2)\n    1\n    iex> rem(6, -4)\n    2"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.round(number) <response> Rounds a number to the nearest integer.\n\nIf the number is equidistant to the two nearest integers, rounds away from zero.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> round(5.6)\n    6\n\n    iex> round(5.2)\n    5\n\n    iex> round(-9.9)\n    -10\n\n    iex> round(-9)\n    -9\n\n    iex> round(2.5)\n    3\n\n    iex> round(-2.5)\n    -3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.self() <response> Returns the PID (process identifier) of the calling process.\n\nAllowed in guard clauses. Inlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.send(dest, message) <response> Sends a message to the given `dest` and returns the message.\n\n`dest` may be a remote or local PID, a local port, a locally\nregistered name, or a tuple in the form of `{registered_name, node}` for a\nregistered name at another node.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> send(self(), :hello)\n    :hello"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.spawn(fun) <response> Spawns the given function and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    child = spawn(fn -> send(current, {self(), 1 + 2}) end)\n\n    receive do\n      {^child, 3} -> IO.puts(\"Received 3 back\")\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.spawn(module, fun, args) <response> Spawns the given function `fun` from the given `module` passing it the given\n`args` and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn(SomeModule, :function, [1, 2, 3])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.spawn_link(fun) <response> Spawns the given function, links it to the current process, and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions. For more\ninformation on linking, check `Process.link/1`.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    child = spawn_link(fn -> send(current, {self(), 1 + 2}) end)\n\n    receive do\n      {^child, 3} -> IO.puts(\"Received 3 back\")\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.spawn_link(module, fun, args) <response> Spawns the given function `fun` from the given `module` passing it the given\n`args`, links it to the current process, and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions. For more\ninformation on linking, check `Process.link/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn_link(SomeModule, :function, [1, 2, 3])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.spawn_monitor(fun) <response> Spawns the given function, monitors it and returns its PID\nand monitoring reference.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    spawn_monitor(fn -> send(current, {self(), 1 + 2}) end)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.spawn_monitor(module, fun, args) <response> Spawns the given module and function passing the given args,\nmonitors it and returns its PID and monitoring reference.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn_monitor(SomeModule, :function, [1, 2, 3])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.struct(struct, fields \\\\ []) <response> Creates and updates a struct.\n\nThe `struct` argument may be an atom (which defines `defstruct`)\nor a `struct` itself. The second argument is any `Enumerable` that\nemits two-element tuples (key-value pairs) during enumeration.\n\nKeys in the `Enumerable` that don't exist in the struct are automatically\ndiscarded. Note that keys must be atoms, as only atoms are allowed when\ndefining a struct. If keys in the `Enumerable` are duplicated, the last\nentry will be taken (same behaviour as `Map.new/1`).\n\nThis function is useful for dynamically creating and updating structs, as\nwell as for converting maps to structs; in the latter case, just inserting\nthe appropriate `:__struct__` field into the map may not be enough and\n`struct/2` should be used instead.\n\n## Examples\n\n    defmodule User do\n      defstruct name: \"john\"\n    end\n\n    struct(User)\n    #=> %User{name: \"john\"}\n\n    opts = [name: \"meg\"]\n    user = struct(User, opts)\n    #=> %User{name: \"meg\"}\n\n    struct(user, unknown: \"value\")\n    #=> %User{name: \"meg\"}\n\n    struct(User, %{name: \"meg\"})\n    #=> %User{name: \"meg\"}\n\n    # String keys are ignored\n    struct(User, %{\"name\" => \"meg\"})\n    #=> %User{name: \"john\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.struct!(struct, fields \\\\ []) <response> Similar to `struct/2` but checks for key validity.\n\nThe function `struct!/2` emulates the compile time behaviour\nof structs. This means that:\n\n  * when building a struct, as in `struct!(SomeStruct, key: :value)`,\n    it is equivalent to `%SomeStruct{key: :value}` and therefore this\n    function will check if every given key-value belongs to the struct.\n    If the struct is enforcing any key via `@enforce_keys`, those will\n    be enforced as well;\n\n  * when updating a struct, as in `struct!(%SomeStruct{}, key: :value)`,\n    it is equivalent to `%SomeStruct{struct | key: :value}` and therefore this\n    function will check if every given key-value belongs to the struct.\n    However, updating structs does not enforce keys, as keys are enforced\n    only when building;"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.throw(term) <response> A non-local return from a function.\n\nUsing `throw/1` is generally discouraged, as it allows a function\nto escape from its regular execution flow, which can make the code\nharder to read. Furthermore, all thrown values must be caught by\n`try/catch`. See `try/1` for more information.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.tl(list) <response> Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n\nThe tail of a list is the list without its first element.\n\nIt works with improper lists.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    tl([1, 2, 3, :go])\n    #=> [2, 3, :go]\n\n    tl([:one])\n    #=> []\n\n    tl([:a, :b | :improper_end])\n    #=> [:b | :improper_end]\n\n    tl([:a | %{b: 1}])\n    #=> %{b: 1}\n\nGiving it an empty list raises:\n\n    tl([])\n    #=> ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.trunc(number) <response> Returns the integer part of `number`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> trunc(5.4)\n    5\n\n    iex> trunc(-5.99)\n    -5\n\n    iex> trunc(-5)\n    -5"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.tuple_size(tuple) <response> Returns the size of a tuple.\n\nThis operation happens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> tuple_size({:a, :b, :c})\n    3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.update_in(data, keys, fun) <response> Updates a key in a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n`data` is a nested structure (that is, a map, keyword\nlist, or struct that implements the `Access` behaviour).\nThe `fun` argument receives the value of `key` (or `nil`\nif `key` is not present) and the result replaces the value\nin the structure.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nNote the current value given to the anonymous function may be `nil`.\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users, [\"jane\", :age], & &1 + 1)\n    ** (ArgumentError) could not put/update key :age on a nil value"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> `Kernel` is Elixir's default environment.\n\nIt mainly consists of:\n\n  * basic language primitives, such as arithmetic operators, spawning of processes,\n    data type handling, and others\n  * macros for control-flow and defining new functionality (modules, functions, and the like)\n  * guard checks for augmenting pattern matching\n\nYou can invoke `Kernel` functions and macros anywhere in Elixir code\nwithout the use of the `Kernel.` prefix since they have all been\nautomatically imported. For example, in IEx, you can call:\n\n    iex> is_number(13)\n    true\n\nIf you don't want to import a function or macro from `Kernel`, use the `:except`\noption and then list the function/macro by arity:\n\n    import Kernel, except: [if: 2, unless: 2]\n\nSee `Kernel.SpecialForms.import/2` for more information on importing.\n\nElixir also has special forms that are always imported and\ncannot be skipped. These are described in `Kernel.SpecialForms`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> The standard library\n\n`Kernel` provides the basic capabilities the Elixir standard library\nis built on top of. It is recommended to explore the standard library\nfor advanced functionality. Here are the main groups of modules in the\nstandard library (this list is not a complete reference, see the\ndocumentation sidebar for all entries)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> # Built-in types\n\nThe following modules handle Elixir built-in data types:\n\n  * `Atom` - literal constants with a name (`true`, `false`, and `nil` are atoms)\n  * `Float` - numbers with floating point precision\n  * `Function` - a reference to code chunk, created with the `fn/1` special form\n  * `Integer` - whole numbers (not fractions)\n  * `List` - collections of a variable number of elements (linked lists)\n  * `Map` - collections of key-value pairs\n  * `Process` - light-weight threads of execution\n  * `Port` - mechanisms to interact with the external world\n  * `Tuple` - collections of a fixed number of elements\n\nThere are two data types without an accompanying module:\n\n  * Bitstring - a sequence of bits, created with `Kernel.SpecialForms.<<>>/1`.\n    When the number of bits is divisible by 8, they are called binaries and can\n    be manipulated with Erlang's `:binary` module\n  * Reference - a unique value in the runtime system, created with `make_ref/0`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> # Data types\n\nElixir also provides other data types that are built on top of the types\nlisted above. Some of them are:\n\n  * `Date` - `year-month-day` structs in a given calendar\n  * `DateTime` - date and time with time zone in a given calendar\n  * `Exception` - data raised from errors and unexpected scenarios\n  * `MapSet` - unordered collections of unique elements\n  * `NaiveDateTime` - date and time without time zone in a given calendar\n  * `Keyword` - lists of two-element tuples, often representing optional values\n  * `Range` - inclusive ranges between two integers\n  * `Regex` - regular expressions\n  * `String` - UTF-8 encoded binaries representing characters\n  * `Time` - `hour:minute:second` structs in a given calendar\n  * `URI` - representation of URIs that identify resources\n  * `Version` - representation of versions and requirements"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> # System modules\n\nModules that interface with the underlying system, such as:\n\n  * `IO` - handles input and output\n  * `File` - interacts with the underlying file system\n  * `Path` - manipulates file system paths\n  * `System` - reads and writes system information"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> # Protocols\n\nProtocols add polymorphic dispatch to Elixir. They are contracts\nimplementable by data types. See `Protocol` for more information on\nprotocols. Elixir provides the following protocols in the standard library:\n\n  * `Collectable` - collects data into a data type\n  * `Enumerable` - handles collections in Elixir. The `Enum` module\n    provides eager functions for working with collections, the `Stream`\n    module provides lazy functions\n  * `Inspect` - converts data types into their programming language\n    representation\n  * `List.Chars` - converts data types to their outside world\n    representation as charlists (non-programming based)\n  * `String.Chars` - converts data types to their outside world\n    representation as strings (non-programming based)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> # Process-based and application-centric functionality\n\nThe following modules build on top of processes to provide concurrency,\nfault-tolerance, and more.\n\n  * `Agent` - a process that encapsulates mutable state\n  * `Application` - functions for starting, stopping and configuring\n    applications\n  * `GenServer` - a generic client-server API\n  * `Registry` - a key-value process-based storage\n  * `Supervisor` - a process that is responsible for starting,\n    supervising and shutting down other processes\n  * `Task` - a process that performs computations\n  * `Task.Supervisor` - a supervisor for managing tasks exclusively"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> # Supporting documents\n\nElixir documentation also includes supporting documents under the\n\"Pages\" section. Those are:\n\n  * [Compatibility and deprecations](compatibility-and-deprecations.md) - lists\n    compatibility between every Elixir version and Erlang/OTP, release schema;\n    lists all deprecated functions, when they were deprecated and alternatives\n  * [Library guidelines](library-guidelines.md) - general guidelines, anti-patterns,\n    and rules for those writing libraries\n  * [Naming conventions](naming-conventions.md) - naming conventions for Elixir code\n  * [Operators](operators.md) - lists all Elixir operators and their precedences\n  * [Patterns and guards](patterns-and-guards.md) - an introduction to patterns,\n    guards, and extensions\n  * [Syntax reference](syntax-reference.md) - the language syntax reference\n  * [Typespecs](typespecs.md)- types and function specifications, including list of types\n  * [Unicode syntax](unicode-syntax.md) - outlines Elixir support for Unicode\n  * [Writing documentation](writing-documentation.md) - guidelines for writing\n    documentation in Elixir"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> Guards\n\nThis module includes the built-in guards used by Elixir developers.\nThey are a predefined set of functions and macros that augment pattern\nmatching, typically invoked after the `when` operator. For example:\n\n    def drive(%User{age: age}) when age >= 16 do\n      ...\n    end\n\nThe clause above will only be invoked if the user's age is more than\nor equal to 16. Guards also support joining multiple conditions with\n`and` and `or`. The whole guard is true if all guard expressions will\nevaluate to `true`. A more complete introduction to guards is available\nin the [Patterns and guards](patterns-and-guards.md) page."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> Structural comparison\n\nThe comparison functions in this module perform structural comparison.\nThis means structures are compared based on their representation and\nnot on their semantic value. This is specially important for functions\nthat are meant to provide ordering, such as `>/2`, `</2`, `>=/2`,\n`<=/2`, `min/2`, and `max/2`. For example:\n\n    ~D[2017-03-31] > ~D[2017-04-01]\n\nwill return `true` because structural comparison compares the `:day`\nfield before `:month` or `:year`. Therefore, when comparing structs,\nyou often use the `compare/2` function made available by the structs\nmodules themselves:\n\n    iex> Date.compare(~D[2017-03-31], ~D[2017-04-01])\n    :lt\n\nAlternatively, you can use the functions in the `Enum` module to\nsort or compute a maximum/minimum:\n\n    iex> Enum.sort([~D[2017-03-31], ~D[2017-04-01]], Date)\n    [~D[2017-03-31], ~D[2017-04-01]]\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-04-01]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> Truthy and falsy values\n\nBesides the booleans `true` and `false`, Elixir has the\nconcept of a \"truthy\" or \"falsy\" value.\n\n  *  a value is truthy when it is neither `false` nor `nil`\n  *  a value is falsy when it is either `false` or `nil`\n\nElixir has functions, like `and/2`, that *only* work with\nbooleans, but also functions that work with these\ntruthy/falsy values, like `&&/2` and `!/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> # Examples\n\nWe can check the truthiness of a value by using the `!/1`\nfunction twice.\n\nTruthy values:\n\n    iex> !!true\n    true\n    iex> !!5\n    true\n    iex> !![1,2]\n    true\n    iex> !!\"foo\"\n    true\n\nFalsy values (of which there are exactly two):\n\n    iex> !!false\n    false\n    iex> !!nil\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Kernel.Elixir.Kernel <response> Inlining\n\nSome of the functions described in this module are inlined by\nthe Elixir compiler into their Erlang counterparts in the\n[`:erlang`](`:erlang`) module.\nThose functions are called BIFs (built-in internal functions)\nin Erlang-land and they exhibit interesting properties, as some\nof them are allowed in guards and others are used for compiler\noptimizations.\n\nMost of the inlined functions can be seen in effect when\ncapturing the function:\n\n    iex> &Kernel.is_atom/1\n    &:erlang.is_atom/1\n\nThose functions will be explicitly marked in their docs as\n\"inlined by the compiler\"."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.delete(keywords, key) <response> Deletes the entries in the keyword list under a specific `key`.\n\nIf the `key` does not exist, it returns the keyword list unchanged.\nUse `delete_first/2` to delete just the first entry in case of\nduplicate keys.\n\n## Examples\n\n    iex> Keyword.delete([a: 1, b: 2], :a)\n    [b: 2]\n    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n    [b: 2]\n    iex> Keyword.delete([b: 2], :a)\n    [b: 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.delete_first(keywords, key) <response> Deletes the first entry in the keyword list under a specific `key`.\n\nIf the `key` does not exist, it returns the keyword list unchanged.\n\n## Examples\n\n    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n    [b: 2, a: 3]\n    iex> Keyword.delete_first([b: 2], :a)\n    [b: 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.drop(keywords, keys) <response> Drops the given `keys` from the keyword list.\n\nRemoves duplicate keys from the new keyword list.\n\n## Examples\n\n    iex> Keyword.drop([a: 1, a: 2], [:a])\n    []\n    iex> Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])\n    [a: 1, c: 3]\n    iex> Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])\n    [a: 1, c: 3, a: 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.equal?(left, right) <response> Checks if two keywords are equal.\n\nConsiders two keywords to be equal if they contain\nthe same keys and those keys contain the same values.\n\n## Examples\n\n    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n    true\n    iex> Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])\n    false\n    iex> Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])\n    true\n\nComparison between values is done with `===/3`,\nwhich means integers are not equivalent to floats:\n\n    iex> Keyword.equal?([a: 1.0], [a: 1])\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.fetch(keywords, key) <response> Fetches the value for a specific `key` and returns it in a tuple.\n\nIf the `key` does not exist, it returns `:error`.\n\n## Examples\n\n    iex> Keyword.fetch([a: 1], :a)\n    {:ok, 1}\n    iex> Keyword.fetch([a: 1], :b)\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.fetch!(keywords, key) <response> Fetches the value for specific `key`.\n\nIf the `key` does not exist, it raises a `KeyError`.\n\n## Examples\n\n    iex> Keyword.fetch!([a: 1], :a)\n    1\n    iex> Keyword.fetch!([a: 1], :b)\n    ** (KeyError) key :b not found in: [a: 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.filter(keywords, fun) <response> Returns a keyword list containing only the entries from `keywords`\nfor which the function `fun` returns a truthy value.\n\nSee also `reject/2` which discards all entries where the function\nreturns a truthy value.\n\n## Examples\n\n    iex> Keyword.filter([one: 1, two: 2, three: 3], fn {_key, val} -> rem(val, 2) == 1 end)\n    [one: 1, three: 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.from_keys(keys, value) <response> Builds a keyword from the given `keys` and the fixed `value`.\n\n## Examples\n\n    iex> Keyword.from_keys([:foo, :bar, :baz], :atom)\n    [foo: :atom, bar: :atom, baz: :atom]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.get(keywords, key, default \\\\ nil) <response> Gets the value under the given `key`.\n\nReturns the default value if `key` does not exist\n(`nil` if no default value is provided).\n\nIf duplicate entries exist, it returns the first one.\nUse `get_values/2` to retrieve all entries.\n\n## Examples\n\n    iex> Keyword.get([], :a)\n    nil\n    iex> Keyword.get([a: 1], :a)\n    1\n    iex> Keyword.get([a: 1], :b)\n    nil\n    iex> Keyword.get([a: 1], :b, 3)\n    3\n\nWith duplicate keys:\n\n    iex> Keyword.get([a: 1, a: 2], :a, 3)\n    1\n    iex> Keyword.get([a: 1, a: 2], :b, 3)\n    3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.get_and_update(keywords, key, fun) <response> Gets the value from `key` and updates it, all in one pass.\n\nThe `fun` argument receives the value of `key` (or `nil` if `key`\nis not present) and must return a two-element tuple: the current value\n(the retrieved value, which can be operated on before being returned)\nand the new value to be stored under `key`. The `fun` may also\nreturn `:pop`, implying the current value shall be removed from the\nkeyword list and returned.\n\nReturns a tuple that contains the current value returned by\n`fun` and a new keyword list with the updated value under `key`.\n\n## Examples\n\n    iex> Keyword.get_and_update([a: 1], :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, [a: \"new value!\"]}\n\n    iex> Keyword.get_and_update([a: 1], :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {nil, [b: \"new value!\", a: 1]}\n\n    iex> Keyword.get_and_update([a: 2], :a, fn number ->\n    ...>   {2 * number, 3 * number}\n    ...> end)\n    {4, [a: 6]}\n\n    iex> Keyword.get_and_update([a: 1], :a, fn _ -> :pop end)\n    {1, []}\n\n    iex> Keyword.get_and_update([a: 1], :b, fn _ -> :pop end)\n    {nil, [a: 1]}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.get_and_update!(keywords, key, fun) <response> Gets the value under `key` and updates it. Raises if there is no `key`.\n\nThe `fun` argument receives the value under `key` and must return a\ntwo-element tuple: the current value (the retrieved value, which can be\noperated on before being returned) and the new value to be stored under\n`key`.\n\nReturns a tuple that contains the current value returned by\n`fun` and a new keyword list with the updated value under `key`.\n\n## Examples\n\n    iex> Keyword.get_and_update!([a: 1], :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, [a: \"new value!\"]}\n\n    iex> Keyword.get_and_update!([a: 1], :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    ** (KeyError) key :b not found in: [a: 1]\n\n    iex> Keyword.get_and_update!([a: 1], :a, fn _ ->\n    ...>   :pop\n    ...> end)\n    {1, []}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.get_lazy(keywords, key, fun) <response> Gets the value under the given `key`.\n\nIf `key` does not exist, lazily evaluates `fun` and returns its result.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\nIf duplicate entries exist, it returns the first one.\nUse `get_values/2` to retrieve all entries.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.get_lazy(keyword, :a, fun)\n    1\n    iex> Keyword.get_lazy(keyword, :b, fun)\n    13"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.get_values(keywords, key) <response> Gets all values under a specific `key`.\n\n## Examples\n\n    iex> Keyword.get_values([], :a)\n    []\n    iex> Keyword.get_values([a: 1], :a)\n    [1]\n    iex> Keyword.get_values([a: 1, a: 2], :a)\n    [1, 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.has_key?(keywords, key) <response> Returns whether a given `key` exists in the given `keywords`.\n\n## Examples\n\n    iex> Keyword.has_key?([a: 1], :a)\n    true\n    iex> Keyword.has_key?([a: 1], :b)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.keys(keywords) <response> Returns all keys from the keyword list.\n\nKeeps duplicate keys in the resulting list of keys.\n\n## Examples\n\n    iex> Keyword.keys(a: 1, b: 2)\n    [:a, :b]\n\n    iex> Keyword.keys(a: 1, b: 2, a: 3)\n    [:a, :b, :a]\n\n    iex> Keyword.keys([{:a, 1}, {\"b\", 2}, {:c, 3}])\n    ** (ArgumentError) expected a keyword list, but an entry in the list is not a two-element tuple with an atom as its first element, got: {\"b\", 2}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.keyword?(term) <response> Returns `true` if `term` is a keyword list, otherwise `false`.\n\nWhen `term` is a list it is traversed to the end.\n\n## Examples\n\n    iex> Keyword.keyword?([])\n    true\n    iex> Keyword.keyword?(a: 1)\n    true\n    iex> Keyword.keyword?([{Foo, 1}])\n    true\n    iex> Keyword.keyword?([{}])\n    false\n    iex> Keyword.keyword?([:key])\n    false\n    iex> Keyword.keyword?(%{})\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.merge(keywords1, keywords2) <response> Merges two keyword lists into one.\n\nAdds all keys, including duplicate keys, given in `keywords2`\nto `keywords1`, overriding any existing ones.\n\nThere are no guarantees about the order of the keys in the returned keyword.\n\n## Examples\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n    [b: 2, a: 3, d: 4]\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])\n    [b: 2, a: 3, d: 4, a: 5]\n\n    iex> Keyword.merge([a: 1], [2, 3])\n    ** (ArgumentError) expected a keyword list as the second argument, got: [2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.merge(keywords1, keywords2, fun) <response> Merges two keyword lists into one.\n\nAdds all keys, including duplicate keys, given in `keywords2`\nto `keywords1`. Invokes the given function to solve conflicts.\n\nIf `keywords2` has duplicate keys, it invokes the given function\nfor each matching pair in `keywords1`.\n\nThere are no guarantees about the order of the keys in the returned keyword.\n\n## Examples\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4]\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4, a: 5]\n\n    iex> Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4, a: 8]\n\n    iex> Keyword.merge([a: 1, b: 2], [:a, :b], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    ** (ArgumentError) expected a keyword list as the second argument, got: [:a, :b]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.new() <response> Returns an empty keyword list, i.e. an empty list.\n\n## Examples\n\n    iex> Keyword.new()\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.new(pairs) <response> Creates a keyword list from an enumerable.\n\nRemoves duplicate entries and the last one prevails.\nUnlike `Enum.into(enumerable, [])`, `Keyword.new(enumerable)`\nguarantees the keys are unique.\n\n## Examples\n\n    iex> Keyword.new([{:b, 1}, {:a, 2}])\n    [b: 1, a: 2]\n\n    iex> Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])\n    [a: 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.new(pairs, transform) <response> Creates a keyword list from an enumerable via the transformation function.\n\nRemoves duplicate entries and the last one prevails.\nUnlike `Enum.into(enumerable, [], fun)`,\n`Keyword.new(enumerable, fun)` guarantees the keys are unique.\n\n## Examples\n\n    iex> Keyword.new([:a, :b], fn x -> {x, x} end)\n    [a: :a, b: :b]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.pop(keywords, key, default \\\\ nil) <response> Returns the first value for `key` and removes all associated entries in the keyword list.\n\nIt returns a tuple where the first element is the first value for `key` and the\nsecond element is a keyword list with all entries associated with `key` removed.\nIf the `key` is not present in the keyword list, it returns `{default, keyword_list}`.\n\nIf you don't want to remove all the entries associated with `key` use `pop_first/3`\ninstead, which will remove only the first entry.\n\n## Examples\n\n    iex> Keyword.pop([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop([a: 1], :b)\n    {nil, [a: 1]}\n    iex> Keyword.pop([a: 1], :b, 3)\n    {3, [a: 1]}\n    iex> Keyword.pop([a: 1, a: 2], :a)\n    {1, []}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.pop!(keywords, key) <response> Returns the first value for `key` and removes all associated entries in the keyword list,\nraising if `key` is not present.\n\nThis function behaves like `pop/3`, but raises in case the `key` is not present in the\ngiven `keywords`.\n\n## Examples\n\n    iex> Keyword.pop!([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop!([a: 1, a: 2], :a)\n    {1, []}\n    iex> Keyword.pop!([a: 1], :b)\n    ** (KeyError) key :b not found in: [a: 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.pop_first(keywords, key, default \\\\ nil) <response> Returns and removes the first value associated with `key` in the keyword list.\n\nKeeps duplicate keys in the resulting keyword list.\n\n## Examples\n\n    iex> Keyword.pop_first([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop_first([a: 1], :b)\n    {nil, [a: 1]}\n    iex> Keyword.pop_first([a: 1], :b, 3)\n    {3, [a: 1]}\n    iex> Keyword.pop_first([a: 1, a: 2], :a)\n    {1, [a: 2]}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.pop_lazy(keywords, key, fun) <response> Lazily returns and removes all values associated with `key` in the keyword list.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\nRemoves all duplicate keys. See `pop_first/3` for removing only the first entry.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.pop_lazy(keyword, :a, fun)\n    {1, []}\n    iex> Keyword.pop_lazy(keyword, :b, fun)\n    {13, [a: 1]}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.pop_values(keywords, key) <response> Returns all values for `key` and removes all associated entries in the keyword list.\n\nIt returns a tuple where the first element is a list of values for `key` and the\nsecond element is a keyword list with all entries associated with `key` removed.\nIf the `key` is not present in the keyword list, it returns `{[], keyword_list}`.\n\nIf you don't want to remove all the entries associated with `key` use `pop_first/3`\ninstead, which will remove only the first entry.\n\n## Examples\n\n    iex> Keyword.pop_values([a: 1], :a)\n    {[1], []}\n    iex> Keyword.pop_values([a: 1], :b)\n    {[], [a: 1]}\n    iex> Keyword.pop_values([a: 1, a: 2], :a)\n    {[1, 2], []}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.put(keywords, key, value) <response> Puts the given `value` under the specified `key`.\n\nIf a value under `key` already exists, it overrides the value\nand removes all duplicate entries.\n\n## Examples\n\n    iex> Keyword.put([a: 1], :b, 2)\n    [b: 2, a: 1]\n    iex> Keyword.put([a: 1, b: 2], :a, 3)\n    [a: 3, b: 2]\n    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n    [a: 3, b: 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.put_new(keywords, key, value) <response> Puts the given `value` under `key`, unless the entry `key` already exists.\n\n## Examples\n\n    iex> Keyword.put_new([a: 1], :b, 2)\n    [b: 2, a: 1]\n    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n    [a: 1, b: 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.put_new_lazy(keywords, key, fun) <response> Evaluates `fun` and puts the result under `key`\nin keyword list unless `key` is already present.\n\nThis is useful if the value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.put_new_lazy(keyword, :a, fun)\n    [a: 1]\n    iex> Keyword.put_new_lazy(keyword, :b, fun)\n    [b: 13, a: 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.reject(keywords, fun) <response> Returns a keyword list excluding the entries from `keywords`\nfor which the function `fun` returns a truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> Keyword.reject([one: 1, two: 2, three: 3], fn {_key, val} -> rem(val, 2) == 1 end)\n    [two: 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.replace(keywords, key, value) <response> Puts a value under `key` only if the `key` already exists in `keywords`.\n\nIn case a key exists multiple times in the keyword list,\nit removes later occurrences.\n\n## Examples\n\n    iex> Keyword.replace([a: 1, b: 2, a: 4], :a, 3)\n    [a: 3, b: 2]\n\n    iex> Keyword.replace([a: 1], :b, 2)\n    [a: 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.replace!(keywords, key, value) <response> Puts a value under `key` only if the `key` already exists in `keywords`.\n\nIf `key` is not present in `keywords`, it raises a `KeyError`.\n\n## Examples\n\n    iex> Keyword.replace!([a: 1, b: 2, a: 3], :a, :new)\n    [a: :new, b: 2]\n    iex> Keyword.replace!([a: 1, b: 2, c: 3, b: 4], :b, :new)\n    [a: 1, b: :new, c: 3]\n\n    iex> Keyword.replace!([a: 1], :b, 2)\n    ** (KeyError) key :b not found in: [a: 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.replace_lazy(keywords, key, fun) <response> Replaces the value under `key` using the given function only if\n`key` already exists in `keywords`.\n\nIn comparison to `replace/3`, this can be useful when it's expensive to calculate the value.\n\nIf `key` does not exist, the original keyword list is returned unchanged.\n\n## Examples\n\n    iex> Keyword.replace_lazy([a: 1, b: 2], :a, fn v -> v * 4 end)\n    [a: 4, b: 2]\n\n    iex> Keyword.replace_lazy([a: 2, b: 2, a: 1], :a, fn v -> v * 4 end)\n    [a: 8, b: 2]\n\n    iex> Keyword.replace_lazy([a: 1, b: 2], :c, fn v -> v * 4 end)\n    [a: 1, b: 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.split(keywords, keys) <response> Takes all entries corresponding to the given `keys` and extracts them into a\nseparate keyword list.\n\nReturns a tuple with the new list and the old list with removed keys.\n\nIgnores keys for which there are no entries in the keyword list.\n\nEntries with duplicate keys end up in the same keyword list.\n\n## Examples\n\n    iex> Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])\n    {[a: 1, c: 3], [b: 2]}\n    iex> Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])\n    {[a: 1, c: 3, a: 4], [b: 2]}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.take(keywords, keys) <response> Takes all entries corresponding to the given `keys` and returns them as a new\nkeyword list.\n\nPreserves duplicate keys in the new keyword list.\n\n## Examples\n\n    iex> Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])\n    [a: 1, c: 3]\n    iex> Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])\n    [a: 1, c: 3, a: 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.to_list(keywords) <response> Returns the keyword list itself.\n\n## Examples\n\n    iex> Keyword.to_list(a: 1)\n    [a: 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.update(keywords, key, default, fun) <response> Updates the value under `key` in `keywords` using the given function.\n\nIf the `key` does not exist, it inserts the given `default` value.\nDoes not pass the `default` value through the update function.\n\nRemoves all duplicate keys and only updates the first one.\n\n## Examples\n\n    iex> Keyword.update([a: 1], :a, 13, fn existing_value -> existing_value * 2 end)\n    [a: 2]\n\n    iex> Keyword.update([a: 1, a: 2], :a, 13, fn existing_value -> existing_value * 2 end)\n    [a: 2]\n\n    iex> Keyword.update([a: 1], :b, 11, fn existing_value -> existing_value * 2 end)\n    [a: 1, b: 11]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.update!(keywords, key, fun) <response> Updates the value under `key` using the given function.\n\nRaises `KeyError` if the `key` does not exist.\n\nRemoves all duplicate keys and only updates the first one.\n\n## Examples\n\n    iex> Keyword.update!([a: 1, b: 2, a: 3], :a, &(&1 * 2))\n    [a: 2, b: 2]\n    iex> Keyword.update!([a: 1, b: 2, c: 3], :b, &(&1 * 2))\n    [a: 1, b: 4, c: 3]\n\n    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n    ** (KeyError) key :b not found in: [a: 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.validate(keyword, values) <response> Ensures the given `keyword` has only the keys given in `values`.\n\nThe second argument must be a list of atoms, specifying\na given key, or tuples specifying a key and a default value.\n\nIf the keyword list has only the given keys, it returns\n`{:ok, keyword}` with default values applied. Otherwise it\nreturns `{:error, invalid_keys}` with invalid keys.\n\nSee also: `validate!/2`.\n\n## Examples\n\n    iex> {:ok, result} = Keyword.validate([], [one: 1, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 2]\n\n    iex> {:ok, result} = Keyword.validate([two: 3], [one: 1, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 3]\n\nIf atoms are given, they are supported as keys but do not\nprovide a default value:\n\n    iex> {:ok, result} = Keyword.validate([], [:one, two: 2])\n    iex> Enum.sort(result)\n    [two: 2]\n\n    iex> {:ok, result} = Keyword.validate([one: 1], [:one, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 2]\n\nPassing unknown keys returns an error:\n\n    iex> Keyword.validate([three: 3, four: 4], [one: 1, two: 2])\n    {:error, [:four, :three]}\n\nPassing the same key multiple times also errors:\n\n    iex> Keyword.validate([one: 1, two: 2, one: 1], [:one, :two])\n    {:error, [:one]}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.validate!(keyword, values) <response> Similar to `validate/2` but returns the keyword or raises an error.\n\n## Examples\n\n    iex> Keyword.validate!([], [one: 1, two: 2]) |> Enum.sort()\n    [one: 1, two: 2]\n    iex> Keyword.validate!([two: 3], [one: 1, two: 2]) |> Enum.sort()\n    [one: 1, two: 3]\n\nIf atoms are given, they are supported as keys but do not\nprovide a default value:\n\n    iex> Keyword.validate!([], [:one, two: 2]) |> Enum.sort()\n    [two: 2]\n    iex> Keyword.validate!([one: 1], [:one, two: 2]) |> Enum.sort()\n    [one: 1, two: 2]\n\nPassing unknown keys raises an error:\n\n    iex> Keyword.validate!([three: 3], [one: 1, two: 2])\n    ** (ArgumentError) unknown keys [:three] in [three: 3], the allowed keys are: [:one, :two]\n\nPassing the same key multiple times also errors:\n\n    iex> Keyword.validate!([one: 1, two: 2, one: 1], [:one, :two])\n    ** (ArgumentError) duplicate keys [:one] in [one: 1, two: 2, one: 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.values(keywords) <response> Returns all values from the keyword list.\n\nKeeps values from duplicate keys in the resulting list of values.\n\n## Examples\n\n    iex> Keyword.values(a: 1, b: 2)\n    [1, 2]\n    iex> Keyword.values(a: 1, b: 2, a: 3)\n    [1, 2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.Elixir.Keyword <response> A keyword list is a list that consists exclusively of two-element tuples.\n\nThe first element of these tuples is known as the *key*, and it must be an atom.\nThe second element, known as the *value*, can be any term.\n\nKeywords are mostly used to work with optional values."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.Elixir.Keyword <response> Examples\n\nFor example, the following is a keyword list:\n\n    [{:exit_on_close, true}, {:active, :once}, {:packet_size, 1024}]\n\nElixir provides a special and more concise syntax for keyword lists:\n\n    [exit_on_close: true, active: :once, packet_size: 1024]\n\nThe two syntaxes return the exact same value.\n\nA *key* can be any atom, consisting of Unicode letters, numbers,\nan underscore or the `@` sign. If the *key* should have any other\ncharacters, such as spaces, you can wrap it in quotes:\n\n    iex> [\"exit on close\": true]\n    [\"exit on close\": true]\n\nWrapping an atom in quotes does not make it a string. Keyword list\n*keys* are always atoms. Quotes should only be used when necessary\nor Elixir will issue a warning."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.Elixir.Keyword <response> Duplicate keys and ordering\n\nA keyword may have duplicate keys so it is not strictly a key-value\ndata type. However most of the functions in this module work on a\nkey-value structure and behave similar to the functions you would\nfind in the `Map` module. For example, `Keyword.get/3` will get the first\nentry matching the given key, regardless if duplicate entries exist.\nSimilarly, `Keyword.put/3` and `Keyword.delete/2` ensure all duplicate\nentries for a given key are removed when invoked. Note, however, that\nkeyword list operations need to traverse the whole list in order to find\nkeys, so these operations are slower than their map counterparts.\n\nA handful of functions exist to handle duplicate keys, for example,\n`get_values/2` returns all values for a given key and `delete_first/2`\ndeletes just the first entry of the existing ones.\n\nEven though lists preserve the existing order, the functions in\n`Keyword` do not guarantee any ordering. For example, if you invoke\n`Keyword.put(opts, new_key, new_value)`, there is no guarantee for\nwhere `new_key` will be added to (the front, the end or anywhere else).\n\nGiven ordering is not guaranteed, it is not recommended to pattern\nmatch on keyword lists either. For example, a function such as:\n\n    def my_function([some_key: value, another_key: another_value])\n\nwill match\n\n    my_function([some_key: :foo, another_key: :bar])\n\nbut it won't match\n\n    my_function([another_key: :bar, some_key: :foo])\n\nMost of the functions in this module work in linear time. This means\nthat the time it takes to perform an operation grows at the same\nrate as the length of the list."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Keyword.Elixir.Keyword <response> Call syntax\n\nWhen keyword lists are passed as the last argument to a function,\nthe square brackets around the keyword list can be omitted. For\nexample, the keyword list syntax:\n\n    String.split(\"1-0\", \"-\", [trim: true, parts: 2])\n\ncan be written without the enclosing brackets whenever it is the last\nargument of a function call:\n\n    String.split(\"1-0\", \"-\", trim: true, parts: 2)\n\nSince tuples, lists and maps are treated similarly to function\narguments in Elixir syntax, this property is also available to them:\n\n    iex> {1, 2, foo: :bar}\n    {1, 2, [{:foo, :bar}]}\n\n    iex> [1, 2, foo: :bar]\n    [1, 2, {:foo, :bar}]\n\n    iex> %{1 => 2, foo: :bar}\n    %{1 => 2, :foo => :bar}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.Chars.BitString.to_charlist(term) <response> Returns the given binary `term` converted to a charlist."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.Chars.to_charlist(term) <response> Converts `term` to a charlist."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.Chars.Elixir.List.Chars <response> The `List.Chars` protocol is responsible for\nconverting a structure to a charlist (only if applicable).\n\nThe only function that must be implemented is\n`to_charlist/1` which does the conversion.\n\nThe `to_charlist/1` function automatically imported\nby `Kernel` invokes this protocol."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.ascii_printable?(list, limit \\\\ :infinity) <response> Checks if `list` is a charlist made only of printable ASCII characters.\n\nTakes an optional `limit` as a second argument. `ascii_printable?/2` only\nchecks the printability of the list up to the `limit`.\n\nA printable charlist in Elixir contains only the printable characters in the\nstandard seven-bit ASCII character encoding, which are characters ranging from\n32 to 126 in decimal notation, plus the following control characters:\n\n  * `?\\a` - Bell\n  * `?\\b` - Backspace\n  * `?\\t` - Horizontal tab\n  * `?\\n` - Line feed\n  * `?\\v` - Vertical tab\n  * `?\\f` - Form feed\n  * `?\\r` - Carriage return\n  * `?\\e` - Escape\n\nFor more information read the [Character groups](https://en.wikipedia.org/wiki/ASCII#Character_groups)\nsection in the Wikipedia article of the [ASCII](https://en.wikipedia.org/wiki/ASCII) standard.\n\n## Examples\n\n    iex> List.ascii_printable?('abc')\n    true\n\n    iex> List.ascii_printable?('abc' ++ [0])\n    false\n\n    iex> List.ascii_printable?('abc' ++ [0], 2)\n    true\n\nImproper lists are not printable, even if made only of ASCII characters:\n\n    iex> List.ascii_printable?('abc' ++ ?d)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.delete(list, element) <response> Deletes the given `element` from the `list`. Returns a new list without\nthe element.\n\nIf the `element` occurs more than once in the `list`, just\nthe first occurrence is removed.\n\n## Examples\n\n    iex> List.delete([:a, :b, :c], :a)\n    [:b, :c]\n\n    iex> List.delete([:a, :b, :c], :d)\n    [:a, :b, :c]\n\n    iex> List.delete([:a, :b, :b, :c], :b)\n    [:a, :b, :c]\n\n    iex> List.delete([], :b)\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.delete_at(list, index) <response> Produces a new list by removing the value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.delete_at([1, 2, 3], 0)\n    [2, 3]\n\n    iex> List.delete_at([1, 2, 3], 10)\n    [1, 2, 3]\n\n    iex> List.delete_at([1, 2, 3], -1)\n    [1, 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.duplicate(elem, n) <response> Duplicates the given element `n` times in a list.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty list is returned.\n\n## Examples\n\n    iex> List.duplicate(\"hello\", 0)\n    []\n\n    iex> List.duplicate(\"hi\", 1)\n    [\"hi\"]\n\n    iex> List.duplicate(\"bye\", 2)\n    [\"bye\", \"bye\"]\n\n    iex> List.duplicate([1, 2], 3)\n    [[1, 2], [1, 2], [1, 2]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.first(list, default \\\\ nil) <response> Returns the first element in `list` or `default` if `list` is empty.\n\n`first/2` has been introduced in Elixir v1.12.0, while `first/1` has been available since v1.0.0.\n\n## Examples\n\n    iex> List.first([])\n    nil\n\n    iex> List.first([], 1)\n    1\n\n    iex> List.first([1])\n    1\n\n    iex> List.first([1, 2, 3])\n    1"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.flatten(list) <response> Flattens the given `list` of nested lists.\n\nEmpty list elements are discarded.\n\n## Examples\n\n    iex> List.flatten([1, [[2], 3]])\n    [1, 2, 3]\n\n    iex> List.flatten([[], [[], []]])\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.flatten(list, tail) <response> Flattens the given `list` of nested lists.\nThe list `tail` will be added at the end of\nthe flattened list.\n\nEmpty list elements from `list` are discarded,\nbut not the ones from `tail`.\n\n## Examples\n\n    iex> List.flatten([1, [[2], 3]], [4, 5])\n    [1, 2, 3, 4, 5]\n\n    iex> List.flatten([1, [], 2], [3, [], 4])\n    [1, 2, 3, [], 4]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.foldl(list, acc, fun) <response> Folds (reduces) the given list from the left with\na function. Requires an accumulator, which can be any value.\n\n## Examples\n\n    iex> List.foldl([5, 5], 10, fn x, acc -> x + acc end)\n    20\n\n    iex> List.foldl([1, 2, 3, 4], 0, fn x, acc -> x - acc end)\n    2\n\n    iex> List.foldl([1, 2, 3], {0, 0}, fn x, {a1, a2} -> {a1 + x, a2 - x} end)\n    {6, -6}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.foldr(list, acc, fun) <response> Folds (reduces) the given list from the right with\na function. Requires an accumulator, which can be any value.\n\n## Examples\n\n    iex> List.foldr([1, 2, 3, 4], 0, fn x, acc -> x - acc end)\n    -2\n\n    iex> List.foldr([1, 2, 3, 4], %{sum: 0, product: 1}, fn x, %{sum: a1, product: a2} -> %{sum: a1 + x, product: a2 * x} end)\n    %{product: 24, sum: 10}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.improper?(list) <response> Returns `true` if `list` is an improper list. Otherwise returns `false`.\n\n## Examples\n\n    iex> List.improper?([1, 2 | 3])\n    true\n\n    iex> List.improper?([1, 2, 3])\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.insert_at(list, index, value) <response> Returns a list with `value` inserted at the specified `index`.\n\nNote that `index` is capped at the list length. Negative indices\nindicate an offset from the end of the `list`.\n\n## Examples\n\n    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n    [1, 2, 0, 3, 4]\n\n    iex> List.insert_at([1, 2, 3], 10, 0)\n    [1, 2, 3, 0]\n\n    iex> List.insert_at([1, 2, 3], -1, 0)\n    [1, 2, 3, 0]\n\n    iex> List.insert_at([1, 2, 3], -10, 0)\n    [0, 1, 2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.keydelete(list, key, position) <response> Receives a `list` of tuples and deletes the first tuple\nwhere the element at `position` matches the\ngiven `key`. Returns the new list.\n\n## Examples\n\n    iex> List.keydelete([a: 1, b: 2], :a, 0)\n    [b: 2]\n\n    iex> List.keydelete([a: 1, b: 2], 2, 1)\n    [a: 1]\n\n    iex> List.keydelete([a: 1, b: 2], :c, 0)\n    [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keydelete([{22, \"SSH\"}, {80, \"HTTP\"}], 80, 0)\n    [{22, \"SSH\"}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.keyfind(list, key, position, default \\\\ nil) <response> Receives a list of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`.\n\nIf no matching tuple is found, `default` is returned.\n\n## Examples\n\n    iex> List.keyfind([a: 1, b: 2], :a, 0)\n    {:a, 1}\n\n    iex> List.keyfind([a: 1, b: 2], 2, 1)\n    {:b, 2}\n\n    iex> List.keyfind([a: 1, b: 2], :c, 0)\n    nil\n\nThis function works for any list of tuples:\n\n    iex> List.keyfind([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    {22, \"SSH\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.keyfind!(list, key, position) <response> Receives a list of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`.\n\nIf no matching tuple is found, an error is raised.\n\n## Examples\n\n    iex> List.keyfind!([a: 1, b: 2], :a, 0)\n    {:a, 1}\n\n    iex> List.keyfind!([a: 1, b: 2], 2, 1)\n    {:b, 2}\n\n    iex> List.keyfind!([a: 1, b: 2], :c, 0)\n    ** (KeyError) key :c at position 0 not found in: [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keyfind!([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    {22, \"SSH\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.keymember?(list, key, position) <response> Receives a list of tuples and returns `true` if there is\na tuple where the element at `position` in the tuple matches\nthe given `key`.\n\n## Examples\n\n    iex> List.keymember?([a: 1, b: 2], :a, 0)\n    true\n\n    iex> List.keymember?([a: 1, b: 2], 2, 1)\n    true\n\n    iex> List.keymember?([a: 1, b: 2], :c, 0)\n    false\n\nThis function works for any list of tuples:\n\n    iex> List.keymember?([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.keyreplace(list, key, position, new_tuple) <response> Receives a list of tuples and if the identified element by `key` at `position`\nexists, it is replaced with `new_tuple`.\n\n## Examples\n\n    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n    [a: 3, b: 2]\n\n    iex> List.keyreplace([a: 1, b: 2], :a, 1, {:a, 3})\n    [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keyreplace([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0, {22, \"Secure Shell\"})\n    [{22, \"Secure Shell\"}, {80, \"HTTP\"}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.keysort(list, position, sorter \\\\ :asc) <response> Receives a list of tuples and sorts the elements\nat `position` of the tuples.\n\nThe sort is stable.\n\nA `sorter` argument is available since Elixir v1.14.0. Similar to\n`Enum.sort/2`, the sorter can be an anonymous function, the atoms\n`:asc` or `:desc`, or module that implements a compare function.\n\n## Examples\n\n    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n    [b: 1, c: 3, a: 5]\n\n    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n    [a: 5, b: 3, c: 1]\n\nTo sort in descending order:\n\n    iex> List.keysort([a: 5, c: 1, b: 3], 0, :desc)\n    [c: 1, b: 3, a: 5]\n\nAs in `Enum.sort/2`, avoid using the default sorting function to sort\nstructs, as by default it performs structural comparison instead of a\nsemantic one. In such cases, you shall pass a sorting function as third\nelement or any module that implements a `compare/2` function. For example,\nif you have tuples with user names and their birthday, and you want to\nsort on their birthday, in both ascending and descending order, you should\ndo:\n\n    iex> users = [\n    ...>   {\"Ellis\", ~D[1943-05-11]},\n    ...>   {\"Lovelace\", ~D[1815-12-10]},\n    ...>   {\"Turing\", ~D[1912-06-23]}\n    ...> ]\n    iex> List.keysort(users, 1, Date)\n    [\n      {\"Lovelace\", ~D[1815-12-10]},\n      {\"Turing\", ~D[1912-06-23]},\n      {\"Ellis\", ~D[1943-05-11]}\n    ]\n    iex> List.keysort(users, 1, {:desc, Date})\n    [\n      {\"Ellis\", ~D[1943-05-11]},\n      {\"Turing\", ~D[1912-06-23]},\n      {\"Lovelace\", ~D[1815-12-10]}\n    ]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.keystore(list, key, position, new_tuple) <response> Receives a `list` of tuples and replaces the element\nidentified by `key` at `position` with `new_tuple`.\n\nIf the element does not exist, it is added to the end of the `list`.\n\n## Examples\n\n    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n    [a: 3, b: 2]\n\n    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n    [a: 1, b: 2, c: 3]\n\nThis function works for any list of tuples:\n\n    iex> List.keystore([{22, \"SSH\"}], 80, 0, {80, \"HTTP\"})\n    [{22, \"SSH\"}, {80, \"HTTP\"}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.keytake(list, key, position) <response> Receives a `list` of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`, as well as the `list` without found tuple.\n\nIf such a tuple is not found, `nil` will be returned.\n\n## Examples\n\n    iex> List.keytake([a: 1, b: 2], :a, 0)\n    {{:a, 1}, [b: 2]}\n\n    iex> List.keytake([a: 1, b: 2], 2, 1)\n    {{:b, 2}, [a: 1]}\n\n    iex> List.keytake([a: 1, b: 2], :c, 0)\n    nil\n\nThis function works for any list of tuples:\n\n    iex> List.keytake([{22, \"SSH\"}, {80, \"HTTP\"}], 80, 0)\n    {{80, \"HTTP\"}, [{22, \"SSH\"}]}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.last(list, default \\\\ nil) <response> Returns the last element in `list` or `default` if `list` is empty.\n\n`last/2` has been introduced in Elixir v1.12.0, while `last/1` has been available since v1.0.0.\n\n## Examples\n\n    iex> List.last([])\n    nil\n\n    iex> List.last([], 1)\n    1\n\n    iex> List.last([1])\n    1\n\n    iex> List.last([1, 2, 3])\n    3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.myers_difference(list1, list2) <response> Returns a keyword list that represents an *edit script*.\n\nThe algorithm is outlined in the\n\"An O(ND) Difference Algorithm and Its Variations\" paper by E. Myers.\n\nAn *edit script* is a keyword list. Each key describes the \"editing action\" to\ntake in order to bring `list1` closer to being equal to `list2`; a key can be\n`:eq`, `:ins`, or `:del`. Each value is a sublist of either `list1` or `list2`\nthat should be inserted (if the corresponding key `:ins`), deleted (if the\ncorresponding key is `:del`), or left alone (if the corresponding key is\n`:eq`) in `list1` in order to be closer to `list2`.\n\nSee `myers_difference/3` if you want to handle nesting in the diff scripts.\n\n## Examples\n\n    iex> List.myers_difference([1, 4, 2, 3], [1, 2, 3, 4])\n    [eq: [1], del: [4], eq: [2, 3], ins: [4]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.myers_difference(list1, list2, diff_script) <response> Returns a keyword list that represents an *edit script* with nested diffs.\n\nThis is an extension of `myers_difference/2` where a `diff_script` function\ncan be given in case it is desired to compute nested differences. The function\nmay return a list with the inner edit script or `nil` in case there is no\nsuch script. The returned inner edit script will be under the `:diff` key.\n\n## Examples\n\n    iex> List.myers_difference([\"a\", \"db\", \"c\"], [\"a\", \"bc\"], &String.myers_difference/2)\n    [eq: [\"a\"], diff: [del: \"d\", eq: \"b\", ins: \"c\"], del: [\"c\"]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.pop_at(list, index, default \\\\ nil) <response> Returns and removes the value at the specified `index` in the `list`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.pop_at([1, 2, 3], 0)\n    {1, [2, 3]}\n    iex> List.pop_at([1, 2, 3], 5)\n    {nil, [1, 2, 3]}\n    iex> List.pop_at([1, 2, 3], 5, 10)\n    {10, [1, 2, 3]}\n    iex> List.pop_at([1, 2, 3], -1)\n    {3, [1, 2]}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.replace_at(list, index, value) <response> Returns a list with a replaced value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.replace_at([1, 2, 3], 0, 0)\n    [0, 2, 3]\n\n    iex> List.replace_at([1, 2, 3], 10, 0)\n    [1, 2, 3]\n\n    iex> List.replace_at([1, 2, 3], -1, 0)\n    [1, 2, 0]\n\n    iex> List.replace_at([1, 2, 3], -10, 0)\n    [1, 2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.starts_with?(list, prefix) <response> Returns `true` if `list` starts with the given `prefix` list; otherwise returns `false`.\n\nIf `prefix` is an empty list, it returns `true`.\n\n### Examples\n\n    iex> List.starts_with?([1, 2, 3], [1, 2])\n    true\n\n    iex> List.starts_with?([1, 2], [1, 2, 3])\n    false\n\n    iex> List.starts_with?([:alpha], [])\n    true\n\n    iex> List.starts_with?([], [:alpha])\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.to_atom(charlist) <response> Converts a charlist to an atom.\n\nElixir supports conversions from charlists which contains any Unicode\ncode point.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_atom('Elixir')\n    :Elixir\n\n    iex> List.to_atom('ð¢ Elixir')\n    :\"ð¢ Elixir\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.to_charlist(list) <response> Converts a list of integers representing Unicode code points, lists or\nstrings into a charlist.\n\nNote that this function expects a list of integers representing\nUnicode code points. If you have a list of bytes, you must instead use\nthe [`:binary` module](`:binary`).\n\n## Examples\n\n    iex> List.to_charlist([0x00E6, 0x00DF])\n    'Ã¦Ã'\n\n    iex> List.to_charlist([0x0061, \"bc\"])\n    'abc'\n\n    iex> List.to_charlist([0x0064, \"ee\", ['p']])\n    'deep'"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.to_existing_atom(charlist) <response> Converts a charlist to an existing atom.\n\nElixir supports conversions from charlists which contains any Unicode\ncode point. Raises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `List.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.\n\n## Examples\n\n    iex> _ = :my_atom\n    iex> List.to_existing_atom('my_atom')\n    :my_atom\n\n    iex> _ = :\"ð¢ Elixir\"\n    iex> List.to_existing_atom('ð¢ Elixir')\n    :\"ð¢ Elixir\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.to_float(charlist) <response> Returns the float whose text representation is `charlist`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_float('2.2017764e+0')\n    2.2017764"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.to_integer(charlist) <response> Returns an integer whose text representation is `charlist`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_integer('123')\n    123"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.to_integer(charlist, base) <response> Returns an integer whose text representation is `charlist` in base `base`.\n\nInlined by the compiler.\n\nThe base needs to be between `2` and `36`.\n\n## Examples\n\n    iex> List.to_integer('3FF', 16)\n    1023"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.to_string(list) <response> Converts a list of integers representing code points, lists or\nstrings into a string.\n\nTo be converted to a string, a list must either be empty or only\ncontain the following elements:\n\n  * strings\n  * integers representing Unicode code points\n  * a list containing one of these three elements\n\nNote that this function expects a list of integers representing\nUnicode code points. If you have a list of bytes, you must instead use\nthe [`:binary` module](`:binary`).\n\n## Examples\n\n    iex> List.to_string([0x00E6, 0x00DF])\n    \"Ã¦Ã\"\n\n    iex> List.to_string([0x0061, \"bc\"])\n    \"abc\"\n\n    iex> List.to_string([0x0064, \"ee\", ['p']])\n    \"deep\"\n\n    iex> List.to_string([])\n    \"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.to_tuple(list) <response> Converts a list to a tuple.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_tuple([:share, [:elixir, 163]])\n    {:share, [:elixir, 163]}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.update_at(list, index, fun) <response> Returns a list with an updated value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n    [11, 2, 3]\n\n    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n    [1, 2, 3]\n\n    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n    [1, 2, 13]\n\n    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n    [1, 2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.wrap(term) <response> Wraps `term` in a list if this is not list.\n\nIf `term` is already a list, it returns the list.\nIf `term` is `nil`, it returns an empty list.\n\n## Examples\n\n    iex> List.wrap(\"hello\")\n    [\"hello\"]\n\n    iex> List.wrap([1, 2, 3])\n    [1, 2, 3]\n\n    iex> List.wrap(nil)\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.zip(list_of_lists) <response> Zips corresponding elements from each list in `list_of_lists`.\n\nThe zipping finishes as soon as any list terminates.\n\n## Examples\n\n    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n    [{1, 3, 5}, {2, 4, 6}]\n\n    iex> List.zip([[1, 2], [3], [5, 6]])\n    [{1, 3, 5}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.Elixir.List <response> Linked lists hold zero, one, or more elements in the chosen order.\n\nLists in Elixir are specified between square brackets:\n\n    iex> [1, \"two\", 3, :four]\n    [1, \"two\", 3, :four]\n\nTwo lists can be concatenated and subtracted using the\n`++/2` and `--/2` operators:\n\n    iex> [1, 2, 3] ++ [4, 5, 6]\n    [1, 2, 3, 4, 5, 6]\n    iex> [1, true, 2, false, 3, true] -- [true, false]\n    [1, 2, 3, true]\n\nAn element can be prepended to a list using `|`:\n\n    iex> new = 0\n    iex> list = [1, 2, 3]\n    iex> [new | list]\n    [0, 1, 2, 3]\n\nLists in Elixir are effectively linked lists, which means\nthey are internally represented in pairs containing the\nhead and the tail of a list:\n\n    iex> [head | tail] = [1, 2, 3]\n    iex> head\n    1\n    iex> tail\n    [2, 3]\n\nSimilarly, we could write the list `[1, 2, 3]` using only\nsuch pairs (called cons cells):\n\n    iex> [1 | [2 | [3 | []]]]\n    [1, 2, 3]\n\nSome lists, called improper lists, do not have an empty list as\nthe second element in the last cons cell:\n\n    iex> [1 | [2 | [3 | 4]]]\n    [1, 2, 3 | 4]\n\nAlthough improper lists are generally avoided, they are used in some\nspecial circumstances like iodata and chardata entities (see the `IO` module).\n\nDue to their cons cell based representation, prepending an element\nto a list is always fast (constant time), while appending becomes\nslower as the list grows in size (linear time):\n\n    iex> list = [1, 2, 3]\n    iex> [0 | list] # fast\n    [0, 1, 2, 3]\n    iex> list ++ [4] # slow\n    [1, 2, 3, 4]\n\nMost of the functions in this module work in linear time. This means that,\nthat the time it takes to perform an operation grows at the same rate as the\nlength of the list. For example `length/1` and `last/1` will run in linear\ntime because they need to iterate through every element of the list, but\n`first/1` will run in constant time because it only needs the first element.\n\nLists also implement the `Enumerable` protocol, so many functions to work with\nlists are found in the `Enum` module. Additionally, the following functions and\noperators for lists are found in `Kernel`:\n\n  * `++/2`\n  * `--/2`\n  * `hd/1`\n  * `tl/1`\n  * `in/2`\n  * `length/1`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.List.Elixir.List <response> Charlists\n\nIf a list is made of non-negative integers, where each integer represents a\nUnicode code point, the list can also be called a charlist. These integers\nmust:\n\n  * be within the range `0..0x10FFFF` (`0..1_114_111`);\n  * and be out of the range `0xD800..0xDFFF` (`55_296..57_343`), which is\n    reserved in Unicode for UTF-16 surrogate pairs.\n\nElixir uses single quotes to define charlists:\n\n    iex> 'hÃ©llo'\n    [104, 233, 108, 108, 111]\n\nIn particular, charlists will be printed back by default in single\nquotes if they contain only printable ASCII characters:\n\n    iex> 'abc'\n    'abc'\n\nEven though the representation changed, the raw data does remain a list of\nnumbers, which can be handled as such:\n\n    iex> inspect('abc', charlists: :as_list)\n    \"[97, 98, 99]\"\n    iex> Enum.map('abc', fn num -> 1000 + num end)\n    [1097, 1098, 1099]\n\nYou can use the `IEx.Helpers.i/1` helper to get a condensed rundown on\ncharlists in IEx when you encounter them, which shows you the type, description\nand also the raw representation in one single summary.\n\nThe rationale behind this behaviour is to better support\nErlang libraries which may return text as charlists\ninstead of Elixir strings. In Erlang, charlists are the default\nway of handling strings, while in Elixir it's binaries. One\nexample of such functions is `Application.loaded_applications/0`:\n\n    Application.loaded_applications()\n    #=>  [\n    #=>    {:stdlib, 'ERTS  CXC 138 10', '2.6'},\n    #=>    {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n    #=>    {:elixir, 'elixir', '1.0.0'},\n    #=>    {:kernel, 'ERTS  CXC 138 10', '4.1'},\n    #=>    {:logger, 'logger', '1.0.0'}\n    #=>  ]\n\nA list can be checked if it is made of only printable ASCII\ncharacters with `ascii_printable?/2`.\n\nImproper lists are never deemed as charlists."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.fetch_alias(map, atom) <response> Fetches the alias for the given atom.\n\nReturns `{:ok, alias}` if the alias exists, `:error`\notherwise.\n\n## Examples\n\n    iex> alias Foo.Bar, as: Baz\n    iex> Baz\n    Foo.Bar\n    iex> Macro.Env.fetch_alias(__ENV__, :Baz)\n    {:ok, Foo.Bar}\n    iex> Macro.Env.fetch_alias(__ENV__, :Unknown)\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.fetch_macro_alias(map, atom) <response> Fetches the macro alias for the given atom.\n\nReturns `{:ok, macro_alias}` if the alias exists, `:error`\notherwise.\n\nA macro alias is only used inside quoted expansion. See\n`fetch_alias/2` for a more general example."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.has_var?(env, var) <response> Checks if a variable belongs to the environment.\n\n## Examples\n\n    iex> x = 13\n    iex> x\n    13\n    iex> Macro.Env.has_var?(__ENV__, {:x, nil})\n    true\n    iex> Macro.Env.has_var?(__ENV__, {:unknown, nil})\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.in_guard?(env) <response> Returns whether the compilation environment is currently\ninside a guard."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.in_match?(env) <response> Returns whether the compilation environment is currently\ninside a match clause."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.location(env) <response> Returns a keyword list containing the file and line\ninformation as keys."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.lookup_import(map, pair) <response> Returns the modules from which the given `{name, arity}` was\nimported.\n\nIt returns a list of two element tuples in the shape of\n`{:function | :macro, module}`. The elements in the list\nare in no particular order and the order is not guaranteed.\n\n## Examples\n\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    []\n    iex> import Tuple, only: [duplicate: 2], warn: false\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    [{:function, Tuple}]\n    iex> import List, only: [duplicate: 2], warn: false\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    [{:function, List}, {:function, Tuple}]\n\n    iex> Macro.Env.lookup_import(__ENV__, {:def, 1})\n    [{:macro, Kernel}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.prepend_tracer(env, tracer) <response> Prepend a tracer to the list of tracers in the environment.\n\n## Examples\n\n    Macro.Env.prepend_tracer(__ENV__, MyCustomTracer)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.prune_compile_info(env) <response> Prunes compile information from the environment.\n\nThis happens when the environment is captured at compilation\ntime, for example, in the module body, and then used to\nevaluate code after the module has been defined."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.required?(map, mod) <response> Returns true if the given module has been required.\n\n## Examples\n\n    iex> Macro.Env.required?(__ENV__, Integer)\n    false\n    iex> require Integer\n    iex> Macro.Env.required?(__ENV__, Integer)\n    true\n\n    iex> Macro.Env.required?(__ENV__, Kernel)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.stacktrace(env) <response> Returns the environment stacktrace."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.to_match(env) <response> Returns a `Macro.Env` in the match context."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.vars(env) <response> Returns a list of variables in the current environment.\n\nEach variable is identified by a tuple of two elements,\nwhere the first element is the variable name as an atom\nand the second element is its context, which may be an\natom or an integer."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Env.Elixir.Macro.Env <response> A struct that holds compile time environment information.\n\nThe current environment can be accessed at any time as\n`__ENV__/0`. Inside macros, the caller environment can be\naccessed as `__CALLER__/0`.\n\nAn instance of `Macro.Env` must not be modified by hand. If you need to\ncreate a custom environment to pass to `Code.eval_quoted/3`, use the\nfollowing trick:\n\n    def make_custom_env do\n      import SomeModule, only: [some_function: 2]\n      alias A.B.C\n      __ENV__\n    end\n\nYou may then call `make_custom_env()` to get a struct with the desired\nimports and aliases included.\n\nIt contains the following fields:\n\n  * `context` - the context of the environment; it can be `nil`\n    (default context), `:guard` (inside a guard) or `:match` (inside a match)\n  * `context_modules` - a list of modules defined in the current context\n  * `file` - the current absolute file name as a binary\n  * `function` - a tuple as `{atom, integer}`, where the first\n    element is the function name and the second its arity; returns\n    `nil` if not inside a function\n  * `line` - the current line as an integer\n  * `module` - the current module name\n\nThe following fields are private to Elixir's macro expansion mechanism and\nmust not be accessed directly:\n\n  * `aliases`\n  * `functions`\n  * `macro_aliases`\n  * `macros`\n  * `lexical_tracker`\n  * `requires`\n  * `tracers`\n  * `versioned_vars`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.camelize(string) <response> Converts the given string to CamelCase format.\n\nThis function was designed to camelize language identifiers/tokens,\nthat's why it belongs to the `Macro` module. Do not use it as a general\nmechanism for camelizing strings as it does not support Unicode or\ncharacters that are not valid in Elixir identifiers.\n\n## Examples\n\n    iex> Macro.camelize(\"foo_bar\")\n    \"FooBar\"\n\n    iex> Macro.camelize(\"foo/bar\")\n    \"Foo.Bar\"\n\nIf uppercase characters are present, they are not modified in any way\nas a mechanism to preserve acronyms:\n\n    iex> Macro.camelize(\"API.V1\")\n    \"API.V1\"\n    iex> Macro.camelize(\"API_SPEC\")\n    \"API_SPEC\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.classify_atom(atom) <response> Classifies a runtime `atom` based on its possible AST placement.\n\nIt returns one of the following atoms:\n\n  * `:alias` - the atom represents an alias\n\n  * `:identifier` - the atom can be used as a variable or local function\n    call (as well as be an unquoted atom)\n\n  * `:unquoted` - the atom can be used in its unquoted form,\n    includes operators and atoms with `@` in them\n\n  * `:quoted` - all other atoms which can only be used in their quoted form\n\nMost operators are going to be `:unquoted`, such as `:+`, with\nsome exceptions returning `:quoted` due to ambiguity, such as\n`:\"::\"`. Use `operator?/2` to check if a given atom is an operator.\n\n## Examples\n\n    iex> Macro.classify_atom(:foo)\n    :identifier\n    iex> Macro.classify_atom(Foo)\n    :alias\n    iex> Macro.classify_atom(:foo@bar)\n    :unquoted\n    iex> Macro.classify_atom(:+)\n    :unquoted\n    iex> Macro.classify_atom(:Foo)\n    :unquoted\n    iex> Macro.classify_atom(:\"with spaces\")\n    :quoted"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.dbg(code, options, env) <response> Default backend for `Kernel.dbg/2`.\n\nThis function provides a default backend for `Kernel.dbg/2`. See the\n`Kernel.dbg/2` documentation for more information.\n\nThis function:\n\n  * prints information about the given `env`\n  * prints information about `code` and its returned value (using `opts` to inspect terms)\n  * returns the value returned by evaluating `code`\n\nYou can call this function directly to build `Kernel.dbg/2` backends that fall back\nto this function."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.decompose_call(ast) <response> Decomposes a local or remote call into its remote part (when provided),\nfunction name and argument list.\n\nReturns `:error` when an invalid call syntax is provided.\n\n## Examples\n\n    iex> Macro.decompose_call(quote(do: foo))\n    {:foo, []}\n\n    iex> Macro.decompose_call(quote(do: foo()))\n    {:foo, []}\n\n    iex> Macro.decompose_call(quote(do: foo(1, 2, 3)))\n    {:foo, [1, 2, 3]}\n\n    iex> Macro.decompose_call(quote(do: Elixir.M.foo(1, 2, 3)))\n    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n\n    iex> Macro.decompose_call(quote(do: 42))\n    :error\n\n    iex> Macro.decompose_call(quote(do: {:foo, [], []}))\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.escape(expr, opts \\\\ []) <response> Recursively escapes a value so it can be inserted into a syntax tree.\n\n## Examples\n\n    iex> Macro.escape(:foo)\n    :foo\n\n    iex> Macro.escape({:a, :b, :c})\n    {:{}, [], [:a, :b, :c]}\n\n    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n    1\n\n## Options\n\n  * `:unquote` - when true, this function leaves `unquote/1` and\n    `unquote_splicing/1` statements unescaped, effectively unquoting\n    the contents on escape. This option is useful only when escaping\n    ASTs which may have quoted fragments in them. Defaults to false.\n\n  * `:prune_metadata` - when true, removes metadata from escaped AST\n    nodes. Note this option changes the semantics of escaped code and\n    it should only be used when escaping ASTs. Defaults to false.\n\n    As an example, `ExUnit` stores the AST of every assertion, so when\n    an assertion fails we can show code snippets to users. Without this\n    option, each time the test module is compiled, we get a different\n    MD5 of the module bytecode, because the AST contains metadata,\n    such as counters, specific to the compilation environment. By pruning\n    the metadata, we ensure that the module is deterministic and reduce\n    the amount of data `ExUnit` needs to keep around. Only the minimal\n    amount of metadata is kept, such as `:line` and `:no_parens`.\n\n## Comparison to `quote/2`\n\nThe `escape/2` function is sometimes confused with `quote/2`,\nbecause the above examples behave the same with both. The key difference is\nbest illustrated when the value to escape is stored in a variable.\n\n    iex> Macro.escape({:a, :b, :c})\n    {:{}, [], [:a, :b, :c]}\n    iex> quote do: {:a, :b, :c}\n    {:{}, [], [:a, :b, :c]}\n\n    iex> value = {:a, :b, :c}\n    iex> Macro.escape(value)\n    {:{}, [], [:a, :b, :c]}\n\n    iex> quote do: value\n    {:value, [], __MODULE__}\n\n    iex> value = {:a, :b, :c}\n    iex> quote do: unquote(value)\n    {:a, :b, :c}\n\n`escape/2` is used to escape *values* (either directly passed or variable\nbound), while `quote/2` produces syntax trees for\nexpressions."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.expand(ast, env) <response> Receives an AST node and expands it until it can no longer\nbe expanded.\n\nNote this function does not traverse the AST, only the root\nnode is expanded.\n\nThis function uses `expand_once/2` under the hood. Check\nit out for more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.expand_literals(ast, env) <response> Expands all literals in `ast` with the given `env`.\n\nThis function is mostly used to remove compile-time dependencies\nfrom AST nodes. In such cases, the given environment is usually\nmanipulated to represent a function:\n\n    Macro.expand_literals(ast, %{env | function: {:my_code, 1}})\n\nAt the moment, the only expandable literal nodes in an AST are\naliases, so this function only expands aliases.\n\nHowever, be careful when removing compile-time dependencies between\nmodules. If you remove them but you still invoke the module at\ncompile-time, Elixir will be unable to properly recompile modules\nwhen they change."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.expand_literals(ast, acc, fun) <response> Expands all literals in `ast` with the given `acc` and `fun`.\n\n`fun` will be invoked with an expandable AST node and `acc` and\nmust return a new node with `acc`. This is a general version of\n`expand_literals/2` which supports a custom expansion function.\nPlease check `expand_literals/2` for use cases and pitfalls."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.expand_once(ast, env) <response> Receives an AST node and expands it once.\n\nThe following contents are expanded:\n\n  * Macros (local or remote)\n  * Aliases are expanded (if possible) and return atoms\n  * Compilation environment macros (`__CALLER__/0`, `__DIR__/0`, `__ENV__/0` and `__MODULE__/0`)\n  * Module attributes reader (`@foo`)\n\nIf the expression cannot be expanded, it returns the expression\nitself. This function does not traverse the AST, only the root\nnode is expanded.\n\n`expand_once/2` performs the expansion just once. Check `expand/2`\nto perform expansion until the node can no longer be expanded.\n\n## Examples\n\nIn the example below, we have a macro that generates a module\nwith a function named `name_length` that returns the length\nof the module name. The value of this function will be calculated\nat compilation time and not at runtime.\n\nConsider the implementation below:\n\n    defmacro defmodule_with_length(name, do: block) do\n      length = length(Atom.to_charlist(name))\n\n      quote do\n        defmodule unquote(name) do\n          def name_length, do: unquote(length)\n          unquote(block)\n        end\n      end\n    end\n\nWhen invoked like this:\n\n    defmodule_with_length My.Module do\n      def other_function, do: ...\n    end\n\nThe compilation will fail because `My.Module` when quoted\nis not an atom, but a syntax tree as follows:\n\n    {:__aliases__, [], [:My, :Module]}\n\nThat said, we need to expand the aliases node above to an\natom, so we can retrieve its length. Expanding the node is\nnot straightforward because we also need to expand the\ncaller aliases. For example:\n\n    alias MyHelpers, as: My\n\n    defmodule_with_length My.Module do\n      def other_function, do: ...\n    end\n\nThe final module name will be `MyHelpers.Module` and not\n`My.Module`. With `Macro.expand/2`, such aliases are taken\ninto consideration. Local and remote macros are also\nexpanded. We could rewrite our macro above to use this\nfunction as:\n\n    defmacro defmodule_with_length(name, do: block) do\n      expanded = Macro.expand(name, __CALLER__)\n      length = length(Atom.to_charlist(expanded))\n\n      quote do\n        defmodule unquote(name) do\n          def name_length, do: unquote(length)\n          unquote(block)\n        end\n      end\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.generate_arguments(amount, context) <response> Generates AST nodes for a given number of required argument\nvariables using `Macro.var/2`.\n\nNote the arguments are not unique. If you later on want\nto access the same variables, you can invoke this function\nwith the same inputs. Use `generate_unique_arguments/2` to\ngenerate a unique arguments that can't be overridden.\n\n## Examples\n\n    iex> Macro.generate_arguments(2, __MODULE__)\n    [{:arg1, [], __MODULE__}, {:arg2, [], __MODULE__}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.generate_unique_arguments(amount, context) <response> Generates AST nodes for a given number of required argument\nvariables using `Macro.unique_var/2`.\n\n## Examples\n\n    iex> [var1, var2] = Macro.generate_unique_arguments(2, __MODULE__)\n    iex> {:arg1, [counter: c1], __MODULE__} = var1\n    iex> {:arg2, [counter: c2], __MODULE__} = var2\n    iex> is_integer(c1) and is_integer(c2)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.inspect_atom(source_format, atom) <response> Inspects `atom` according to different source formats.\n\nThe atom can be inspected according to the three different\nformats it appears in the AST: as a literal (`:literal`),\nas a key (`:key`), or as the function name of a remote call\n(`:remote_call`).\n\n## Examples\n\n### As a literal\n\nLiterals include regular atoms, quoted atoms, operators,\naliases, and the special `nil`, `true`, and `false` atoms.\n\n    iex> Macro.inspect_atom(:literal, nil)\n    \"nil\"\n    iex> Macro.inspect_atom(:literal, :foo)\n    \":foo\"\n    iex> Macro.inspect_atom(:literal, :<>)\n    \":<>\"\n    iex> Macro.inspect_atom(:literal, :Foo)\n    \":Foo\"\n    iex> Macro.inspect_atom(:literal, Foo.Bar)\n    \"Foo.Bar\"\n    iex> Macro.inspect_atom(:literal, :\"with spaces\")\n    \":\\\"with spaces\\\"\"\n\n### As a key\n\nInspect an atom as a key of a keyword list or a map.\n\n    iex> Macro.inspect_atom(:key, :foo)\n    \"foo:\"\n    iex> Macro.inspect_atom(:key, :<>)\n    \"<>:\"\n    iex> Macro.inspect_atom(:key, :Foo)\n    \"Foo:\"\n    iex> Macro.inspect_atom(:key, :\"with spaces\")\n    \"\\\"with spaces\\\":\"\n\n### As a remote call\n\nInspect an atom the function name of a remote call.\n\n    iex> Macro.inspect_atom(:remote_call, :foo)\n    \"foo\"\n    iex> Macro.inspect_atom(:remote_call, :<>)\n    \"<>\"\n    iex> Macro.inspect_atom(:remote_call, :Foo)\n    \"\\\"Foo\\\"\"\n    iex> Macro.inspect_atom(:remote_call, :\"with spaces\")\n    \"\\\"with spaces\\\"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.operator?(name, arity) <response> Returns `true` if the given name and arity is an operator.\n\n## Examples\n\n    iex> Macro.operator?(:not_an_operator, 3)\n    false\n    iex> Macro.operator?(:.., 0)\n    true\n    iex> Macro.operator?(:+, 1)\n    true\n    iex> Macro.operator?(:++, 2)\n    true\n    iex> Macro.operator?(:..//, 3)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.path(ast, fun) <response> Returns the path to the node in `ast` which `fun` returns true.\n\nThe path is a list, starting with the node in which `fun` returns\ntrue, followed by all of its parents.\n\nComputing the path can be an efficient operation when you want\nto find a particular node in the AST within its context and then\nassert something about it.\n\n## Examples\n\n    iex> Macro.path(quote(do: [1, 2, 3]), & &1 == 3)\n    [3, [1, 2, 3]]\n\n    iex> Macro.path(quote(do: Foo.bar(3)), & &1 == 3)\n    [3, quote(do: Foo.bar(3))]\n\n    iex> Macro.path(quote(do: %{foo: [bar: :baz]}), & &1 == :baz)\n    [\n      :baz,\n      {:bar, :baz},\n      [bar: :baz],\n      {:foo, [bar: :baz]},\n      {:%{}, [], [foo: [bar: :baz]]}\n    ]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.pipe(expr, call_args, position) <response> Pipes `expr` into the `call_args` at the given `position`.\n\nThis function can be used to implement `|>` like functionality. For example,\n`|>` itself is implemented as:\n\n    defmacro left |> right do\n      Macro.pipe(left, right, 0)\n    end\n\n`expr` is the AST of an expression. `call_args` must be the AST *of a call*,\notherwise this function will raise an error. As an example, consider the pipe\noperator `|>/2`, which uses this function to build pipelines.\n\nEven if the expression is piped into the AST, it doesn't necessarily mean that\nthe AST is valid. For example, you could pipe an argument to `div/2`, effectively\nturning it into a call to `div/3`, which is a function that doesn't exist by\ndefault. The code will raise unless a `div/3` function is locally defined."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.postwalk(ast, fun) <response> This function behaves like `prewalk/2`, but performs a depth-first,\npost-order traversal of quoted expressions."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.postwalk(ast, acc, fun) <response> This functions behaves like `prewalk/3`, but performs a depth-first,\npost-order traversal of quoted expressions using an accumulator."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.postwalker(ast) <response> Returns an enumerable that traverses the  `ast` in depth-first,\npost-order traversal.\n\n## Examples\n\n    iex> ast = quote do: foo(1, \"abc\")\n    iex> Enum.map(Macro.postwalker(ast), & &1)\n    [1, \"abc\", {:foo, [], [1, \"abc\"]}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.prewalk(ast, fun) <response> Performs a depth-first, pre-order traversal of quoted expressions.\n\nReturns a new AST where each node is the result of invoking `fun` on each\ncorresponding node of `ast`.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> new_ast = Macro.prewalk(ast, fn\n    ...>   {:+, meta, children} -> {:*, meta, children}\n    ...>   {:*, meta, children} -> {:+, meta, children}\n    ...>   other -> other\n    ...> end)\n    iex> {:*, _, [5, {:+, _, [3, 7]}]} = new_ast\n    iex> Code.eval_quoted(ast)\n    {26, []}\n    iex> Code.eval_quoted(new_ast)\n    {50, []}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.prewalk(ast, acc, fun) <response> Performs a depth-first, pre-order traversal of quoted expressions\nusing an accumulator.\n\nReturns a tuple where the first element is a new AST where each node is the\nresult of invoking `fun` on each corresponding node and the second one is the\nfinal accumulator.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> {new_ast, acc} = Macro.prewalk(ast, [], fn\n    ...>   {:+, meta, children}, acc -> {{:*, meta, children}, [:+ | acc]}\n    ...>   {:*, meta, children}, acc -> {{:+, meta, children}, [:* | acc]}\n    ...>   other, acc -> {other, acc}\n    ...> end)\n    iex> {{:*, _, [5, {:+, _, [3, 7]}]}, [:*, :+]} = {new_ast, acc}\n    iex> Code.eval_quoted(ast)\n    {26, []}\n    iex> Code.eval_quoted(new_ast)\n    {50, []}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.prewalker(ast) <response> Returns an enumerable that traverses the  `ast` in depth-first,\npre-order traversal.\n\n## Examples\n\n    iex> ast = quote do: foo(1, \"abc\")\n    iex> Enum.map(Macro.prewalker(ast), & &1)\n    [{:foo, [], [1, \"abc\"]}, 1, \"abc\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.quoted_literal?(term) <response> Returns `true` if the given quoted expression represents a quoted literal.\n\nAtoms and numbers are always literals. Binaries, lists, tuples,\nmaps, and structs are only literals if all of their terms are also literals.\n\n## Examples\n\n    iex> Macro.quoted_literal?(quote(do: \"foo\"))\n    true\n    iex> Macro.quoted_literal?(quote(do: {\"foo\", 1}))\n    true\n    iex> Macro.quoted_literal?(quote(do: {\"foo\", 1, :baz}))\n    true\n    iex> Macro.quoted_literal?(quote(do: %{foo: \"bar\"}))\n    true\n    iex> Macro.quoted_literal?(quote(do: %URI{path: \"/\"}))\n    true\n    iex> Macro.quoted_literal?(quote(do: URI.parse(\"/\")))\n    false\n    iex> Macro.quoted_literal?(quote(do: {foo, var}))\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.special_form?(name, arity) <response> Returns `true` if the given name and arity is a special form."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.struct!(module, env) <response> Expands the struct given by `module` in the given `env`.\n\nThis is useful when a struct needs to be expanded at\ncompilation time and the struct being expanded may or may\nnot have been compiled. This function is also capable of\nexpanding structs defined under the module being compiled.\n\nIt will raise `CompileError` if the struct is not available.\nFrom Elixir v1.12, calling this function also adds an export\ndependency on the given struct."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.to_string(tree) <response> Converts the given expression AST to a string.\n\nThis is a convenience function for converting AST into\na string, which discards all formatting of the original\ncode and wraps newlines around 98 characters. See\n`Code.quoted_to_algebra/2` as a lower level function\nwith more control around formatting.\n\n## Examples\n\n    iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))\n    \"foo.bar(1, 2, 3)\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.to_string(tree, fun) <response> Converts the given expression AST to a string.\n\nThe given `fun` is called for every node in the AST with two arguments: the\nAST of the node being printed and the string representation of that same\nnode. The return value of this function is used as the final string\nrepresentation for that AST node.\n\nThis function discards all formatting of the original code.\n\n## Examples\n\n    Macro.to_string(quote(do: 1 + 2), fn\n      1, _string -> \"one\"\n      2, _string -> \"two\"\n      _ast, string -> string\n    end)\n    #=> \"one + two\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.traverse(ast, acc, pre, post) <response> Performs a depth-first traversal of quoted expressions\nusing an accumulator.\n\nReturns a tuple where the first element is a new AST and the second one is\nthe final accumulator. The new AST is the result of invoking `pre` on each\nnode of `ast` during the pre-order phase and `post` during the post-order\nphase.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> {new_ast, acc} =\n    ...>  Macro.traverse(\n    ...>    ast,\n    ...>    [],\n    ...>    fn\n    ...>      {:+, meta, children}, acc -> {{:-, meta, children}, [:- | acc]}\n    ...>      {:*, meta, children}, acc -> {{:/, meta, children}, [:/ | acc]}\n    ...>      other, acc -> {other, acc}\n    ...>    end,\n    ...>    fn\n    ...>      {:-, meta, children}, acc -> {{:min, meta, children}, [:min | acc]}\n    ...>      {:/, meta, children}, acc -> {{:max, meta, children}, [:max | acc]}\n    ...>      other, acc -> {other, acc}\n    ...>    end\n    ...>  )\n    iex> {:min, _, [5, {:max, _, [3, 7]}]} = new_ast\n    iex> [:min, :max, :/, :-] = acc\n    iex> Code.eval_quoted(new_ast)\n    {5, []}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.underscore(atom_or_string) <response> Converts the given argument to a string with the underscore-slash format.\n\nThe argument must either be an atom or a string.\nIf an atom is given, it is assumed to be an Elixir module,\nso it is converted to a string and then processed.\n\nThis function was designed to format language identifiers/tokens with the underscore-slash format,\nthat's why it belongs to the `Macro` module. Do not use it as a general\nmechanism for underscoring strings as it does not support Unicode or\ncharacters that are not valid in Elixir identifiers.\n\n## Examples\n\n    iex> Macro.underscore(\"FooBar\")\n    \"foo_bar\"\n\n    iex> Macro.underscore(\"Foo.Bar\")\n    \"foo/bar\"\n\n    iex> Macro.underscore(Foo.Bar)\n    \"foo/bar\"\n\nIn general, `underscore` can be thought of as the reverse of\n`camelize`, however, in some cases formatting may be lost:\n\n    iex> Macro.underscore(\"SAPExample\")\n    \"sap_example\"\n\n    iex> Macro.camelize(\"sap_example\")\n    \"SapExample\"\n\n    iex> Macro.camelize(\"hello_10\")\n    \"Hello10\"\n\n    iex> Macro.camelize(\"foo/bar\")\n    \"Foo.Bar\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.unescape_string(string) <response> Unescapes characters in a string.\n\nThis is the unescaping behaviour used by default in Elixir\nsingle- and double-quoted strings. Check `unescape_string/2`\nfor information on how to customize the escaping map.\n\nIn this setup, Elixir will escape the following: `\\0`, `\\a`, `\\b`,\n`\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` and `\\v`. Bytes can be\ngiven as hexadecimals via `\\xNN` and Unicode code points as\n`\\uNNNN` escapes.\n\nThis function is commonly used on sigil implementations\n(like `~r`, `~s` and others), which receive a raw, unescaped\nstring, and it can be used anywhere that needs to mimic how\nElixir parses strings.\n\n## Examples\n\n    iex> Macro.unescape_string(\"example\\\\n\")\n    \"example\\n\"\n\nIn the example above, we pass a string with `\\n` escaped\nand return a version with it unescaped."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.unescape_string(string, map) <response> Unescapes characters in a string according to the given mapping.\n\nCheck `unescape_string/1` if you want to use the same mapping\nas Elixir single- and double-quoted strings.\n\n## Mapping function\n\nThe mapping function receives an integer representing the code point\nof the character it wants to unescape. There are also the special atoms\n`:newline`, `:unicode`, and `:hex`, which control newline, unicode,\nand escaping respectively.\n\nHere is the default mapping function implemented by Elixir:\n\n    def unescape_map(:newline), do: true\n    def unescape_map(:unicode), do: true\n    def unescape_map(:hex), do: true\n    def unescape_map(?0), do: ?0\n    def unescape_map(?a), do: ?\\a\n    def unescape_map(?b), do: ?\\b\n    def unescape_map(?d), do: ?\\d\n    def unescape_map(?e), do: ?\\e\n    def unescape_map(?f), do: ?\\f\n    def unescape_map(?n), do: ?\\n\n    def unescape_map(?r), do: ?\\r\n    def unescape_map(?s), do: ?\\s\n    def unescape_map(?t), do: ?\\t\n    def unescape_map(?v), do: ?\\v\n    def unescape_map(e), do: e\n\nIf the `unescape_map/1` function returns `false`, the char is\nnot escaped and the backslash is kept in the string.\n\n## Examples\n\nUsing the `unescape_map/1` function defined above is easy:\n\n    Macro.unescape_string(\"example\\\\n\", &unescape_map(&1))"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.unique_var(var, context) <response> Generates an AST node representing a unique variable\ngiven by the atoms `var` and `context`.\n\nCalling this function with the same arguments will\ngenerate another variable, with its own unique counter.\nSee `var/2` for an alternative.\n\n## Examples\n\n    iex> {:foo, [counter: c], __MODULE__} = Macro.unique_var(:foo, __MODULE__)\n    iex> is_integer(c)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.unpipe(expr) <response> Breaks a pipeline expression into a list.\n\nThe AST for a pipeline (a sequence of applications of `|>/2`) is similar to the\nAST of a sequence of binary operators or function applications: the top-level\nexpression is the right-most `:|>` (which is the last one to be executed), and\nits left-hand and right-hand sides are its arguments:\n\n    quote do: 100 |> div(5) |> div(2)\n    #=> {:|>, _, [arg1, arg2]}\n\nIn the example above, the `|>/2` pipe is the right-most pipe; `arg1` is the AST\nfor `100 |> div(5)`, and `arg2` is the AST for `div(2)`.\n\nIt's often useful to have the AST for such a pipeline as a list of function\napplications. This function does exactly that:\n\n    Macro.unpipe(quote do: 100 |> div(5) |> div(2))\n    #=> [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}]\n\nWe get a list that follows the pipeline directly: first the `100`, then the\n`div(5)` (more precisely, its AST), then `div(2)`. The `0` as the second\nelement of the tuples is the position of the previous element in the pipeline\ninside the current function application: `{{:div, [], [5]}, 0}` means that the\nprevious element (`100`) will be inserted as the 0th (first) argument to the\n`div/2` function, so that the AST for that function will become `{:div, [],\n[100, 5]}` (`div(100, 5)`)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.update_meta(quoted, fun) <response> Applies the given function to the node metadata if it contains one.\n\nThis is often useful when used with `Macro.prewalk/2` to remove\ninformation like lines and hygienic counters from the expression\nfor either storage or comparison.\n\n## Examples\n\n    iex> quoted = quote line: 10, do: sample()\n    {:sample, [line: 10], []}\n    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n    {:sample, [], []}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.validate(expr) <response> Validates the given expressions are valid quoted expressions.\n\nCheck the type `t:Macro.t/0` for a complete specification of a\nvalid quoted expression.\n\nIt returns `:ok` if the expression is valid. Otherwise it returns\na tuple in the form of `{:error, remainder}` where `remainder` is\nthe invalid part of the quoted expression.\n\n## Examples\n\n    iex> Macro.validate({:two_element, :tuple})\n    :ok\n    iex> Macro.validate({:three, :element, :tuple})\n    {:error, {:three, :element, :tuple}}\n\n    iex> Macro.validate([1, 2, 3])\n    :ok\n    iex> Macro.validate([1, 2, 3, {4}])\n    {:error, {4}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.var(var, context) <response> Generates an AST node representing the variable given\nby the atoms `var` and `context`.\n\nNote this variable is not unique. If you later on want\nto access this same variable, you can invoke `var/2`\nagain with the same arguments. Use `unique_var/2` to\ngenerate a unique variable that can't be overridden.\n\n## Examples\n\nIn order to build a variable, a context is expected.\nMost of the times, in order to preserve hygiene, the\ncontext must be `__MODULE__/0`:\n\n    iex> Macro.var(:foo, __MODULE__)\n    {:foo, [], __MODULE__}\n\nHowever, if there is a need to access the user variable,\nnil can be given:\n\n    iex> Macro.var(:foo, nil)\n    {:foo, [], nil}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Elixir.Macro <response> Functions for manipulating AST and implementing macros.\n\nMacros are compile-time constructs that receive Elixir's AST as input\nand return Elixir's AST as output.\n\nMany of the functions in this module exist precisely to work with Elixir\nAST, to traverse, query, and transform it.\n\nLet's see a simple example that shows the difference between functions\nand macros:\n\n    defmodule Example do\n      defmacro macro_inspect(value) do\n        IO.inspect(value)\n        value\n      end\n\n      def fun_inspect(value) do\n        IO.inspect(value)\n        value\n      end\n    end\n\nNow let's give it a try:\n\n    import Example\n\n    macro_inspect(1)\n    #=> 1\n    #=> 1\n\n    fun_inspect(1)\n    #=> 1\n    #=> 1\n\nSo far they behave the same, as we are passing an integer as argument.\nBut let's see what happens when we pass an expression:\n\n    macro_inspect(1 + 2)\n    #=> {:+, [line: 3], [1, 2]}\n    #=> 3\n\n    fun_inspect(1 + 2)\n    #=> 3\n    #=> 3\n\nThe macro receives the representation of the code given as argument,\nwhile a function receives the result of the code given as argument.\nA macro must return a superset of the code representation. See\n`t:input/0` and `t:output/0` for more information.\n\nTo learn more about Elixir's AST and how to build them programmatically,\nsee `quote/2`.\n\n> Note: the functions in this module do not evaluate code. In fact,\n> evaluating code from macros is often an anti-pattern. For code\n> evaluation, see the `Code` module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Elixir.Macro <response> Custom Sigils\n\nMacros are also commonly used to implement custom sigils. To create a custom\nsigil, define a macro with the name `sigil_{identifier}` that takes two\narguments. The first argument will be the string, the second will be a charlist\ncontaining any modifiers. If the sigil is lower case (such as `sigil_x`) then\nthe string argument will allow interpolation. If the sigil is upper case\n(such as `sigil_X`) then the string will not be interpolated.\n\nValid modifiers include only lower and upper case letters. Other characters\nwill cause a syntax error.\n\nThe module containing the custom sigil must be imported before the sigil\nsyntax can be used."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Macro.Elixir.Macro <response> # Examples\n\n    defmodule MySigils do\n      defmacro sigil_x(term, [?r]) do\n        quote do\n          unquote(term) |> String.reverse()\n        end\n      end\n      defmacro sigil_x(term, _modifiers) do\n        term\n      end\n      defmacro sigil_X(term, [?r]) do\n        quote do\n          unquote(term) |> String.reverse()\n        end\n      end\n      defmacro sigil_X(term, _modifiers) do\n        term\n      end\n    end\n\n    import MySigils\n\n    ~x(with #{\"inter\" <> \"polation\"})\n    #=>\"with interpolation\"\n\n    ~x(with #{\"inter\" <> \"polation\"})r\n    #=>\"noitalopretni htiw\"\n\n    ~X(without #{\"interpolation\"})\n    #=>\"without \\#{\"interpolation\"}\"\n\n    ~X(without #{\"interpolation\"})r\n    #=>\"}\\\"noitalopretni\\\"{# tuohtiw\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.delete(map, key) <response> Deletes the entry in `map` for a specific `key`.\n\nIf the `key` does not exist, returns `map` unchanged.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.delete(%{a: 1, b: 2}, :a)\n    %{b: 2}\n    iex> Map.delete(%{b: 2}, :a)\n    %{b: 2}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.drop(map, keys) <response> Drops the given `keys` from `map`.\n\nIf `keys` contains keys that are not in `map`, they're simply ignored.\n\n## Examples\n\n    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n    %{a: 1, c: 3}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.equal?(map1, map2) <response> Checks if two maps are equal.\n\nTwo maps are considered to be equal if they contain\nthe same keys and those keys contain the same values.\n\nNote this function exists for completeness so the `Map`\nand `Keyword` modules provide similar APIs. In practice,\ndevelopers often compare maps using `==/2` or `===/2`\ndirectly.\n\n## Examples\n\n    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n    true\n    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n    false\n\nComparison between keys and values is done with `===/3`,\nwhich means integers are not equivalent to floats:\n\n    iex> Map.equal?(%{a: 1.0}, %{a: 1})\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.fetch(map, key) <response> Fetches the value for a specific `key` in the given `map`.\n\nIf `map` contains the given `key` then its value is returned in the shape of `{:ok, value}`.\nIf `map` doesn't contain `key`, `:error` is returned.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.fetch(%{a: 1}, :a)\n    {:ok, 1}\n    iex> Map.fetch(%{a: 1}, :b)\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.fetch!(map, key) <response> Fetches the value for a specific `key` in the given `map`, erroring out if\n`map` doesn't contain `key`.\n\nIf `map` contains `key`, the corresponding value is returned. If\n`map` doesn't contain `key`, a `KeyError` exception is raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.fetch!(%{a: 1}, :a)\n    1"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.filter(map, fun) <response> Returns a map containing only those pairs from `map`\nfor which `fun` returns a truthy value.\n\n`fun` receives the key and value of each of the\nelements in the map as a key-value pair.\n\nSee also `reject/2` which discards all elements where the\nfunction returns a truthy value.\n\n> Note: if you find yourself doing multiple calls to `Map.filter/2`\n> and `Map.reject/2` in a pipeline, it is likely more efficient\n> to use `Enum.map/2` and `Enum.filter/2` instead and convert to\n> a map at the end using `Map.new/1`.\n\n## Examples\n\n    iex> Map.filter(%{one: 1, two: 2, three: 3}, fn {_key, val} -> rem(val, 2) == 1 end)\n    %{one: 1, three: 3}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.from_keys(keys, value) <response> Builds a map from the given `keys` and the fixed `value`.\n\n## Examples\n\n    iex> Map.from_keys([1, 2, 3], :number)\n    %{1 => :number, 2 => :number, 3 => :number}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.from_struct(struct) <response> Converts a `struct` to map.\n\nIt accepts the struct module or a struct itself and\nsimply removes the `__struct__` field from the given struct\nor from a new struct generated from the given module.\n\n## Example\n\n    defmodule User do\n      defstruct [:name]\n    end\n\n    Map.from_struct(User)\n    #=> %{name: nil}\n\n    Map.from_struct(%User{name: \"john\"})\n    #=> %{name: \"john\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.get(map, key, default \\\\ nil) <response> Gets the value for a specific `key` in `map`.\n\nIf `key` is present in `map` then its value `value` is\nreturned. Otherwise, `default` is returned.\n\nIf `default` is not provided, `nil` is used.\n\n## Examples\n\n    iex> Map.get(%{}, :a)\n    nil\n    iex> Map.get(%{a: 1}, :a)\n    1\n    iex> Map.get(%{a: 1}, :b)\n    nil\n    iex> Map.get(%{a: 1}, :b, 3)\n    3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.get_and_update(map, key, fun) <response> Gets the value from `key` and updates it, all in one pass.\n\n`fun` is called with the current value under `key` in `map` (or `nil` if `key`\nis not present in `map`) and must return a two-element tuple: the current value\n(the retrieved value, which can be operated on before being returned) and the\nnew value to be stored under `key` in the resulting new map. `fun` may also\nreturn `:pop`, which means the current value shall be removed from `map` and\nreturned (making this function behave like `Map.pop(map, key)`).\n\nThe returned value is a two-element tuple with the current value returned by\n`fun` and a new map with the updated value under `key`.\n\n## Examples\n\n    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, %{a: \"new value!\"}}\n\n    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {nil, %{a: 1, b: \"new value!\"}}\n\n    iex> Map.get_and_update(%{a: 1}, :a, fn _ -> :pop end)\n    {1, %{}}\n\n    iex> Map.get_and_update(%{a: 1}, :b, fn _ -> :pop end)\n    {nil, %{a: 1}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.get_and_update!(map, key, fun) <response> Gets the value from `key` and updates it, all in one pass. Raises if there is no `key`.\n\nBehaves exactly like `get_and_update/3`, but raises a `KeyError` exception if\n`key` is not present in `map`.\n\n## Examples\n\n    iex> Map.get_and_update!(%{a: 1}, :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, %{a: \"new value!\"}}\n\n    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    ** (KeyError) key :b not found in: %{a: 1}\n\n    iex> Map.get_and_update!(%{a: 1}, :a, fn _ ->\n    ...>   :pop\n    ...> end)\n    {1, %{}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.get_lazy(map, key, fun) <response> Gets the value for a specific `key` in `map`.\n\nIf `key` is present in `map` then its value `value` is\nreturned. Otherwise, `fun` is evaluated and its result is returned.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Map.get_lazy(map, :a, fun)\n    1\n    iex> Map.get_lazy(map, :b, fun)\n    13"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.has_key?(map, key) <response> Returns whether the given `key` exists in the given `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.has_key?(%{a: 1}, :a)\n    true\n    iex> Map.has_key?(%{a: 1}, :b)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.keys(map) <response> Returns all keys from `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.keys(%{a: 1, b: 2})\n    [:a, :b]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.merge(map1, map2) <response> Merges two maps into one.\n\nAll keys in `map2` will be added to `map1`, overriding any existing one\n(i.e., the keys in `map2` \"have precedence\" over the ones in `map1`).\n\nIf you have a struct and you would like to merge a set of keys into the\nstruct, do not use this function, as it would merge all keys on the right\nside into the struct, even if the key is not part of the struct. Instead,\nuse `struct/2`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n    %{a: 3, b: 2, d: 4}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.merge(map1, map2, fun) <response> Merges two maps into one, resolving conflicts through the given `fun`.\n\nAll keys in `map2` will be added to `map1`. The given function will be invoked\nwhen there are duplicate keys; its arguments are `key` (the duplicate key),\n`value1` (the value of `key` in `map1`), and `value2` (the value of `key` in\n`map2`). The value returned by `fun` is used as the value under `key` in\nthe resulting map.\n\n## Examples\n\n    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    %{a: 4, b: 2, d: 4}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.new() <response> Returns a new empty map.\n\n## Examples\n\n    iex> Map.new()\n    %{}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.new(enumerable) <response> Creates a map from an `enumerable`.\n\nDuplicated keys are removed; the latest one prevails.\n\n## Examples\n\n    iex> Map.new([{:b, 1}, {:a, 2}])\n    %{a: 2, b: 1}\n    iex> Map.new(a: 1, a: 2, a: 3)\n    %{a: 3}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.new(enumerable, transform) <response> Creates a map from an `enumerable` via the given transformation function.\n\nDuplicated keys are removed; the latest one prevails.\n\n## Examples\n\n    iex> Map.new([:a, :b], fn x -> {x, x} end)\n    %{a: :a, b: :b}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.pop(map, key, default \\\\ nil) <response> Removes the value associated with `key` in `map` and returns the value and the updated map.\n\nIf `key` is present in `map`, it returns `{value, updated_map}` where `value` is the value of\nthe key and `updated_map` is the result of removing `key` from `map`. If `key`\nis not present in `map`, `{default, map}` is returned.\n\n## Examples\n\n    iex> Map.pop(%{a: 1}, :a)\n    {1, %{}}\n    iex> Map.pop(%{a: 1}, :b)\n    {nil, %{a: 1}}\n    iex> Map.pop(%{a: 1}, :b, 3)\n    {3, %{a: 1}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.pop!(map, key) <response> Removes the value associated with `key` in `map` and returns the value\nand the updated map, or it raises if `key` is not present.\n\nBehaves the same as `pop/3` but raises if `key` is not present in `map`.\n\n## Examples\n\n    iex> Map.pop!(%{a: 1}, :a)\n    {1, %{}}\n    iex> Map.pop!(%{a: 1, b: 2}, :a)\n    {1, %{b: 2}}\n    iex> Map.pop!(%{a: 1}, :b)\n    ** (KeyError) key :b not found in: %{a: 1}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.pop_lazy(map, key, fun) <response> Lazily returns and removes the value associated with `key` in `map`.\n\nIf `key` is present in `map`, it returns `{value, new_map}` where `value` is the value of\nthe key and `new_map` is the result of removing `key` from `map`. If `key`\nis not present in `map`, `{fun_result, map}` is returned, where `fun_result`\nis the result of applying `fun`.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Map.pop_lazy(map, :a, fun)\n    {1, %{}}\n    iex> Map.pop_lazy(map, :b, fun)\n    {13, %{a: 1}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.put(map, key, value) <response> Puts the given `value` under `key` in `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.put(%{a: 1}, :b, 2)\n    %{a: 1, b: 2}\n    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.put_new(map, key, value) <response> Puts the given `value` under `key` unless the entry `key`\nalready exists in `map`.\n\n## Examples\n\n    iex> Map.put_new(%{a: 1}, :b, 2)\n    %{a: 1, b: 2}\n    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n    %{a: 1, b: 2}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.put_new_lazy(map, key, fun) <response> Evaluates `fun` and puts the result under `key`\nin `map` unless `key` is already present.\n\nThis function is useful in case you want to compute the value to put under\n`key` only if `key` is not already present, as for example, when the value is expensive to\ncalculate or generally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   3\n    ...> end\n    iex> Map.put_new_lazy(map, :a, fun)\n    %{a: 1}\n    iex> Map.put_new_lazy(map, :b, fun)\n    %{a: 1, b: 3}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.reject(map, fun) <response> Returns map excluding the pairs from `map` for which `fun` returns\na truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> Map.reject(%{one: 1, two: 2, three: 3}, fn {_key, val} -> rem(val, 2) == 1 end)\n    %{two: 2}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.replace(map, key, value) <response> Puts a value under `key` only if the `key` already exists in `map`.\n\n## Examples\n\n    iex> Map.replace(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n    iex> Map.replace(%{a: 1}, :b, 2)\n    %{a: 1}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.replace!(map, key, value) <response> Puts a value under `key` only if the `key` already exists in `map`.\n\nIf `key` is not present in `map`, a `KeyError` exception is raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.replace!(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n    iex> Map.replace!(%{a: 1}, :b, 2)\n    ** (KeyError) key :b not found in: %{a: 1}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.replace_lazy(map, key, fun) <response> Replaces the value under `key` using the given function only if\n`key` already exists in `map`.\n\nIn comparison to `replace/3`, this can be useful when it's expensive to calculate the value.\n\nIf `key` does not exist, the original map is returned unchanged.\n\n## Examples\n\n    iex> Map.replace_lazy(%{a: 1, b: 2}, :a, fn v -> v * 4 end)\n    %{a: 4, b: 2}\n\n    iex> Map.replace_lazy(%{a: 1, b: 2}, :c, fn v -> v * 4 end)\n    %{a: 1, b: 2}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.split(map, keys) <response> Takes all entries corresponding to the given `keys` in `map` and extracts\nthem into a separate map.\n\nReturns a tuple with the new map and the old map with removed keys.\n\nKeys for which there are no entries in `map` are ignored.\n\n## Examples\n\n    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n    {%{a: 1, c: 3}, %{b: 2}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.take(map, keys) <response> Returns a new map with all the key-value pairs in `map` where the key\nis in `keys`.\n\nIf `keys` contains keys that are not in `map`, they're simply ignored.\n\n## Examples\n\n    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n    %{a: 1, c: 3}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.to_list(map) <response> Converts `map` to a list.\n\nEach key-value pair in the map is converted to a two-element tuple `{key,\nvalue}` in the resulting list.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.to_list(%{a: 1})\n    [a: 1]\n    iex> Map.to_list(%{1 => 2})\n    [{1, 2}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.update(map, key, default, fun) <response> Updates the `key` in `map` with the given function.\n\nIf `key` is present in `map` then the existing value is passed to `fun` and its result is\nused as the updated value of `key`. If `key` is\nnot present in `map`, `default` is inserted as the value of `key`. The default\nvalue will not be passed through the update function.\n\n## Examples\n\n    iex> Map.update(%{a: 1}, :a, 13, fn existing_value -> existing_value * 2 end)\n    %{a: 2}\n    iex> Map.update(%{a: 1}, :b, 11, fn existing_value -> existing_value * 2 end)\n    %{a: 1, b: 11}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.update!(map, key, fun) <response> Updates `key` with the given function.\n\nIf `key` is present in `map` then the existing value is passed to `fun` and its result is\nused as the updated value of `key`. If `key` is\nnot present in `map`, a `KeyError` exception is raised.\n\n## Examples\n\n    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n    %{a: 2}\n\n    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n    ** (KeyError) key :b not found in: %{a: 1}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.values(map) <response> Returns all values from `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.values(%{a: 1, b: 2})\n    [1, 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Map.Elixir.Map <response> Maps are the \"go to\" key-value data structure in Elixir.\n\nMaps can be created with the `%{}` syntax, and key-value pairs can be\nexpressed as `key => value`:\n\n    iex> %{}\n    %{}\n    iex> %{\"one\" => :two, 3 => \"four\"}\n    %{3 => \"four\", \"one\" => :two}\n\nKey-value pairs in a map do not follow any order (that's why the printed map\nin the example above has a different order than the map that was created).\n\nMaps do not impose any restriction on the key type: anything can be a key in a\nmap. As a key-value structure, maps do not allow duplicated keys. Keys are\ncompared using the exact-equality operator (`===/2`). If colliding keys are defined\nin a map literal, the last one prevails.\n\nWhen the key in a key-value pair is an atom, the `key: value` shorthand syntax\ncan be used (as in many other special forms):\n\n    iex> %{a: 1, b: 2}\n    %{a: 1, b: 2}\n\nIf you want to mix the shorthand syntax with `=>`, the shorthand syntax must come\nat the end:\n\n    iex> %{\"hello\" => \"world\", a: 1, b: 2}\n    %{:a => 1, :b => 2, \"hello\" => \"world\"}\n\nKeys in maps can be accessed through some of the functions in this module\n(such as `Map.get/3` or `Map.fetch/2`) or through the `map[]` syntax provided\nby the `Access` module:\n\n    iex> map = %{a: 1, b: 2}\n    iex> Map.fetch(map, :a)\n    {:ok, 1}\n    iex> map[:b]\n    2\n    iex> map[\"non_existing_key\"]\n    nil\n\nTo access atom keys, one may also use the `map.key` notation. Note that `map.key`\nwill raise a `KeyError` if the `map` doesn't contain the key `:key`, compared to\n`map[:key]`, that would return `nil`.\n\n    map = %{foo: \"bar\", baz: \"bong\"}\n    map.foo\n    #=> \"bar\"\n    map.non_existing_key\n    ** (KeyError) key :non_existing_key not found in: %{baz: \"bong\", foo: \"bar\"}\n\n> Note: do not add parens when accessing fields, such as in `data.key()`.\n> If parenthesis are used, Elixir will expect `data` to be an atom representing\n> a module and attempt to call the *function* `key/0` in it.\n\nThe two syntaxes for accessing keys reveal the dual nature of maps. The `map[key]`\nsyntax is used for dynamically created maps that may have any key, of any type.\n`map.key` is used with maps that hold a predetermined set of atoms keys, which are\nexpected to always be present. Structs, defined via `defstruct/1`, are one example\nof such \"static maps\", where the keys can also be checked during compile time.\n\nMaps can be pattern matched on. When a map is on the left-hand side of a\npattern match, it will match if the map on the right-hand side contains the\nkeys on the left-hand side and their values match the ones on the left-hand\nside. This means that an empty map matches every map.\n\n    iex> %{} = %{foo: \"bar\"}\n    %{foo: \"bar\"}\n    iex> %{a: a} = %{:a => 1, \"b\" => 2, [:c, :e, :e] => 3}\n    iex> a\n    1\n\nBut this will raise a `MatchError` exception:\n\n    %{:c => 3} = %{:a => 1, 2 => :b}\n\nVariables can be used as map keys both when writing map literals as well as\nwhen matching:\n\n    iex> n = 1\n    1\n    iex> %{n => :one}\n    %{1 => :one}\n    iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}\n    %{1 => :one, 2 => :two, 3 => :three}\n\nMaps also support a specific update syntax to update the value stored under\n*existing* keys. You can update using the atom keys syntax:\n\n    iex> map = %{one: 1, two: 2}\n    iex> %{map | one: \"one\"}\n    %{one: \"one\", two: 2}\n\nOr any other key:\n\n    iex> other_map = %{\"three\" => 3, \"four\" => 4}\n    iex> %{other_map | \"three\" => \"three\"}\n    %{\"four\" => 4, \"three\" => \"three\"}\n\nWhen a key that does not exist in the map is updated a `KeyError` exception will be raised:\n\n    %{map | three: 3}\n\nThe functions in this module that need to find a specific key work in logarithmic time.\nThis means that the time it takes to find keys grows as the map grows, but it's not\ndirectly proportional to the map size. In comparison to finding an element in a list,\nit performs better because lists have a linear time complexity. Some functions,\nsuch as `keys/1` and `values/1`, run in linear time because they need to get to every\nelement in the map.\n\nMaps also implement the `Enumerable` protocol, so many functions to work with maps\nare found in the `Enum` module. Additionally, the following functions for maps are\nfound in `Kernel`:\n\n  * `map_size/1`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.delete(map_set, value) <response> Deletes `value` from `map_set`.\n\nReturns a new set which is a copy of `map_set` but without `value`.\n\n## Examples\n\n    iex> map_set = MapSet.new([1, 2, 3])\n    iex> MapSet.delete(map_set, 4)\n    MapSet.new([1, 2, 3])\n    iex> MapSet.delete(map_set, 2)\n    MapSet.new([1, 3])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.difference(map_set1, map_set2) <response> Returns a set that is `map_set1` without the members of `map_set2`.\n\n## Examples\n\n    iex> MapSet.difference(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([1])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.disjoint?(map_set1, map_set2) <response> Checks if `map_set1` and `map_set2` have no members in common.\n\n## Examples\n\n    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    true\n    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([2, 3]))\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.equal?(map_set1, map_set2) <response> Checks if two sets are equal.\n\nThe comparison between elements is done using `===/2`,\nwhich a set with `1` is not equivalent to a set with\n`1.0`.\n\n## Examples\n\n    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([2, 1, 1]))\n    true\n    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    false\n    iex> MapSet.equal?(MapSet.new([1]), MapSet.new([1.0]))\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.filter(map_set, fun) <response> Filters the set by returning only the elements from `set` for which invoking\n`fun` returns a truthy value.\n\nAlso see `reject/2` which discards all elements where the function returns\na truthy value.\n\n> Note: if you find yourself doing multiple calls to `MapSet.filter/2`\n> and `MapSet.reject/2` in a pipeline, it is likely more efficient\n> to use `Enum.map/2` and `Enum.filter/2` instead and convert to\n> a map at the end using `Map.new/1`.\n\n## Examples\n\n    iex> MapSet.filter(MapSet.new(1..5), fn x -> x > 3 end)\n    MapSet.new([4, 5])\n\n    iex> MapSet.filter(MapSet.new([\"a\", :b, \"c\"]), &is_atom/1)\n    MapSet.new([:b])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.intersection(map_set, map_set) <response> Returns a set containing only members that `map_set1` and `map_set2` have in common.\n\n## Examples\n\n    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([2])\n\n    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    MapSet.new([])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.member?(map_set, value) <response> Checks if `map_set` contains `value`.\n\n## Examples\n\n    iex> MapSet.member?(MapSet.new([1, 2, 3]), 2)\n    true\n    iex> MapSet.member?(MapSet.new([1, 2, 3]), 4)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.new() <response> Returns a new set.\n\n## Examples\n\n    iex> MapSet.new()\n    MapSet.new([])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.new(enumerable) <response> Creates a set from an enumerable.\n\n## Examples\n\n    iex> MapSet.new([:b, :a, 3])\n    MapSet.new([3, :a, :b])\n    iex> MapSet.new([3, 3, 3, 2, 2, 1])\n    MapSet.new([1, 2, 3])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.new(enumerable, transform) <response> Creates a set from an enumerable via the transformation function.\n\n## Examples\n\n    iex> MapSet.new([1, 2, 1], fn x -> 2 * x end)\n    MapSet.new([2, 4])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.put(map_set, value) <response> Inserts `value` into `map_set` if `map_set` doesn't already contain it.\n\n## Examples\n\n    iex> MapSet.put(MapSet.new([1, 2, 3]), 3)\n    MapSet.new([1, 2, 3])\n    iex> MapSet.put(MapSet.new([1, 2, 3]), 4)\n    MapSet.new([1, 2, 3, 4])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.reject(map_set, fun) <response> Returns a set by excluding the elements from `set` for which invoking `fun`\nreturns a truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> MapSet.reject(MapSet.new(1..5), fn x -> rem(x, 2) != 0 end)\n    MapSet.new([2, 4])\n\n    iex> MapSet.reject(MapSet.new([\"a\", :b, \"c\"]), &is_atom/1)\n    MapSet.new([\"a\", \"c\"])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.size(map_set) <response> Returns the number of elements in `map_set`.\n\n## Examples\n\n    iex> MapSet.size(MapSet.new([1, 2, 3]))\n    3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.subset?(map_set1, map_set2) <response> Checks if `map_set1`'s members are all contained in `map_set2`.\n\nThis function checks if `map_set1` is a subset of `map_set2`.\n\n## Examples\n\n    iex> MapSet.subset?(MapSet.new([1, 2]), MapSet.new([1, 2, 3]))\n    true\n    iex> MapSet.subset?(MapSet.new([1, 2, 3]), MapSet.new([1, 2]))\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.symmetric_difference(map_set1, map_set2) <response> Returns a set with elements that are present in only one but not both sets.\n\n## Examples\n\n    iex> MapSet.symmetric_difference(MapSet.new([1, 2, 3]), MapSet.new([2, 3, 4]))\n    MapSet.new([1, 4])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.to_list(map_set) <response> Converts `map_set` to a list.\n\n## Examples\n\n    iex> MapSet.to_list(MapSet.new([1, 2, 3]))\n    [1, 2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.union(map_set1, map_set2) <response> Returns a set containing all members of `map_set1` and `map_set2`.\n\n## Examples\n\n    iex> MapSet.union(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([1, 2, 3, 4])"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.MapSet.Elixir.MapSet <response> Functions that work on sets.\n\nA set is a data structure that can contain unique elements of any kind,\nwithout any particular order. `MapSet` is the \"go to\" set data structure in Elixir.\n\nA set can be constructed using `MapSet.new/0`:\n\n    iex> MapSet.new()\n    MapSet.new([])\n\nElements in a set don't have to be of the same type and they can be\npopulated from an [enumerable](`t:Enumerable.t/0`) using `MapSet.new/1`:\n\n    iex> MapSet.new([1, :two, {\"three\"}])\n    MapSet.new([1, :two, {\"three\"}])\n\nElements can be inserted using `MapSet.put/2`:\n\n    iex> MapSet.new([2]) |> MapSet.put(4) |> MapSet.put(0)\n    MapSet.new([0, 2, 4])\n\nBy definition, sets can't contain duplicate elements: when\ninserting an element in a set where it's already present, the insertion is\nsimply a no-op.\n\n    iex> map_set = MapSet.new()\n    iex> MapSet.put(map_set, \"foo\")\n    MapSet.new([\"foo\"])\n    iex> map_set |> MapSet.put(\"foo\") |> MapSet.put(\"foo\")\n    MapSet.new([\"foo\"])\n\nA `MapSet` is represented internally using the `%MapSet{}` struct. This struct\ncan be used whenever there's a need to pattern match on something being a `MapSet`:\n\n    iex> match?(%MapSet{}, MapSet.new())\n    true\n\nNote that, however, the struct fields are private and must not be accessed\ndirectly; use the functions in this module to perform operations on sets.\n\n`MapSet`s can also be constructed starting from other collection-type data\nstructures: for example, see `MapSet.new/1` or `Enum.into/2`.\n\n`MapSet` is built on top of `Map`, this means that they share many properties,\nincluding logarithmic time complexity. See the documentation for `Map` for more\ninformation on its execution time complexity."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.LocalsTracker.add_defaults(arg, kind, pair, defaults, meta) <response> Adds and tracks defaults for a definition into the tracker."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.LocalsTracker.add_import(arg, function, module, imported) <response> Adds an import dispatch to the given target."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.LocalsTracker.add_local(arg, from, to, meta, macro_dispatch?) <response> Adds a local dispatch from-to the given target."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.LocalsTracker.collect_imports_conflicts(arg, all_defined) <response> Collect all conflicting imports with the given functions"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.LocalsTracker.collect_undefined_locals(arg, all_defined) <response> Collect undefined functions based on local calls and existing definitions."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.LocalsTracker.collect_unused_locals(arg, all_defined, private) <response> Collect all unused definitions based on the private\ngiven, also accounting the expected number of default\nclauses a private function have."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.LocalsTracker.reachable_from(arg, local) <response> Returns all local nodes reachable from `vertex`.\n\nBy default, all public functions are reachable.\nA private function is only reachable if it has\na public function that it invokes directly."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.LocalsTracker.reattach(arg, tuple, kind, function, out_neighbours, meta) <response> Reattach a previously yanked node."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.LocalsTracker.yank(arg, local) <response> Yanks a local node. Returns its in and out vertices in a tuple."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.ParallelChecker.all_exports(arg, module) <response> Returns all exported functions and macros for the given module from\nthe cache."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.ParallelChecker.fetch_export(arg, module, fun, arity) <response> Returns the export kind and deprecation reason for the given MFA from\nthe cache. If the module does not exist return `{:error, :module}`,\nor if the function does not exist return `{:error, :function}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.ParallelChecker.get() <response> Gets the parallel checker data from pdict."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.ParallelChecker.preload_module(arg, module) <response> Preloads a module into the cache. Call this function before any other\ncache lookups for the module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.ParallelChecker.put(pid, checker) <response> Stores the parallel checker information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.ParallelChecker.spawn(arg, module, info) <response> Spawns a process that runs the parallel checker."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.ParallelChecker.start_link(schedulers \\\\ nil) <response> Initializes the parallel checker process."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.ParallelChecker.stop(checker) <response> Stops the parallel checker process."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.ParallelChecker.test_cache() <response> Test cache."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.ParallelChecker.verify(fun) <response> Verifies the given compilation function\nby starting a checker if one does not exist.\nSee `verify/3`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.ParallelChecker.verify(checker, runtime_files) <response> Receives pairs of module maps and BEAM binaries. In parallel it verifies\nthe modules and adds the ExCk chunk to the binaries. Returns the updated\nlist of warnings from the verification."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Helpers.flat_map_ok(list, fun) <response> Like `Enum.flat_map/2` but only continues while `fun` returns `{:ok, list}`\nand stops on `{:error, reason}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Helpers.flat_map_reduce_ok(list, acc, fun) <response> Like `Enum.flat_map_reduce/3` but only continues while `fun` returns `{:ok, list, acc}`\nand stops on `{:error, reason}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Helpers.get_meta(arg1) <response> Returns the AST metadata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Helpers.guards_to_or(guards) <response> Combines a list of guard expressions `when x when y when z` to an expression\ncombined with `or`, `x or y or z`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Helpers.map_ok(list, fun) <response> Like `Enum.map/2` but only continues while `fun` returns `{:ok, elem}`\nand stops on `{:error, reason}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Helpers.map_reduce_ok(list, acc, fun) <response> Like `Enum.map_reduce/3` but only continues while `fun` returns `{:ok, elem, acc}`\nand stops on `{:error, reason}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Helpers.oks_or_errors(list) <response> Given a list of `[{:ok, term()} | {:error, term()}]` it returns a list of\nerrors `{:error, [term()]}` in case of at least one error or `{:ok, [term()]}`\nif there are no errors."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Helpers.reduce_ok(list, acc, fun) <response> Like `Enum.reduce/3` but only continues while `fun` returns `{:ok, acc}`\nand stops on `{:error, reason}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Helpers.unzip_ok(list) <response> Like `Enum.unzip/1` but only continues while `fun` returns `{:ok, elem1, elem2}`\nand stops on `{:error, reason}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Helpers.var_name(arg) <response> Returns unique identifier for the current assignment of the variable."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Helpers.zip_many(lists) <response> Like `Enum.zip/1` but will zip multiple lists together instead of only two."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Of.binary(list, stack, context, of_fun) <response> Handles binaries.\n\nIn the stack, we add nodes such as <<expr>>, <<..., expr>>, etc,\nbased on the position of the expression within the binary."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Of.closed_map(args, stack, context, of_fun) <response> Handles closed maps (without dynamic => dynamic)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Of.open_map(args, stack, context, of_fun) <response> Handles open maps (with dynamic => dynamic)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Of.remote(module, fun, arity, meta, context) <response> Handles remote calls."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Of.struct(struct, meta, context) <response> Handles structs."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Pattern.of_guard(expr, expected, stack, context) <response> Refines the type variables in the typing context using type check guards\nsuch as `is_integer/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Pattern.of_head(patterns, guards, stack, context) <response> Handles patterns and guards at once."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Pattern.of_pattern(pattern, stack, context) <response> Return the type and typing context of a pattern expression or an error\nin case of a typing conflict."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.add_var(context) <response> Adds an internal variable to the typing context and returns its type variable.\nAn internal variable is used to help unify complex expressions,\nit does not belong to a specific AST expression."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.collect_var_indexes(type, context, acc \\\\ %{}) <response> Collects all type vars recursively."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.flatten_union(type, context) <response> Expand unions so that all unions are at the top level.\n\n    {integer() | float()} => {integer()} | {float()}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.format_type(atom, simplify?) <response> Formats types.\n\nThe second argument says when complex types such as maps and\nstructs should be simplified and not shown."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.get_var!(var, context) <response> Gets a variable."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.has_unbound_var?(type, context) <response> Checks if the type has a type var."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.lift_types(types, context) <response> Lifts type variables to their inferred types from the context."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.new_var(var, context) <response> Adds a variable to the typing context and returns its type variable.\nIf the variable has already been added, return the existing type variable."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.push_expr_stack(expr, stack) <response> Push expression to stack.\n\nThe expression stack is used to give the context where a type variable\nwas refined when show a type conflict error."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.refine_var!(var, type, stack, context) <response> Set the type for a variable and add trace."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.remove_var(var, context) <response> Remove type variable and all its traces."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.resolve_var(other, context) <response> Maybe resolves a variable."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.restore_var!(var, new_context, old_context) <response> Restores the variable information from the old context into new context."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.singleton?(arg1, context) <response> Returns true if it is a singleton type.\n\nOnly atoms are singleton types. Unbound vars are not\nconsidered singleton types."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.subtype?(type, type, context) <response> Checks if the first argument is a subtype of the second argument.\n\nThis function assumes that:\n\n  * unbound variables are not subtype of anything\n\n  * dynamic is not considered a subtype of all other types but the top type.\n    This allows this function can be used for ordering, in other cases, you\n    may need to check for both sides"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.to_union(types, context) <response> Returns a \"simplified\" union using `subtype?/3` to remove redundant types.\n\nDue to limitations in `subtype?/3` some overlapping types may still be\nincluded. For example unions with overlapping non-concrete types such as\n`{boolean()} | {atom()}` will not be merged or types with variables that\nare distinct but equivalent such as `a | b when a ~ b`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.unify(same, same, stack, context) <response> Unifies two types and returns the unified type and an updated typing context\nor an error in case of a typing conflict."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Types.Unify.walk(type, acc, fun) <response> Performs a depth-first, pre-order traversal of the type tree using an accumulator."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.attributes_in(module) <response> Returns all module attributes names defined in `module`.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule Example do\n      @foo 1\n      Module.register_attribute(__MODULE__, :bar, accumulate: true)\n\n      :foo in Module.attributes_in(__MODULE__)\n      #=> true\n\n      :bar in Module.attributes_in(__MODULE__)\n      #=> true\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.concat(list) <response> Concatenates a list of aliases and returns a new alias.\n\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.concat([Foo, Bar])\n    Foo.Bar\n\n    iex> Module.concat([Foo, \"Bar\"])\n    Foo.Bar"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.concat(left, right) <response> Concatenates two aliases and returns a new alias.\n\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.concat(Foo, Bar)\n    Foo.Bar\n\n    iex> Module.concat(Foo, \"Bar\")\n    Foo.Bar"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.create(module, quoted, opts) <response> Creates a module with the given name and defined by\nthe given quoted expressions.\n\nThe line where the module is defined and its file **must**\nbe passed as options.\n\nIt returns a tuple of shape `{:module, module, binary, term}`\nwhere `module` is the module name, `binary` is the module\nbytecode and `term` is the result of the last expression in\n`quoted`.\n\nSimilar to `Kernel.defmodule/2`, the binary will only be\nwritten to disk as a `.beam` file if `Module.create/3` is\ninvoked in a file that is currently being compiled.\n\n## Examples\n\n    contents =\n      quote do\n        def world, do: true\n      end\n\n    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n\n    Hello.world()\n    #=> true\n\n## Differences from `defmodule`\n\n`Module.create/3` works similarly to `Kernel.defmodule/2`\nand return the same results. While one could also use\n`Kernel.defmodule/2` to define modules dynamically, this function\nis preferred when the module body is given by a quoted\nexpression.\n\nAnother important distinction is that `Module.create/3`\nallows you to control the environment variables used\nwhen defining the module, while `Kernel.defmodule/2`\nautomatically uses the environment it is invoked at."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.defines?(module, tuple) <response> Checks if the module defines the given function or macro.\n\nUse `defines?/3` to assert for a specific type.\n\nThis function can only be used on modules that have not yet been compiled.\nUse `Kernel.function_exported?/3` and `Kernel.macro_exported?/3` to check for\npublic functions and macros respectively in compiled modules.\n\nNote that `defines?` returns false for functions and macros that have\nbeen defined but then marked as overridable and no other implementation\nhas been provided. You can check the overridable status by calling\n`overridable?/2`.\n\n## Examples\n\n    defmodule Example do\n      Module.defines?(__MODULE__, {:version, 0}) #=> false\n      def version, do: 1\n      Module.defines?(__MODULE__, {:version, 0}) #=> true\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.defines?(module, tuple, def_kind) <response> Checks if the module defines a function or macro of the\ngiven `kind`.\n\n`kind` can be any of `:def`, `:defp`, `:defmacro`, or `:defmacrop`.\n\nThis function can only be used on modules that have not yet been compiled.\nUse `Kernel.function_exported?/3` and `Kernel.macro_exported?/3` to check for\npublic functions and macros respectively in compiled modules.\n\n## Examples\n\n    defmodule Example do\n      Module.defines?(__MODULE__, {:version, 0}, :def) #=> false\n      def version, do: 1\n      Module.defines?(__MODULE__, {:version, 0}, :def) #=> true\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.defines_type?(module, definition) <response> Checks if the current module defines the given type (private, opaque or not).\n\nThis function is only available for modules being compiled."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.definitions_in(module) <response> Returns all functions and macros defined in `module`.\n\nIt returns a list with all defined functions and macros, public and private,\nin the shape of `[{name, arity}, ...]`.\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get the public functions and macros in\ncompiled modules.\n\n## Examples\n\n    defmodule Example do\n      def version, do: 1\n      defmacrop test(arg), do: arg\n      Module.definitions_in(__MODULE__) #=> [{:version, 0}, {:test, 1}]\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.definitions_in(module, kind) <response> Returns all functions defined in `module`, according\nto its kind.\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get the public functions and macros in\ncompiled modules.\n\n## Examples\n\n    defmodule Example do\n      def version, do: 1\n      Module.definitions_in(__MODULE__, :def)  #=> [{:version, 0}]\n      Module.definitions_in(__MODULE__, :defp) #=> []\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.delete_attribute(module, key) <response> Deletes the entry (or entries) for the given module attribute.\n\nIt returns the deleted attribute value. If the attribute has not\nbeen set nor configured to accumulate, it returns `nil`.\n\nIf the attribute is set to accumulate, then this function always\nreturns a list. Deleting the attribute removes existing entries\nbut the attribute will still accumulate.\n\n## Examples\n\n    defmodule MyModule do\n      Module.put_attribute(__MODULE__, :custom_threshold_for_lib, 10)\n      Module.delete_attribute(__MODULE__, :custom_threshold_for_lib)\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.delete_definition(module, arg) <response> Deletes a definition from a module.\n\nIt returns true if the definition exists and it was removed,\notherwise it returns false."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.eval_quoted(module_or_env, quoted, binding \\\\ [], opts \\\\ []) <response> Evaluates the quoted contents in the given module's context.\n\nA list of environment options can also be given as argument.\nSee `Code.eval_string/3` for more information.\n\nRaises an error if the module was already compiled.\n\n## Examples\n\n    defmodule Foo do\n      contents =\n        quote do\n          def sum(a, b), do: a + b\n        end\n\n      Module.eval_quoted(__MODULE__, contents)\n    end\n\n    Foo.sum(1, 2)\n    #=> 3\n\nFor convenience, you can pass any `Macro.Env` struct, such\nas  `__ENV__/0`, as the first argument or as options. Both\nthe module and all options will be automatically extracted\nfrom the environment:\n\n    defmodule Foo do\n      contents =\n        quote do\n          def sum(a, b), do: a + b\n        end\n\n      Module.eval_quoted(__ENV__, contents)\n    end\n\n    Foo.sum(1, 2)\n    #=> 3\n\nNote that if you pass a `Macro.Env` struct as first argument\nwhile also passing `opts`, they will be merged with `opts`\nhaving precedence."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.get_attribute(module, key, default \\\\ nil) <response> Gets the given attribute from a module.\n\nIf the attribute was marked with `accumulate` with\n`Module.register_attribute/3`, a list is always returned.\n`nil` is returned if the attribute has not been marked with\n`accumulate` and has not been set to any value.\n\nThe `@` macro compiles to a call to this function. For example,\nthe following code:\n\n    @foo\n\nExpands to something akin to:\n\n    Module.get_attribute(__MODULE__, :foo)\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get all persisted attributes, or\n`Code.fetch_docs/1` to retrieve all documentation related attributes in\ncompiled modules.\n\n## Examples\n\n    defmodule Foo do\n      Module.put_attribute(__MODULE__, :value, 1)\n      Module.get_attribute(__MODULE__, :value) #=> 1\n\n      Module.get_attribute(__MODULE__, :value, :default) #=> 1\n      Module.get_attribute(__MODULE__, :not_found, :default) #=> :default\n\n      Module.register_attribute(__MODULE__, :value, accumulate: true)\n      Module.put_attribute(__MODULE__, :value, 1)\n      Module.get_attribute(__MODULE__, :value) #=> [1]\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.get_definition(module, arg, options \\\\ []) <response> Returns the definition for the given name-arity pair.\n\nIt returns a tuple with the `version`, the `kind`,\nthe definition `metadata`, and a list with each clause.\nEach clause is a four-element tuple with metadata,\nthe arguments, the guards, and the clause AST.\n\nThe clauses are returned in the Elixir AST but a subset\nthat has already been expanded and normalized. This makes\nit useful for analyzing code but it cannot be reinjected\ninto the module as it will have lost some of its original\ncontext. Given this AST representation is mostly internal,\nit is versioned and it may change at any time. Therefore,\n**use this API with caution**.\n\n## Options\n\n  * `:skip_clauses` (since v1.14.0) - returns `[]` instead\n    of returning the clauses. This is useful when there is\n    only an interest in fetching the kind and the metadata"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.has_attribute?(module, key) <response> Checks if the given attribute has been defined.\n\nAn attribute is defined if it has been registered with `register_attribute/3`\nor assigned a value. If an attribute has been deleted with `delete_attribute/2`\nit is no longer considered defined.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule MyModule do\n      @value 1\n      Module.register_attribute(__MODULE__, :other_value)\n      Module.put_attribute(__MODULE__, :another_value, 1)\n\n      Module.has_attribute?(__MODULE__, :value) #=> true\n      Module.has_attribute?(__MODULE__, :other_value) #=> true\n      Module.has_attribute?(__MODULE__, :another_value) #=> true\n\n      Module.has_attribute?(__MODULE__, :undefined) #=> false\n\n      Module.delete_attribute(__MODULE__, :value)\n      Module.has_attribute?(__MODULE__, :value) #=> false\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.make_overridable(module, tuples) <response> Makes the given functions in `module` overridable.\n\nAn overridable function is lazily defined, allowing a\ndeveloper to customize it. See `Kernel.defoverridable/1` for\nmore information and documentation.\n\nOnce a function or a macro is marked as overridable, it will\nno longer be listed under `definitions_in/1` or return true\nwhen given to `defines?/2` until another implementation is\ngiven."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.open?(module) <response> Checks if a module is open.\n\nA module is \"open\" if it is currently being defined and its attributes and\nfunctions can be modified."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.overridable?(module, tuple) <response> Returns `true` if `tuple` in `module` was marked as overridable\nat some point.\n\nNote `overridable?/2` returns true even if the definition was\nalready overridden. You can use `defines?/2` to see if a definition\nexists or one is pending."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.overridables_in(module) <response> Returns all overridable definitions in `module`.\n\nNote a definition is included even if it was was already overridden.\nYou can use `defines?/2` to see if a definition exists or one is pending.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule Example do\n      def foo, do: 1\n      def bar, do: 2\n\n      defoverridable foo: 0, bar: 0\n      def foo, do: 3\n\n      [bar: 0, foo: 0] = Module.overridables_in(__MODULE__) |> Enum.sort()\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.put_attribute(module, key, value) <response> Puts a module attribute with `key` and `value` in the given `module`.\n\n## Examples\n\n    defmodule MyModule do\n      Module.put_attribute(__MODULE__, :custom_threshold_for_lib, 10)\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.register_attribute(module, attribute, options) <response> Registers an attribute.\n\nBy registering an attribute, a developer is able to customize\nhow Elixir will store and accumulate the attribute values.\n\n## Options\n\nWhen registering an attribute, two options can be given:\n\n  * `:accumulate` - several calls to the same attribute will\n    accumulate instead of overriding the previous one. New attributes\n    are always added to the top of the accumulated list.\n\n  * `:persist` - the attribute will be persisted in the Erlang\n    Abstract Format. Useful when interfacing with Erlang libraries.\n\nBy default, both options are `false`. Once an attribute has been\nset to accumulate or persist, the behaviour cannot be reverted.\n\n## Examples\n\n    defmodule MyModule do\n      Module.register_attribute(__MODULE__, :custom_threshold_for_lib, accumulate: true)\n\n      @custom_threshold_for_lib 10\n      @custom_threshold_for_lib 20\n      @custom_threshold_for_lib #=> [20, 10]\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.reserved_attributes() <response> Returns information about module attributes used by Elixir.\n\nSee the \"Module attributes\" section in the module documentation for more\ninformation on each attribute.\n\n## Examples\n\n    iex> map = Module.reserved_attributes()\n    iex> Map.has_key?(map, :moduledoc)\n    true\n    iex> Map.has_key?(map, :doc)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.safe_concat(list) <response> Concatenates a list of aliases and returns a new alias only if the alias\nwas already referenced.\n\nIf the alias was not referenced yet, fails with `ArgumentError`.\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.safe_concat([List, Chars])\n    List.Chars"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.safe_concat(left, right) <response> Concatenates two aliases and returns a new alias only if the alias was\nalready referenced.\n\nIf the alias was not referenced yet, fails with `ArgumentError`.\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.safe_concat(List, Chars)\n    List.Chars"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.spec_to_callback(module, definition) <response> Copies the given spec as a callback.\n\nReturns `true` if there is such a spec and it was copied as a callback.\nIf the function associated to the spec has documentation defined prior to\ninvoking this function, the docs are copied too."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.split(module) <response> Splits the given module name into binary parts.\n\n`module` has to be an Elixir module, as `split/1` won't work with Erlang-style\nmodules (for example, `split(:lists)` raises an error).\n\n`split/1` also supports splitting the string representation of Elixir modules\n(that is, the result of calling `Atom.to_string/1` with the module name).\n\n## Examples\n\n    iex> Module.split(Very.Long.Module.Name.And.Even.Longer)\n    [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer\"]\n    iex> Module.split(\"Elixir.String.Chars\")\n    [\"String\", \"Chars\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> Provides functions to deal with modules during compilation time.\n\nIt allows a developer to dynamically add, delete and register\nattributes, attach documentation and so forth.\n\nAfter a module is compiled, using many of the functions in\nthis module will raise errors, since it is out of their scope\nto inspect runtime data. Most of the runtime data can be inspected\nvia the [`__info__/1`](`c:Module.__info__/1`) function attached to\neach compiled module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> Module attributes\n\nEach module can be decorated with one or more attributes. The following ones\nare currently defined by Elixir:"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@after_compile`\n\nA hook that will be invoked right after the current module is compiled.\nAccepts a module or a `{module, function_name}`. See the \"Compile callbacks\"\nsection below."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@after_verify` (since v1.14.0)\n\nA hook that will be invoked right after the current module is verified for\nundefined functions, deprecations, etc. Accepts a module or a `{module, function_name}`.\nSee the \"Compile callbacks\" section below."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@before_compile`\n\nA hook that will be invoked before the module is compiled.\nAccepts a module or a `{module, function_or_macro_name}` tuple.\nSee the \"Compile callbacks\" section below."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@behaviour`\n\nNote the British spelling!\n\nBehaviours can be referenced by modules to ensure they implement\nrequired specific function signatures defined by `@callback`.\n\nFor example, you could specify a `URI.Parser` behaviour as follows:\n\n    defmodule URI.Parser do\n      @doc \"Defines a default port\"\n      @callback default_port() :: integer\n\n      @doc \"Parses the given URL\"\n      @callback parse(uri_info :: URI.t()) :: URI.t()\n    end\n\nAnd then a module may use it as:\n\n    defmodule URI.HTTP do\n      @behaviour URI.Parser\n      def default_port(), do: 80\n      def parse(info), do: info\n    end\n\nIf the behaviour changes or `URI.HTTP` does not implement\none of the callbacks, a warning will be raised.\n\nFor detailed documentation, see the\n[behaviour typespec documentation](typespecs.md#behaviours)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@impl`\n\nTo aid in the correct implementation of behaviours, you may optionally declare\n`@impl` for implemented callbacks of a behaviour. This makes callbacks\nexplicit and can help you to catch errors in your code. The compiler will warn\nin these cases:\n\n  * if you mark a function with `@impl` when that function is not a callback.\n\n  * if you don't mark a function with `@impl` when other functions are marked\n    with `@impl`. If you mark one function with `@impl`, you must mark all\n    other callbacks for that behaviour as `@impl`.\n\n`@impl` works on a per-context basis. If you generate a function through a macro\nand mark it with `@impl`, that won't affect the module where that function is\ngenerated in.\n\n`@impl` also helps with maintainability by making it clear to other developers\nthat the function is implementing a callback.\n\nUsing `@impl`, the example above can be rewritten as:\n\n    defmodule URI.HTTP do\n      @behaviour URI.Parser\n\n      @impl true\n      def default_port(), do: 80\n\n      @impl true\n      def parse(info), do: info\n    end\n\nYou may pass either `false`, `true`, or a specific behaviour to `@impl`.\n\n    defmodule Foo do\n      @behaviour Bar\n      @behaviour Baz\n\n      # Will warn if neither Bar nor Baz specify a callback named bar/0.\n      @impl true\n      def bar(), do: :ok\n\n      # Will warn if Baz does not specify a callback named baz/0.\n      @impl Baz\n      def baz(), do: :ok\n    end\n\nThe code is now more readable, as it is now clear which functions are\npart of your API and which ones are callback implementations. To reinforce this\nidea, `@impl true` automatically marks the function as `@doc false`, disabling\ndocumentation unless `@doc` is explicitly set."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@compile`\n\nDefines options for module compilation. This is used to configure\nboth Elixir and Erlang compilers, as any other compilation pass\nadded by external tools. For example:\n\n    defmodule MyModule do\n      @compile {:inline, my_fun: 1}\n\n      def my_fun(arg) do\n        to_string(arg)\n      end\n    end\n\nMultiple uses of `@compile` will accumulate instead of overriding\nprevious ones. See the \"Compile options\" section below."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@deprecated` (since v1.6.0)\n\nProvides the deprecation reason for a function. For example:\n\n    defmodule Keyword do\n      @deprecated \"Use Kernel.length/1 instead\"\n      def size(keyword) do\n        length(keyword)\n      end\n    end\n\nThe Mix compiler automatically looks for calls to deprecated modules\nand emit warnings during compilation.\n\nUsing the `@deprecated` attribute will also be reflected in the\ndocumentation of the given function and macro. You can choose between\nthe `@deprecated` attribute and the documentation metadata to provide\nhard-deprecations (with warnings) and soft-deprecations (without warnings):\n\nThis is a soft-deprecation as it simply annotates the documentation\nas deprecated:\n\n    @doc deprecated: \"Use Kernel.length/1 instead\"\n    def size(keyword)\n\nThis is a hard-deprecation as it emits warnings and annotates the\ndocumentation as deprecated:\n\n    @deprecated \"Use Kernel.length/1 instead\"\n    def size(keyword)\n\nCurrently `@deprecated` only supports functions and macros. However\nyou can use the `:deprecated` key in the annotation metadata to\nannotate the docs of modules, types and callbacks too.\n\nWe recommend using this feature with care, especially library authors.\nDeprecating code always pushes the burden towards library users. We\nalso recommend for deprecated functionality to be maintained for long\nperiods of time, even after deprecation, giving developers plenty of\ntime to update (except for cases where keeping the deprecated API is\nundesired, such as in the presence of security issues)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@doc` and `@typedoc`\n\nProvides documentation for the entity that follows the attribute.\n`@doc` is to be used with a function, macro, callback, or\nmacrocallback, while `@typedoc` with a type (public or opaque).\n\nAccepts one of these:\n\n  * a string (often a heredoc)\n  * `false`, which will make the entity invisible to documentation-extraction\n    tools like [`ExDoc`](https://hexdocs.pm/ex_doc/)\n  * a keyword list, since Elixir 1.7.0\n\nFor example:\n\n    defmodule MyModule do\n      @typedoc \"This type\"\n      @typedoc since: \"1.1.0\"\n      @type t :: term\n\n      @doc \"Hello world\"\n      @doc since: \"1.1.0\"\n      def hello do\n        \"world\"\n      end\n\n      @doc \"\"\"\n      Sums `a` to `b`.\n      \"\"\"\n      def sum(a, b) do\n        a + b\n      end\n    end\n\nAs can be seen in the example above, since Elixir 1.7.0 `@doc` and `@typedoc`\nalso accept a keyword list that serves as a way to provide arbitrary metadata\nabout the entity. Tools like [`ExDoc`](https://hexdocs.pm/ex_doc/) and\n`IEx` may use this information to display annotations. A common use\ncase is the `:since` key, which may be used to annotate in which version the\nfunction was introduced.\n\nAs illustrated in the example, it is possible to use these attributes\nmore than once before an entity. However, the compiler will warn if\nused twice with binaries as that replaces the documentation text from\nthe preceding use. Multiple uses with keyword lists will merge the\nlists into one.\n\nNote that since the compiler also defines some additional metadata,\nthere are a few reserved keys that will be ignored and warned if used.\nCurrently these are: `:opaque` and `:defaults`.\n\nOnce this module is compiled, this information becomes available via\nthe `Code.fetch_docs/1` function."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@dialyzer`\n\nDefines warnings to request or suppress when using `:dialyzer`.\n\nAccepts an atom, a tuple, or a list of atoms and tuples. For example:\n\n    defmodule MyModule do\n      @dialyzer {:nowarn_function, my_fun: 1}\n\n      def my_fun(arg) do\n        M.not_a_function(arg)\n      end\n    end\n\nFor the list of supported warnings, see [`:dialyzer` module](`:dialyzer`).\n\nMultiple uses of `@dialyzer` will accumulate instead of overriding\nprevious ones."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@external_resource`\n\nSpecifies an external resource for the current module.\n\nSometimes a module embeds information from an external file. This\nattribute allows the module to annotate which external resources\nhave been used.\n\nTools may use this information to ensure the module is recompiled\nin case any of the external resources change, see for example:\n[`mix compile.elixir`](https://hexdocs.pm/mix/Mix.Tasks.Compile.Elixir.html).\n\nIf the external resource does not exist, the module still has\na dependency on it, causing the module to be recompiled as soon\nas the file is added."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@file`\n\nChanges the filename used in stacktraces for the function or macro that\nfollows the attribute, such as:\n\n    defmodule MyModule do\n      @doc \"Hello world\"\n      @file \"hello.ex\"\n      def hello do\n        \"world\"\n      end\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@moduledoc`\n\nProvides documentation for the current module.\n\n    defmodule MyModule do\n      @moduledoc \"\"\"\n      A very useful module.\n      \"\"\"\n      @moduledoc authors: [\"Alice\", \"Bob\"]\n    end\n\nAccepts a string (often a heredoc) or `false` where `@moduledoc false`\nwill make the module invisible to documentation extraction tools like\n[`ExDoc`](https://hexdocs.pm/ex_doc/).\n\nSimilarly to `@doc` also accepts a keyword list to provide metadata\nabout the module. For more details, see the documentation of `@doc`\nabove.\n\nOnce this module is compiled, this information becomes available via\nthe `Code.fetch_docs/1` function."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@on_definition`\n\nA hook that will be invoked when each function or macro in the current\nmodule is defined. Useful when annotating functions.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take 6 arguments:\n\n  * the module environment\n  * the kind of the function/macro: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n  * the function/macro name\n  * the list of quoted arguments\n  * the list of quoted guards\n  * the quoted function body\n\nIf the function/macro being defined has multiple clauses, the hook will\nbe called for each clause.\n\nUnlike other hooks, `@on_definition` will only invoke functions and\nnever macros. This is to avoid `@on_definition` callbacks from\nredefining functions that have just been defined in favor of more\nexplicit approaches.\n\nWhen just a module is provided, the function is assumed to be\n`__on_definition__/6`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> ## Example\n\n    defmodule Hooks do\n      def on_def(_env, kind, name, args, guards, body) do\n        IO.puts(\"Defining #{kind} named #{name} with args:\")\n        IO.inspect(args)\n        IO.puts(\"and guards\")\n        IO.inspect(guards)\n        IO.puts(\"and body\")\n        IO.puts(Macro.to_string(body))\n      end\n    end\n\n    defmodule MyModule do\n      @on_definition {Hooks, :on_def}\n\n      def hello(arg) when is_binary(arg) or is_list(arg) do\n        \"Hello\" <> to_string(arg)\n      end\n\n      def hello(_) do\n        :ok\n      end\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@on_load`\n\nA hook that will be invoked whenever the module is loaded.\n\nAccepts the function name (as an atom) of a function in the current module.\nThe function must have an arity of 0 (no arguments). If the function does\nnot return `:ok`, the loading of the module will be aborted.\nFor example:\n\n    defmodule MyModule do\n      @on_load :load_check\n\n      def load_check do\n        if some_condition() do\n          :ok\n        else\n          :abort\n        end\n      end\n\n      def some_condition do\n        false\n      end\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@vsn`\n\nSpecify the module version. Accepts any valid Elixir value, for example:\n\n    defmodule MyModule do\n      @vsn \"1.0\"\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # Struct attributes\n\n  * `@derive` - derives an implementation for the given protocol for the\n    struct defined in the current module\n\n  * `@enforce_keys` - ensures the given keys are always set when building\n    the struct defined in the current module\n\nSee `defstruct/1` for more information on building and using structs."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # Typespec attributes\n\nThe following attributes are part of typespecs and are also built-in in\nElixir:\n\n  * `@type` - defines a type to be used in `@spec`\n  * `@typep` - defines a private type to be used in `@spec`\n  * `@opaque` - defines an opaque type to be used in `@spec`\n  * `@spec` - provides a specification for a function\n  * `@callback` - provides a specification for a behaviour callback\n  * `@macrocallback` - provides a specification for a macro behaviour callback\n  * `@optional_callbacks` - specifies which behaviour callbacks and macro\n    behaviour callbacks are optional\n  * `@impl` - declares an implementation of a callback function or macro\n\nFor detailed documentation, see the [typespec documentation](typespecs.md)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # Custom attributes\n\nIn addition to the built-in attributes outlined above, custom attributes may\nalso be added. Custom attributes are expressed using the `@/1` operator followed\nby a valid variable name. The value given to the custom attribute must be a valid\nElixir value:\n\n    defmodule MyModule do\n      @custom_attr [some: \"stuff\"]\n    end\n\nFor more advanced options available when defining custom attributes, see\n`register_attribute/3`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> Compile callbacks\n\nThere are three compilation callbacks, invoked in this order:\n`@before_compile`, `@after_compile`, and `@after_verify`.\nThey are described next."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@before_compile`\n\nA hook that will be invoked before the module is compiled. This is\noften used to change how the current module is being compiled.\n\nAccepts a module or a `{module, function_or_macro_name}` tuple. The\nfunction/macro must take one argument: the module environment. If\nit's a macro, its returned value will be injected at the end of the\nmodule definition before the compilation starts.\n\nWhen just a module is provided, the function/macro is assumed to be\n`__before_compile__/1`.\n\nCallbacks will run in the order they are registered. Any overridable\ndefinition will be made concrete before the first callback runs.\nA definition may be made overridable again in another before compile\ncallback and it will be made concrete one last time after all callbacks\nrun.\n\n*Note*: the callback function/macro must be placed in a separate module\n(because when the callback is invoked, the current module does not yet exist)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> ## Example\n\n    defmodule A do\n      defmacro __before_compile__(_env) do\n        quote do\n          def hello, do: \"world\"\n        end\n      end\n    end\n\n    defmodule B do\n      @before_compile A\n    end\n\n    B.hello()\n    #=> \"world\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@after_compile`\n\nA hook that will be invoked right after the current module is compiled.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take two arguments: the module environment and its bytecode.\nWhen just a module is provided, the function is assumed to be\n`__after_compile__/2`.\n\nCallbacks will run in the order they are registered.\n\n`Module` functions expecting not yet compiled modules (such as `definitions_in/1`)\nare still available at the time `@after_compile` is invoked."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> ## Example\n\n    defmodule MyModule do\n      @after_compile __MODULE__\n\n      def __after_compile__(env, _bytecode) do\n        IO.inspect(env)\n      end\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> # `@after_verify`\n\nA hook that will be invoked right after the current module is verified for\nundefined functions, deprecations, etc. A module is always verified after\nit is compiled. In Mix projects, a module is also verified when any of its\nruntime dependencies change. Therefore this is useful to perform verification\nof the current module while avoiding compile-time dependencies.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take one argument: the module name. When just a module is provided,\nthe function is assumed to be `__after_verify__/2`.\n\nCallbacks will run in the order they are registered.\n\n`Module` functions expecting not yet compiled modules are no longer available\nat the time `@after_verify` is invoked."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> ## Example\n\n    defmodule MyModule do\n      @after_verify __MODULE__\n\n      def __after_verify__(module) do\n        IO.inspect(module)\n        :ok\n      end\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Module.Elixir.Module <response> Compile options\n\nThe `@compile` attribute accepts different options that are used by both\nElixir and Erlang compilers. Some of the common use cases are documented\nbelow:\n\n  * `@compile :debug_info` - includes `:debug_info` regardless of the\n    corresponding setting in `Code.get_compiler_option/1`\n\n  * `@compile {:debug_info, false}` - disables `:debug_info` regardless\n    of the corresponding setting in `Code.get_compiler_option/1`. Note\n    disabling `:debug_info` is not recommended as it removes the ability\n    of the Elixir compiler and other tools to static analyse the code.\n    If you want to remove the `:debug_info` while deploying, tools like\n    `mix release` already do such by default.\n\n  * `@compile {:inline, some_fun: 2, other_fun: 3}` - inlines the given\n    name/arity pairs. Inlining is applied locally, calls from another\n    module are not affected by this option\n\n  * `@compile {:autoload, false}` - disables automatic loading of\n    modules after compilation. Instead, the module will be loaded after\n    it is dispatched to\n\n  * `@compile {:no_warn_undefined, Mod}` or\n    `@compile {:no_warn_undefined, {Mod, fun, arity}}` - does not warn if\n    the given module or the given `Mod.fun/arity` are not defined"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.add(naive_datetime, amount_to_add, unit \\\\ :second) <response> Adds a specified amount of time to a `NaiveDateTime`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\n## Examples\n\nIt uses seconds by default:\n\n    # adds seconds by default\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2)\n    ~N[2014-10-02 00:29:12]\n\n    # accepts negative offsets\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], -2)\n    ~N[2014-10-02 00:29:08]\n\nIt can also work with subsecond precisions:\n\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2_000, :millisecond)\n    ~N[2014-10-02 00:29:12.000]\n\nAs well as days/hours/minutes:\n\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 2, :day)\n    ~N[2015-03-02 00:29:10]\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 36, :hour)\n    ~N[2015-03-01 12:29:10]\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 60, :minute)\n    ~N[2015-02-28 01:29:10]\n\nThis operation merges the precision of the naive date time with the given unit:\n\n    iex> result = NaiveDateTime.add(~N[2014-10-02 00:29:10], 21, :millisecond)\n    ~N[2014-10-02 00:29:10.021]\n    iex> result.microsecond\n    {21000, 3}\n\nOperations on top of gregorian seconds or the Unix epoch are optimized:\n\n    # from Gregorian seconds\n    iex> NaiveDateTime.add(~N[0000-01-01 00:00:00], 63_579_428_950)\n    ~N[2014-10-02 00:29:10]\n\nPassing a `DateTime` automatically converts it to `NaiveDateTime`,\ndiscarding the time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.add(dt, 21, :second)\n    ~N[2000-02-29 23:00:28]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.compare(naive_datetime1, naive_datetime2) <response> Compares two `NaiveDateTime` structs.\n\nReturns `:gt` if first is later than the second\nand `:lt` for vice versa. If the two NaiveDateTime\nare equal `:eq` is returned.\n\n## Examples\n\n    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15], ~N[2016-04-28 16:19:25])\n    :lt\n    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15.1], ~N[2016-04-16 13:30:15.01])\n    :gt\n\nThis function can also be used to compare a DateTime without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.compare(dt, ~N[2000-02-29 23:00:07])\n    :eq\n    iex> NaiveDateTime.compare(dt, ~N[2000-01-29 23:00:07])\n    :gt\n    iex> NaiveDateTime.compare(dt, ~N[2000-03-29 23:00:07])\n    :lt"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.convert(naive_datetime, calendar) <response> Converts the given `naive_datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an `{:error, :incompatible_calendars}` tuple\nis returned.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> NaiveDateTime.convert(~N[2000-01-01 13:30:15], Calendar.Holocene)\n    {:ok, %NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,\n                         hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.convert!(naive_datetime, calendar) <response> Converts the given `naive_datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an ArgumentError is raised.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> NaiveDateTime.convert!(~N[2000-01-01 13:30:15], Calendar.Holocene)\n    %NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,\n                   hour: 13, minute: 30, second: 15, microsecond: {0, 0}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.diff(naive_datetime1, naive_datetime2, unit \\\\ :second) <response> Subtracts `naive_datetime2` from `naive_datetime1`.\n\nThe answer can be returned in any `:day`, `:hour`, `:minute`, or any `unit`\navailable from `t:System.time_unit/0`. The unit is measured according to\n`Calendar.ISO` and defaults to `:second`.\n\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10])\n    2\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10], :microsecond)\n    2_000_000\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021])\n    0\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021], :millisecond)\n    21\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10], ~N[2014-10-02 00:29:12])\n    -2\n    iex> NaiveDateTime.diff(~N[-0001-10-02 00:29:10], ~N[-0001-10-02 00:29:12])\n    -2\n\nIt can also compute the difference in days, hours, or minutes:\n\n    iex> NaiveDateTime.diff(~N[2014-10-10 00:29:10], ~N[2014-10-02 00:29:10], :day)\n    8\n    iex> NaiveDateTime.diff(~N[2014-10-02 12:29:10], ~N[2014-10-02 00:29:10], :hour)\n    12\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:39:10], ~N[2014-10-02 00:29:10], :minute)\n    10\n\nBut it also rounds incomplete days to zero:\n\n    iex> NaiveDateTime.diff(~N[2014-10-10 00:29:09], ~N[2014-10-02 00:29:10], :day)\n    7"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.from_erl(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n\nAttempting to convert an invalid ISO calendar date will produce an error tuple.\n\n## Examples\n\n    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}})\n    {:ok, ~N[2000-01-01 13:30:15]}\n    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n    {:ok, ~N[2000-01-01 13:30:15.005]}\n    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n    {:error, :invalid_date}\n    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n    {:error, :invalid_date}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.from_erl!(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n\nRaises if the datetime is invalid.\nAttempting to convert an invalid ISO calendar date will produce an error tuple.\n\n## Examples\n\n    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}})\n    ~N[2000-01-01 13:30:15]\n    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n    ~N[2000-01-01 13:30:15.005]\n    iex> NaiveDateTime.from_erl!({{2000, 13, 1}, {13, 30, 15}})\n    ** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive datetime, reason: :invalid_date"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.from_gregorian_seconds(seconds, arg \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Converts a number of gregorian seconds to a `NaiveDateTime` struct.\n\n## Examples\n\n    iex> NaiveDateTime.from_gregorian_seconds(1)\n    ~N[0000-01-01 00:00:01]\n    iex> NaiveDateTime.from_gregorian_seconds(63_755_511_991, {5000, 3})\n    ~N[2020-05-01 00:26:31.005]\n    iex> NaiveDateTime.from_gregorian_seconds(-1)\n    ~N[-0001-12-31 23:59:59]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.from_iso8601(string, calendar \\\\ Calendar.ISO) <response> Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nTime zone offset may be included in the string but they will be\nsimply discarded as such information is not included in naive date\ntimes.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\nNote leap seconds are not supported by the built-in Calendar.ISO.\n\n## Examples\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0\")\n    {:ok, ~N[2015-01-23 23:50:07.0]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07,0123456\")\n    {:ok, ~N[2015-01-23 23:50:07.012345]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0123456\")\n    {:ok, ~N[2015-01-23 23:50:07.012345]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123Z\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23P23:50:07\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015:01:23 23-50-07\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:61\")\n    {:error, :invalid_time}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-32 23:50:07\")\n    {:error, :invalid_date}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+00:00\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-02:30\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-24:00\")\n    {:error, :invalid_format}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.from_iso8601!(string, calendar \\\\ Calendar.ISO) <response> Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07.123Z\")\n    ~N[2015-01-23 23:50:07.123]\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07,123Z\")\n    ~N[2015-01-23 23:50:07.123]\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23P23:50:07\")\n    ** (ArgumentError) cannot parse \"2015-01-23P23:50:07\" as naive datetime, reason: :invalid_format"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.local_now(calendar \\\\ Calendar.ISO) <response> Returns the \"local time\" for the machine the Elixir program is running on.\n\nWARNING: This function can cause insidious bugs. It depends on the time zone\nconfiguration at run time. This can changed and be set to a time zone that has\ndaylight saving jumps (spring forward or fall back).\n\nThis function can be used to display what the time is right now for the time\nzone configuration that the machine happens to have. An example would be a\ndesktop program displaying a clock to the user. For any other uses it is\nprobably a bad idea to use this function.\n\nFor most cases, use `DateTime.now/2` or `DateTime.utc_now/1` instead.\n\nDoes not include fractional seconds.\n\n## Examples\n\n    iex> naive_datetime = NaiveDateTime.local_now()\n    iex> naive_datetime.year >= 2019\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.new(date, time) <response> Builds a naive datetime from date and time structs.\n\n## Examples\n\n    iex> NaiveDateTime.new(~D[2010-01-13], ~T[23:00:07.005])\n    {:ok, ~N[2010-01-13 23:00:07.005]}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.new(year, month, day, hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Builds a new ISO naive datetime.\n\nExpects all values to be integers. Returns `{:ok, naive_datetime}`\nif each entry fits its appropriate range, returns `{:error, reason}`\notherwise.\n\n## Examples\n\n    iex> NaiveDateTime.new(2000, 1, 1, 0, 0, 0)\n    {:ok, ~N[2000-01-01 00:00:00]}\n    iex> NaiveDateTime.new(2000, 13, 1, 0, 0, 0)\n    {:error, :invalid_date}\n    iex> NaiveDateTime.new(2000, 2, 29, 0, 0, 0)\n    {:ok, ~N[2000-02-29 00:00:00]}\n    iex> NaiveDateTime.new(2000, 2, 30, 0, 0, 0)\n    {:error, :invalid_date}\n    iex> NaiveDateTime.new(2001, 2, 29, 0, 0, 0)\n    {:error, :invalid_date}\n\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1})\n    {:ok, ~N[2000-01-01 23:59:59.0]}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 999_999)\n    {:ok, ~N[2000-01-01 23:59:59.999999]}\n    iex> NaiveDateTime.new(2000, 1, 1, 24, 59, 59, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 60, 59, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 60, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 1_000_000)\n    {:error, :invalid_time}\n\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)\n    {:ok, ~N[2000-01-01 23:59:59.0]}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.new!(date, time) <response> Builds a naive datetime from date and time structs.\n\n## Examples\n\n    iex> NaiveDateTime.new!(~D[2010-01-13], ~T[23:00:07.005])\n    ~N[2010-01-13 23:00:07.005]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.new!(year, month, day, hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Builds a new ISO naive datetime.\n\nExpects all values to be integers. Returns `naive_datetime`\nif each entry fits its appropriate range, raises if\ntime or date is invalid.\n\n## Examples\n\n    iex> NaiveDateTime.new!(2000, 1, 1, 0, 0, 0)\n    ~N[2000-01-01 00:00:00]\n    iex> NaiveDateTime.new!(2000, 2, 29, 0, 0, 0)\n    ~N[2000-02-29 00:00:00]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1})\n    ~N[2000-01-01 23:59:59.0]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, 999_999)\n    ~N[2000-01-01 23:59:59.999999]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)\n    ~N[2000-01-01 23:59:59.0]\n    iex> NaiveDateTime.new!(2000, 1, 1, 24, 59, 59, 999_999)\n    ** (ArgumentError) cannot build naive datetime, reason: :invalid_time"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.to_date(map) <response> Converts a `NaiveDateTime` into a `Date`.\n\nBecause `Date` does not hold time information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> NaiveDateTime.to_date(~N[2002-01-13 23:00:07])\n    ~D[2002-01-13]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.to_erl(naive_datetime) <response> Converts a `NaiveDateTime` struct to an Erlang datetime tuple.\n\nOnly supports converting naive datetimes which are in the ISO calendar,\nattempting to convert naive datetimes from other calendars will raise.\n\nWARNING: Loss of precision may occur, as Erlang time tuples only store\nhour/minute/second.\n\n## Examples\n\n    iex> NaiveDateTime.to_erl(~N[2000-01-01 13:30:15])\n    {{2000, 1, 1}, {13, 30, 15}}\n\nThis function can also be used to convert a DateTime to an Erlang\ndatetime tuple without the time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_erl(dt)\n    {{2000, 2, 29}, {23, 00, 07}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.to_gregorian_seconds(map) <response> Converts a `NaiveDateTime` struct to a number of gregorian seconds and microseconds.\n\n## Examples\n\n    iex> NaiveDateTime.to_gregorian_seconds(~N[0000-01-01 00:00:01])\n    {1, 0}\n    iex> NaiveDateTime.to_gregorian_seconds(~N[2020-05-01 00:26:31.005])\n    {63_755_511_991, 5000}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.to_iso8601(naive_datetime, format \\\\ :extended) <response> Converts the given naive datetime to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `NaiveDateTime.to_iso8601/2` returns naive datetimes formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting naive datetimes which are in the ISO calendar,\nattempting to convert naive datetimes from other calendars will raise.\n\n### Examples\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13])\n    \"2000-02-28T23:00:13\"\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001])\n    \"2000-02-28T23:00:13.001\"\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001], :basic)\n    \"20000228T230013.001\"\n\nThis function can also be used to convert a DateTime to ISO 8601 without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.to_string(naive_datetime) <response> Converts the given naive datetime to a string according to its calendar.\n\n### Examples\n\n    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13])\n    \"2000-02-28 23:00:13\"\n    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13.001])\n    \"2000-02-28 23:00:13.001\"\n    iex> NaiveDateTime.to_string(~N[-0100-12-15 03:20:31])\n    \"-0100-12-15 03:20:31\"\n\nThis function can also be used to convert a DateTime to a string without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_string(dt)\n    \"2000-02-29 23:00:07\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.to_time(map) <response> Converts a `NaiveDateTime` into `Time`.\n\nBecause `Time` does not hold date information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> NaiveDateTime.to_time(~N[2002-01-13 23:00:07])\n    ~T[23:00:07]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.truncate(naive_datetime, precision) <response> Returns the given naive datetime with the microsecond field truncated to the\ngiven precision (`:microsecond`, `:millisecond` or `:second`).\n\nThe given naive datetime is returned unchanged if it already has lower precision\nthan the given precision.\n\n## Examples\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :microsecond)\n    ~N[2017-11-06 00:23:51.123456]\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :millisecond)\n    ~N[2017-11-06 00:23:51.123]\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :second)\n    ~N[2017-11-06 00:23:51]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.utc_now(calendar \\\\ Calendar.ISO) <response> Returns the current naive datetime in UTC.\n\nPrefer using `DateTime.utc_now/0` when possible as, opposite\nto `NaiveDateTime`, it will keep the time zone information.\n\n## Examples\n\n    iex> naive_datetime = NaiveDateTime.utc_now()\n    iex> naive_datetime.year >= 2016\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.Elixir.NaiveDateTime <response> A NaiveDateTime struct (without a time zone) and functions.\n\nThe NaiveDateTime struct contains the fields year, month, day, hour,\nminute, second, microsecond and calendar. New naive datetimes can be\nbuilt with the `new/2` and `new/8` functions or using the\n`~N` (see `sigil_N/2`) sigil:\n\n    iex> ~N[2000-01-01 23:00:07]\n    ~N[2000-01-01 23:00:07]\n\nThe date and time fields in the struct can be accessed directly:\n\n    iex> naive = ~N[2000-01-01 23:00:07]\n    iex> naive.year\n    2000\n    iex> naive.second\n    7\n\nWe call them \"naive\" because this datetime representation does not\nhave a time zone. This means the datetime may not actually exist in\ncertain areas in the world even though it is valid.\n\nFor example, when daylight saving changes are applied by a region,\nthe clock typically moves forward or backward by one hour. This means\ncertain datetimes never occur or may occur more than once. Since\n`NaiveDateTime` is not validated against a time zone, such errors\nwould go unnoticed.\n\nDevelopers should avoid creating the NaiveDateTime structs directly\nand instead, rely on the functions provided by this module as well\nas the ones in third-party calendar libraries."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.Elixir.NaiveDateTime <response> Comparing naive date times\n\nComparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `NaiveDateTime` struct fields. For proper comparison\nbetween naive datetimes, use the `compare/2` function. The existence of the\n`compare/2` function in this module also allows using `Enum.min/2` and\n`Enum.max/2` functions to get the minimum and maximum naive datetime of an\n`Enum`. For example:\n\n    iex> Enum.min([~N[2020-01-01 23:00:07], ~N[2000-01-01 23:00:07]], NaiveDateTime)\n    ~N[2000-01-01 23:00:07]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.NaiveDateTime.Elixir.NaiveDateTime <response> Using epochs\n\nThe `add/3` and `diff/3` functions can be used for computing date\ntimes or retrieving the number of seconds between instants.\nFor example, if there is an interest in computing the number of\nseconds from the Unix epoch (1970-01-01 00:00:00):\n\n    iex> NaiveDateTime.diff(~N[2010-04-17 14:00:00], ~N[1970-01-01 00:00:00])\n    1271512800\n\n    iex> NaiveDateTime.add(~N[1970-01-01 00:00:00], 1_271_512_800)\n    ~N[2010-04-17 14:00:00]\n\nThose functions are optimized to deal with common epochs, such\nas the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.alive?() <response> Returns `true` if the local node is alive.\n\nThat is, if the node can be part of a distributed system."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.connect(node) <response> Establishes a connection to `node`.\n\nReturns `true` if successful, `false` if not, and the atom\n`:ignored` if the local node is not alive.\n\nFor more information, see `:net_kernel.connect_node/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.disconnect(node) <response> Forces the disconnection of a node.\n\nThis will appear to the `node` as if the local node has crashed.\nThis function is mainly used in the Erlang network authentication\nprotocols. Returns `true` if disconnection succeeds, otherwise `false`.\nIf the local node is not alive, the function returns `:ignored`.\n\nFor more information, see `:erlang.disconnect_node/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.get_cookie() <response> Returns the magic cookie of the local node.\n\nReturns the cookie if the node is alive, otherwise `:nocookie`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.list() <response> Returns a list of all visible nodes in the system, excluding\nthe local node.\n\nSame as `list(:visible)`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.list(args) <response> Returns a list of nodes according to argument given.\n\nThe result returned when the argument is a list, is the list of nodes\nsatisfying the disjunction(s) of the list elements.\n\nFor more information, see `:erlang.nodes/1`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.monitor(node, flag) <response> Monitors the status of the node.\n\nIf `flag` is `true`, monitoring is turned on.\nIf `flag` is `false`, monitoring is turned off.\n\nFor more information, see `:erlang.monitor_node/2`.\n\nFor monitoring status changes of all nodes, see `:net_kernel.monitor_nodes/2`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.monitor(node, flag, options) <response> Behaves as `monitor/2` except that it allows an extra\noption to be given, namely `:allow_passive_connect`.\n\nFor more information, see `:erlang.monitor_node/3`.\n\nFor monitoring status changes of all nodes, see `:net_kernel.monitor_nodes/2`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.ping(node) <response> Tries to set up a connection to node.\n\nReturns `:pang` if it fails, or `:pong` if it is successful.\n\n## Examples\n\n    iex> Node.ping(:unknown_node)\n    :pang"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.self() <response> Returns the current node.\n\nIt returns the same as the built-in `node()`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.set_cookie(node \\\\ Node.self(), cookie) <response> Sets the magic cookie of `node` to the atom `cookie`.\n\nThe default node is `Node.self/0`, the local node. If `node` is the local node,\nthe function also sets the cookie of all other unknown nodes to `cookie`.\n\nThis function will raise `FunctionClauseError` if the given `node` is not alive."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.spawn(node, fun) <response> Returns the PID of a new process started by the application of `fun`\non `node`. If `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/2`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.spawn(node, fun, opts) <response> Returns the PID of a new process started by the application of `fun`\non `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn_opt/3`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.spawn(node, module, fun, args) <response> Returns the PID of a new process started by the application of\n`module.function(args)` on `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/4`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.spawn(node, module, fun, args, opts) <response> Returns the PID of a new process started by the application of\n`module.function(args)` on `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/4`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.spawn_link(node, fun) <response> Returns the PID of a new linked process started by the application of `fun` on `node`.\n\nA link is created between the calling process and the new process, atomically.\nIf `node` does not exist, a useless PID is returned (and due to the link, an exit\nsignal with exit reason `:noconnection` will be received).\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.spawn_link(node, module, fun, args) <response> Returns the PID of a new linked process started by the application of\n`module.function(args)` on `node`.\n\nA link is created between the calling process and the new process, atomically.\nIf `node` does not exist, a useless PID is returned (and due to the link, an exit\nsignal with exit reason `:noconnection` will be received).\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.spawn_monitor(node, fun) <response> Spawns the given function on a node, monitors it and returns its PID\nand monitoring reference.\n\nThis functionality was added on Erlang/OTP 23. Using this function to\ncommunicate with nodes running on earlier versions will fail.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.spawn_monitor(node, module, fun, args) <response> Spawns the given module and function passing the given args on a node,\nmonitors it and returns its PID and monitoring reference.\n\nThis functionality was added on Erlang/OTP 23. Using this function\nto communicate with nodes running on earlier versions will fail.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.start(name, type \\\\ :longnames, tick_time \\\\ 15000) <response> Turns a non-distributed node into a distributed node.\n\nThis functionality starts the `:net_kernel` and other related\nprocesses.\n\nThis function is rarely invoked in practice. Instead, nodes are\nnamed and started via the command line by using the `--sname` and\n`--name` flags. If you need to use this function to dynamically\nname a node, please make sure the `epmd` operating system process\nis running by calling `epmd -daemon`.\n\nInvoking this function when the distribution has already been started,\neither via the command line interface or dynamically, will return an\nerror.\n\n## Examples\n\n    {:ok, pid} = Node.start(:example, :shortnames, 15000)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.stop() <response> Turns a distributed node into a non-distributed node.\n\nFor other nodes in the network, this is the same as the node going down.\nOnly possible when the node was started with `Node.start/3`, otherwise\nreturns `{:error, :not_allowed}`. Returns `{:error, :not_found}` if the\nlocal node is not alive."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Node.Elixir.Node <response> Functions related to VM nodes.\n\nSome of the functions in this module are inlined by the compiler,\nsimilar to functions in the `Kernel` module and they are explicitly\nmarked in their docs as \"inlined by the compiler\". For more information\nabout inlined functions, check out the `Kernel` module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.OptionParser.next(argv, opts \\\\ []) <response> Low-level function that parses one option.\n\nIt accepts the same options as `parse/2` and `parse_head/2`\nas both functions are built on top of this function. This function\nmay return:\n\n  * `{:ok, key, value, rest}` - the option `key` with `value` was\n    successfully parsed\n\n  * `{:invalid, key, value, rest}` - the option `key` is invalid with `value`\n    (returned when the value cannot be parsed according to the switch type)\n\n  * `{:undefined, key, value, rest}` - the option `key` is undefined\n    (returned in strict mode when the switch is unknown or on nonexistent atoms)\n\n  * `{:error, rest}` - there are no switches at the head of the given `argv`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.OptionParser.parse(argv, opts \\\\ []) <response> Parses `argv` into a keyword list.\n\nIt returns a three-element tuple with the form `{parsed, args, invalid}`, where:\n\n  * `parsed` is a keyword list of parsed switches with `{switch_name, value}`\n    tuples in it; `switch_name` is the atom representing the switch name while\n    `value` is the value for that switch parsed according to `opts` (see the\n    \"Examples\" section for more information)\n  * `args` is a list of the remaining arguments in `argv` as strings\n  * `invalid` is a list of invalid options as `{option_name, value}` where\n    `option_name` is the raw option and `value` is `nil` if the option wasn't\n    expected or the string value if the value didn't have the expected type for\n    the corresponding option\n\nElixir converts switches to underscored atoms, so `--source-path` becomes\n`:source_path`. This is done to better suit Elixir conventions. However, this\nmeans that switches can't contain underscores and switches that do contain\nunderscores are always returned in the list of invalid switches.\n\nWhen parsing, it is common to list switches and their expected types:\n\n    iex> OptionParser.parse([\"--debug\"], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n    iex> OptionParser.parse([\"--source\", \"lib\"], strict: [source: :string])\n    {[source: \"lib\"], [], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--source-path\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   strict: [source_path: :string, verbose: :boolean]\n    ...> )\n    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n\nWe will explore the valid switches and operation modes of option parser below.\n\n## Options\n\nThe following options are supported:\n\n  * `:switches` or `:strict` - see the \"Switch definitions\" section below\n  * `:allow_nonexistent_atoms` - see the \"Parsing unknown switches\" section below\n  * `:aliases` - see the \"Aliases\" section below\n\n## Switch definitions\n\nSwitches can be specified via one of two options:\n\n  * `:strict` - defines strict switches and their types. Any switch\n    in `argv` that is not specified in the list is returned in the\n    invalid options list. This is the preferred way to parse options.\n\n  * `:switches` - defines switches and their types. This function\n    still attempts to parse switches that are not in this list.\n\nBoth these options accept a keyword list where the key is an atom\ndefining the name of the switch and value is the `type` of the\nswitch (see the \"Types\" section below for more information).\n\nNote that you should only supply the `:switches` or the `:strict` option.\nIf you supply both, an `ArgumentError` exception will be raised.\n\n### Types\n\nSwitches parsed by `OptionParser` may take zero or one arguments.\n\nThe following switches types take no arguments:\n\n  * `:boolean` - sets the value to `true` when given (see also the\n    \"Negation switches\" section below)\n  * `:count` - counts the number of times the switch is given\n\nThe following switches take one argument:\n\n  * `:integer` - parses the value as an integer\n  * `:float` - parses the value as a float\n  * `:string` - parses the value as a string\n\nIf a switch can't be parsed according to the given type, it is\nreturned in the invalid options list.\n\n### Modifiers\n\nSwitches can be specified with modifiers, which change how\nthey behave. The following modifiers are supported:\n\n  * `:keep` - keeps duplicated elements instead of overriding them;\n    works with all types except `:count`. Specifying `switch_name: :keep`\n    assumes the type of `:switch_name` will be `:string`.\n\nTo use `:keep` with a type other than `:string`, use a list as the type\nfor the switch. For example: `[foo: [:integer, :keep]]`.\n\n### Negation switches\n\nIn case a switch `SWITCH` is specified to have type `:boolean`, it may be\npassed as `--no-SWITCH` as well which will set the option to `false`:\n\n    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :boolean])\n    {[op: false], [\"path/to/file\"], []}\n\n### Parsing unknown switches\n\nWhen the `:switches` option is given, `OptionParser` will attempt to parse\nunknown switches:\n\n    iex> OptionParser.parse([\"--debug\"], switches: [key: :string])\n    {[debug: true], [], []}\n\nEven though we haven't specified `--debug` in the list of switches, it is part\nof the returned options. This would also work:\n\n    iex> OptionParser.parse([\"--debug\", \"value\"], switches: [key: :string])\n    {[debug: \"value\"], [], []}\n\nSwitches followed by a value will be assigned the value, as a string. Switches\nwithout an argument will be set automatically to `true`. Since we cannot assert\nthe type of the switch value, it is preferred to use the `:strict` option that\naccepts only known switches and always verify their types.\n\nIf you do want to parse unknown switches, remember that Elixir converts switches\nto atoms. Since atoms are not garbage-collected, OptionParser will only parse\nswitches that translate to atoms used by the runtime to avoid leaking atoms.\nFor instance, the code below will discard the `--option-parser-example` switch\nbecause the `:option_parser_example` atom is never used anywhere:\n\n    OptionParser.parse([\"--option-parser-example\"], switches: [debug: :boolean])\n    # The :option_parser_example atom is not used anywhere below\n\nHowever, the code below would work as long as `:option_parser_example` atom is\nused at some point later (or earlier) **in the same module**. For example:\n\n    {opts, _, _} = OptionParser.parse([\"--option-parser-example\"], switches: [debug: :boolean])\n    # ... then somewhere in the same module you access it ...\n    opts[:option_parser_example]\n\nIn other words, Elixir will only parse options that are used by the runtime,\nignoring all others. If you would like to parse all switches, regardless if\nthey exist or not, you can force creation of atoms by passing\n`allow_nonexistent_atoms: true` as option. Use this option with care. It is\nonly useful when you are building command-line applications that receive\ndynamically-named arguments and must be avoided in long-running systems.\n\n## Aliases\n\nA set of aliases can be specified in the `:aliases` option:\n\n    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n## Examples\n\nHere are some examples of working with different types and modifiers:\n\n    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: [unlock: :boolean])\n    {[unlock: true], [\"path/to/file\"], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--unlock\", \"--limit\", \"0\", \"path/to/file\"],\n    ...>   strict: [unlock: :boolean, limit: :integer]\n    ...> )\n    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n\n    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :integer])\n    {[limit: 3], [], []}\n\n    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :integer])\n    {[], [], [{\"--limit\", \"xyz\"}]}\n\n    iex> OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n    {[verbose: 1], [], []}\n\n    iex> OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], strict: [verbose: :count])\n    {[verbose: 2], [], []}\n\n    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n\n    iex> OptionParser.parse(\n    ...>   [\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n    ...>   switches: [limit: :integer]\n    ...> )\n    {[limit: 3, unknown: \"xyz\"], [], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--unlock\", \"path/to/file\", \"--unlock\", \"path/to/another/file\"],\n    ...>   strict: [unlock: :keep]\n    ...> )\n    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.OptionParser.parse!(argv, opts \\\\ []) <response> The same as `parse/2` but raises an `OptionParser.ParseError`\nexception if any invalid options are given.\n\nIf there are no errors, returns a `{parsed, rest}` tuple where:\n\n  * `parsed` is the list of parsed switches (same as in `parse/2`)\n  * `rest` is the list of arguments (same as in `parse/2`)\n\n## Examples\n\n    iex> OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: [debug: :boolean])\n    {[debug: true], [\"path/to/file\"]}\n\n    iex> OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :integer])\n    ** (OptionParser.ParseError) 1 error found!\n    --limit : Expected type integer, got \"xyz\"\n\n    iex> OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n    ** (OptionParser.ParseError) 1 error found!\n    --unknown : Unknown option\n\n    iex> OptionParser.parse!(\n    ...>   [\"-l\", \"xyz\", \"-f\", \"bar\"],\n    ...>   switches: [limit: :integer, foo: :integer],\n    ...>   aliases: [l: :limit, f: :foo]\n    ...> )\n    ** (OptionParser.ParseError) 2 errors found!\n    -l : Expected type integer, got \"xyz\"\n    -f : Expected type integer, got \"bar\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.OptionParser.parse_head(argv, opts \\\\ []) <response> Similar to `parse/2` but only parses the head of `argv`;\nas soon as it finds a non-switch, it stops parsing.\n\nSee `parse/2` for more information.\n\n## Example\n\n    iex> OptionParser.parse_head(\n    ...>   [\"--source\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   switches: [source: :string, verbose: :boolean]\n    ...> )\n    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n\n    iex> OptionParser.parse_head(\n    ...>   [\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n    ...>   switches: [source: :string, verbose: :boolean, unlock: :boolean]\n    ...> )\n    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock\"], []}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.OptionParser.parse_head!(argv, opts \\\\ []) <response> The same as `parse_head/2` but raises an `OptionParser.ParseError`\nexception if any invalid options are given.\n\nIf there are no errors, returns a `{parsed, rest}` tuple where:\n\n  * `parsed` is the list of parsed switches (same as in `parse_head/2`)\n  * `rest` is the list of arguments (same as in `parse_head/2`)\n\n## Examples\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--source\", \"lib\", \"path/to/file\", \"--verbose\"],\n    ...>   switches: [source: :string, verbose: :boolean]\n    ...> )\n    {[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--number\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   strict: [number: :integer]\n    ...> )\n    ** (OptionParser.ParseError) 1 error found!\n    --number : Expected type integer, got \"lib\"\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n    ...>   strict: [verbose: :integer, source: :integer]\n    ...> )\n    ** (OptionParser.ParseError) 2 errors found!\n    --verbose : Missing argument of type integer\n    --source : Expected type integer, got \"lib\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.OptionParser.split(string) <response> Splits a string into `t:argv/0` chunks.\n\nThis function splits the given `string` into a list of strings in a similar\nway to many shells.\n\n## Examples\n\n    iex> OptionParser.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n    [\"foo\", \"bar baz\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.OptionParser.to_argv(enum, options \\\\ []) <response> Receives a key-value enumerable and converts it to `t:argv/0`.\n\nKeys must be atoms. Keys with `nil` value are discarded,\nboolean values are converted to `--key` or `--no-key`\n(if the value is `true` or `false`, respectively),\nand all other values are converted using `to_string/1`.\n\nIt is advised to pass to `to_argv/2` the same set of `options`\ngiven to `parse/2`. Some switches can only be reconstructed\ncorrectly with the `:switches` information in hand.\n\n## Examples\n\n    iex> OptionParser.to_argv(foo_bar: \"baz\")\n    [\"--foo-bar\", \"baz\"]\n    iex> OptionParser.to_argv(bool: true, bool: false, discarded: nil)\n    [\"--bool\", \"--no-bool\"]\n\nSome switches will output different values based on the switches\ntypes:\n\n    iex> OptionParser.to_argv([number: 2], switches: [])\n    [\"--number\", \"2\"]\n    iex> OptionParser.to_argv([number: 2], switches: [number: :count])\n    [\"--number\", \"--number\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.OptionParser.Elixir.OptionParser <response> Functions for parsing command line arguments.\n\nWhen calling a command, it's possible to pass command line options\nto modify what the command does. In this documentation, those are\ncalled \"switches\", in other situations they may be called \"flags\"\nor simply \"options\". A switch can be given a value, also called an\n\"argument\".\n\nThe main function in this module is `parse/2`, which parses a list\nof command line options and arguments into a keyword list:\n\n    iex> OptionParser.parse([\"--debug\"], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n`OptionParser` provides some conveniences out of the box,\nsuch as aliases and automatic handling of negation switches.\n\nThe `parse_head/2` function is an alternative to `parse/2`\nwhich stops parsing as soon as it finds a value that is not\na switch nor a value for a previous switch.\n\nThis module also provides low-level functions, such as `next/2`,\nfor parsing switches manually, as well as `split/1` and `to_argv/1`\nfor parsing from and converting switches to strings."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.PartitionSupervisor.count_children(supervisor) <response> Returns a map containing count values for the supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the number of partitions (children processes)\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not the child\n    process is still alive\n\n  * `:workers` - the count of all workers, whether or not the child process\n    is still alive"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.PartitionSupervisor.partitions(name) <response> Returns the number of partitions for the partition supervisor."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.PartitionSupervisor.start_link(opts) <response> Starts a partition supervisor with the given options.\n\nThis function is typically not invoked directly, instead it is invoked\nwhen using a `PartitionSupervisor` as a child of another supervisor:\n\n    children = [\n      {PartitionSupervisor, child_spec: SomeChild, name: MyPartitionSupervisor}\n    ]\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the given name\nfor the partition supervisor is already assigned to a process,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.\n\n## Options\n\n  * `:name` - an atom or via tuple representing the name of the partition\n    supervisor (see `t:name/0`).\n\n  * `:partitions` - a positive integer with the number of partitions.\n    Defaults to `System.schedulers_online()` (typically the number of cores).\n\n  * `:strategy` - the restart strategy option, defaults to `:one_for_one`.\n    You can learn more about strategies in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:with_arguments` - a two-argument anonymous function that allows\n    the partition to be given to the child starting function. See the\n    `:with_arguments` section below.\n\n## `:with_arguments`\n\nSometimes you want each partition to know their partition assigned number.\nThis can be done with the `:with_arguments` option. This function receives\nthe list of arguments of the child specification and the partition. It\nmust return a new list of arguments that will be passed to the child specification\nof children.\n\nFor example, most processes are started by calling `start_link(opts)`,\nwhere `opts` is a keyword list. You could inject the partition into the\noptions given to the child:\n\n    with_arguments: fn [opts], partition ->\n      [Keyword.put(opts, :partition, partition)]\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.PartitionSupervisor.stop(supervisor, reason \\\\ :normal, timeout \\\\ :infinity) <response> Synchronously stops the given partition supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.PartitionSupervisor.which_children(name) <response> Returns a list with information about all children.\n\nThis function returns a list of tuples containing:\n\n  * `id` - the partition number\n\n  * `child` - the PID of the corresponding child process or the\n    atom `:restarting` if the process is about to be restarted\n\n  * `type` - `:worker` or `:supervisor` as defined in the child\n    specification\n\n  * `modules` - as defined in the child specification"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.PartitionSupervisor.Elixir.PartitionSupervisor <response> A supervisor that starts multiple partitions of the same child.\n\nCertain processes may become bottlenecks in large systems.\nIf those processes can have their state trivially partitioned,\nin a way there is no dependency between them, then they can use\nthe `PartitionSupervisor` to create multiple isolated and\nindependent partitions.\n\nOnce the `PartitionSupervisor` starts, you can dispatch to its\nchildren using `{:via, PartitionSupervisor, {name, key}}`, where\n`name` is the name of the `PartitionSupervisor` and key is used\nfor routing."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.PartitionSupervisor.Elixir.PartitionSupervisor <response> Example\n\nThe `DynamicSupervisor` is a single process responsible for starting\nother processes. In some applications, the `DynamicSupervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `DynamicSupervisor` through a `PartitionSupervisor`, and then\npick a \"random\" instance to start the child on.\n\nInstead of starting a single `DynamicSupervisor`:\n\n    children = [\n      {DynamicSupervisor, name: MyApp.DynamicSupervisor}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nand starting children on that dynamic supervisor directly:\n\n    DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Agent, fn -> %{} end})\n\nYou can do start the dynamic supervisors under a `PartitionSupervisor`:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: DynamicSupervisor,\n       name: MyApp.DynamicSupervisors}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nand then:\n\n    DynamicSupervisor.start_child(\n      {:via, PartitionSupervisor, {MyApp.DynamicSupervisors, self()}},\n      {Agent, fn -> %{} end}\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `DynamicSupervisor` by name, you call it through the\npartition supervisor using the `{:via, PartitionSupervisor, {name, key}}`\nformat. We picked `self()` as the routing key, which means each process\nwill be assigned one of the existing dynamic supervisors. See `start_link/1`\nto see all options supported by the `PartitionSupervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.PartitionSupervisor.Elixir.PartitionSupervisor <response> Implementation notes\n\nThe `PartitionSupervisor` uses either an ETS table or a `Registry` to\nmanage all of the partitions. Under the hood, the `PartitionSupervisor`\ngenerates a child spec for each partition and then acts as a regular\nsupervisor. The ID of each child spec is the partition number.\n\nFor routing, two strategies are used. If `key` is an integer, it is routed\nusing `rem(abs(key), partitions)` where `partitions` is the number of\npartitions. Otherwise it uses `:erlang.phash2(key, partitions)`.\nThe particular routing may change in the future, and therefore must not\nbe relied on. If you want to retrieve a particular PID for a certain key,\nyou can use `GenServer.whereis({:via, PartitionSupervisor, {name, key}})`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.absname(path) <response> Converts the given path to an absolute one.\n\nUnlike `expand/1`, no attempt is made to resolve `..`, `.`, or `~`.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.absname(\"foo\")\n    #=> \"/usr/local/foo\"\n\n    Path.absname(\"../x\")\n    #=> \"/usr/local/../x\"\n\n### Windows\n\n    Path.absname(\"foo\")\n    #=> \"D:/usr/local/foo\"\n\n    Path.absname(\"../x\")\n    #=> \"D:/usr/local/../x\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.absname(path, relative_to) <response> Builds a path from `relative_to` to `path`.\n\nIf `path` is already an absolute path, `relative_to` is ignored. See also\n`relative_to/2`.\n\nUnlike `expand/2`, no attempt is made to\nresolve `..`, `.` or `~`.\n\n## Examples\n\n    iex> Path.absname(\"foo\", \"bar\")\n    \"bar/foo\"\n\n    iex> Path.absname(\"../x\", \"bar\")\n    \"bar/../x\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.basename(path) <response> Returns the last component of the path or the path\nitself if it does not contain any directory separators.\n\n## Examples\n\n    iex> Path.basename(\"foo\")\n    \"foo\"\n\n    iex> Path.basename(\"foo/bar\")\n    \"bar\"\n\n    iex> Path.basename(\"lib/module/submodule.ex\")\n    \"submodule.ex\"\n\n    iex> Path.basename(\"/\")\n    \"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.basename(path, extension) <response> Returns the last component of `path` with the `extension`\nstripped.\n\nThis function should be used to remove a specific\nextension which may or may not be there.\n\n## Examples\n\n    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n    \"bar\"\n\n    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n    \"bar.exs\"\n\n    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n    \"bar.old\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.dirname(path) <response> Returns the directory component of `path`.\n\n## Examples\n\n    iex> Path.dirname(\"/foo/bar.ex\")\n    \"/foo\"\n\n    iex> Path.dirname(\"/foo/bar/baz.ex\")\n    \"/foo/bar\"\n\n    iex> Path.dirname(\"/foo/bar/\")\n    \"/foo/bar\"\n\n    iex> Path.dirname(\"bar.ex\")\n    \".\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.expand(path) <response> Converts the path to an absolute one, expanding\nany `.` and `..` components and a leading `~`.\n\n## Examples\n\n    Path.expand(\"/foo/bar/../baz\")\n    #=> \"/foo/baz\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.expand(path, relative_to) <response> Expands the path relative to the path given as the second argument\nexpanding any `.` and `..` characters.\n\nIf the path is already an absolute path, `relative_to` is ignored.\n\nNote that this function treats a `path` with a leading `~` as\nan absolute one.\n\nThe second argument is first expanded to an absolute path.\n\n## Examples\n\n    # Assuming that the absolute path to baz is /quux/baz\n    Path.expand(\"foo/bar/../bar\", \"baz\")\n    #=> \"/quux/baz/foo/bar\"\n\n    Path.expand(\"foo/bar/../bar\", \"/baz\")\n    #=> \"/baz/foo/bar\"\n\n    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n    #=> \"/foo/bar\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.extname(path) <response> Returns the extension of the last component of `path`.\n\nThe behaviour of this function changed in Erlang/OTP 24 for filenames\nstarting with a dot and without an extension. For example, for a file\nnamed `.gitignore`, `extname/1` now returns an empty string, while it\nwould return `\".gitignore\"` in previous Erlang/OTP versions. This was\ndone to match the behaviour of `rootname/1`, which would return\n`\".gitignore\"` as its name (and therefore it cannot also be an extension).\n\nSee `basename/1` and `rootname/1` for related functions to extract\ninformation from paths.\n\n## Examples\n\n    iex> Path.extname(\"foo.erl\")\n    \".erl\"\n\n    iex> Path.extname(\"~/foo/bar\")\n    \"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.join(list) <response> Joins a list of paths.\n\nThis function should be used to convert a list of paths to a path.\nNote that any trailing slash is removed when joining.\n\nRaises an error if the given list of paths is empty.\n\n## Examples\n\n    iex> Path.join([\"~\", \"foo\"])\n    \"~/foo\"\n\n    iex> Path.join([\"foo\"])\n    \"foo\"\n\n    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n    \"/foo/bar\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.join(left, right) <response> Joins two paths.\n\nThe right path will always be expanded to its relative format\nand any trailing slash will be removed when joining.\n\n## Examples\n\n    iex> Path.join(\"foo\", \"bar\")\n    \"foo/bar\"\n\n    iex> Path.join(\"/foo\", \"/bar/\")\n    \"/foo/bar\"\n\nThe functions in this module support chardata, so giving a list will\ntreat it as a single entity:\n\n    iex> Path.join(\"foo\", [\"bar\", \"fiz\"])\n    \"foo/barfiz\"\n\n    iex> Path.join([\"foo\", \"bar\"], \"fiz\")\n    \"foobar/fiz\"\n\nUse `join/1` if you need to join a list of paths instead."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.relative(name) <response> Forces the path to be a relative path.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n\n### Windows\n\n    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.relative_to(path, from) <response> Returns the given `path` relative to the given `from` path.\n\nIn other words, this function tries to strip the `from` prefix from `path`.\n\nThis function does not query the file system, so it assumes\nno symlinks between the paths.\n\nIn case a direct relative path cannot be found, it returns\nthe original path.\n\n## Examples\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n    \"foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n    \"usr/local/foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n    \"/usr/local/foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local/foo\")\n    \".\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.relative_to_cwd(path) <response> Convenience to get the path relative to the current working\ndirectory.\n\nIf, for some reason, the current working directory\ncannot be retrieved, this function returns the given `path`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.rootname(path) <response> Returns the `path` with the `extension` stripped.\n\n## Examples\n\n    iex> Path.rootname(\"/foo/bar\")\n    \"/foo/bar\"\n\n    iex> Path.rootname(\"/foo/bar.ex\")\n    \"/foo/bar\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.rootname(path, extension) <response> Returns the `path` with the `extension` stripped.\n\nThis function should be used to remove a specific extension which may\nor may not be there.\n\n## Examples\n\n    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n    \"/foo/bar\"\n\n    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n    \"/foo/bar.erl\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.safe_relative(path) <response> Returns a path relative to the current working directory that is\nprotected from directory-traversal attacks.\n\nSame as `safe_relative_to/2` with the current working directory as\nthe second argument. If there is an issue retrieving the current working\ndirectory, this function raises an error.\n\n## Examples\n\n    iex> Path.safe_relative(\"foo\")\n    {:ok, \"foo\"}\n\n    iex> Path.safe_relative(\"foo/../bar\")\n    {:ok, \"bar\"}\n\n    iex> Path.safe_relative(\"foo/../..\")\n    :error\n\n    iex> Path.safe_relative(\"/usr/local\")\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.safe_relative_to(path, relative_to) <response> Returns a relative path that is protected from directory-traversal attacks.\n\nThe given relative path is sanitized by eliminating `..` and `.` components.\n\nThis function checks that, after expanding those components, the path is still \"safe\".\nPaths are considered unsafe if either of these is true:\n\n  * The path is not relative, such as `\"/foo/bar\"`.\n\n  * A `..` component would make it so that the path would travers up above\n    the root of `relative_to`.\n\n  * A symbolic link in the path points to something above the root of `relative_to`.\n\n## Examples\n\n    iex> Path.safe_relative_to(\"deps/my_dep/app.beam\", \"deps\")\n    {:ok, \"deps/my_dep/app.beam\"}\n\n    iex> Path.safe_relative_to(\"deps/my_dep/./build/../app.beam\", \"deps\")\n    {:ok, \"deps/my_dep/app.beam\"}\n\n    iex> Path.safe_relative_to(\"my_dep/../..\", \"deps\")\n    :error\n\n    iex> Path.safe_relative_to(\"/usr/local\", \".\")\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.split(path) <response> Splits the path into a list at the path separator.\n\nIf an empty string is given, returns an empty list.\n\nOn Windows, path is split on both `\"\\\"` and `\"/\"` separators\nand the driver letter, if there is one, is always returned\nin lowercase.\n\n## Examples\n\n    iex> Path.split(\"\")\n    []\n\n    iex> Path.split(\"foo\")\n    [\"foo\"]\n\n    iex> Path.split(\"/foo/bar\")\n    [\"/\", \"foo\", \"bar\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.type(name) <response> Returns the path type.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.type(\"/\")                #=> :absolute\n    Path.type(\"/usr/local/bin\")   #=> :absolute\n    Path.type(\"usr/local/bin\")    #=> :relative\n    Path.type(\"../usr/local/bin\") #=> :relative\n    Path.type(\"~/file\")           #=> :relative\n\n### Windows\n\n    Path.type(\"D:/usr/local/bin\") #=> :absolute\n    Path.type(\"usr/local/bin\")    #=> :relative\n    Path.type(\"D:bar.ex\")         #=> :volumerelative\n    Path.type(\"/bar/foo.ex\")      #=> :volumerelative"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.wildcard(glob, opts \\\\ []) <response> Traverses paths according to the given `glob` expression and returns a\nlist of matches.\n\nThe wildcard looks like an ordinary path, except that the following\n\"wildcard characters\" are interpreted in a special way:\n\n  * `?` - matches one character.\n\n  * `*` - matches any number of characters up to the end of the filename, the\n    next dot, or the next slash.\n\n  * `**` - two adjacent `*`'s used as a single pattern will match all\n    files and zero or more directories and subdirectories.\n\n  * `[char1,char2,...]` - matches any of the characters listed; two\n    characters separated by a hyphen will match a range of characters.\n    Do not add spaces before and after the comma as it would then match\n    paths containing the space character itself.\n\n  * `{item1,item2,...}` - matches one of the alternatives.\n    Do not add spaces before and after the comma as it would then match\n    paths containing the space character itself.\n\nOther characters represent themselves. Only paths that have\nexactly the same character in the same position will match. Note\nthat matching is case-sensitive: `\"a\"` will not match `\"A\"`.\n\nDirectory separators must always be written as `/`, even on Windows.\nYou may call `Path.expand/1` to normalize the path before invoking\nthis function.\n\nBy default, the patterns `*` and `?` do not match files starting\nwith a dot `.`. See the `:match_dot` option in the \"Options\" section\nbelow.\n\n## Options\n\n  * `:match_dot` - (boolean) if `false`, the special wildcard characters `*` and `?`\n    will not match files starting with a dot (`.`). If `true`, files starting with\n    a `.` will not be treated specially. Defaults to `false`.\n\n## Examples\n\nImagine you have a directory called `projects` with three Elixir projects\ninside of it: `elixir`, `ex_doc`, and `plug`. You can find all `.beam` files\ninside the `ebin` directory of each project as follows:\n\n    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n\nIf you want to search for both `.beam` and `.app` files, you could do:\n\n    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Path.Elixir.Path <response> This module provides conveniences for manipulating or\nretrieving file system paths.\n\nThe functions in this module may receive chardata as\narguments and will always return a string encoded in UTF-8. Chardata\nis a string or a list of characters and strings, see `t:IO.chardata/0`.\nIf a binary is given, in whatever encoding, its encoding will be kept.\n\nThe majority of the functions in this module do not\ninteract with the file system, except for a few functions\nthat require it (like `wildcard/2` and `expand/1`)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.close(port) <response> Closes the `port`.\n\nFor more information, see `:erlang.port_close/1`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.command(port, data, options \\\\ []) <response> Sends `data` to the port driver `port`.\n\nFor more information, see `:erlang.port_command/3`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.connect(port, pid) <response> Associates the `port` identifier with a `pid`.\n\nFor more information, see `:erlang.port_connect/2`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.demonitor(monitor_ref, options \\\\ []) <response> Demonitors the monitor identified by the given `reference`.\n\nIf `monitor_ref` is a reference which the calling process\nobtained by calling `monitor/1`, that monitoring is turned off.\nIf the monitoring is already turned off, nothing happens.\n\nSee `:erlang.demonitor/2` for more information.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.info(port) <response> Returns information about the `port` or `nil` if the port is closed.\n\nFor more information, see `:erlang.port_info/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.info(port, spec) <response> Returns information about the `port` or `nil` if the port is closed.\n\nFor more information, see `:erlang.port_info/2`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.list() <response> Returns a list of all ports in the current node.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.monitor(port) <response> Starts monitoring the given `port` from the calling process.\n\nOnce the monitored port process dies, a message is delivered to the\nmonitoring process in the shape of:\n\n    {:DOWN, ref, :port, object, reason}\n\nwhere:\n\n  * `ref` is a monitor reference returned by this function;\n  * `object` is either the `port` being monitored (when monitoring by port ID)\n  or `{name, node}` (when monitoring by a port name);\n  * `reason` is the exit reason.\n\nSee `:erlang.monitor/2` for more information.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.open(name, options) <response> Opens a port given a tuple `name` and a list of `options`.\n\nThe module documentation above contains documentation and examples\nfor the supported `name` values, summarized below:\n\n  * `{:spawn, command}` - runs an external program. `command` must contain\n    the program name and optionally a list of arguments separated by space.\n    If passing programs or arguments with space in their name, use the next option.\n  * `{:spawn_executable, filename}` - runs the executable given by the absolute\n    file name `filename`. Arguments can be passed via the `:args` option.\n  * `{:spawn_driver, command}` - spawns so-called port drivers.\n  * `{:fd, fd_in, fd_out}` - accesses file descriptors, `fd_in` and `fd_out`\n    opened by the VM.\n\nFor more information and the list of options, see `:erlang.open_port/2`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.Elixir.Port <response> Functions for interacting with the external world through ports.\n\nPorts provide a mechanism to start operating system processes external\nto the Erlang VM and communicate with them via message passing."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.Elixir.Port <response> Example\n\n    iex> port = Port.open({:spawn, \"cat\"}, [:binary])\n    iex> send(port, {self(), {:command, \"hello\"}})\n    iex> send(port, {self(), {:command, \"world\"}})\n    iex> flush()\n    {#Port<0.1444>, {:data, \"hello\"}}\n    {#Port<0.1444>, {:data, \"world\"}}\n    iex> send(port, {self(), :close})\n    :ok\n    iex> flush()\n    {#Port<0.1464>, :closed}\n    :ok\n\nIn the example above, we have created a new port that executes the\nprogram `cat`. `cat` is a program available on Unix-like operating systems that\nreceives data from multiple inputs and concatenates them in the output.\n\nAfter the port was created, we sent it two commands in the form of\nmessages using `send/2`. The first command has the binary payload\nof \"hello\" and the second has \"world\".\n\nAfter sending those two messages, we invoked the IEx helper `flush()`,\nwhich printed all messages received from the port, in this case we got\n\"hello\" and \"world\" back. Note that the messages are in binary because we\npassed the `:binary` option when opening the port in `Port.open/2`. Without\nsuch option, it would have yielded a list of bytes.\n\nOnce everything was done, we closed the port.\n\nElixir provides many conveniences for working with ports and some drawbacks.\nWe will explore those below."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.Elixir.Port <response> Message and function APIs\n\nThere are two APIs for working with ports. It can be either asynchronous via\nmessage passing, as in the example above, or by calling the functions on this\nmodule.\n\nThe messages supported by ports and their counterpart function APIs are\nlisted below:\n\n  * `{pid, {:command, binary}}` - sends the given data to the port.\n    See `command/3`.\n\n  * `{pid, :close}` - closes the port. Unless the port is already closed,\n    the port will reply with `{port, :closed}` message once it has flushed\n    its buffers and effectively closed. See `close/1`.\n\n  * `{pid, {:connect, new_pid}}` - sets the `new_pid` as the new owner of\n    the port. Once a port is opened, the port is linked and connected to the\n    caller process and communication to the port only happens through the\n    connected process. This message makes `new_pid` the new connected processes.\n    Unless the port is dead, the port will reply to the old owner with\n    `{port, :connected}`. See `connect/2`.\n\nOn its turn, the port will send the connected process the following messages:\n\n  * `{port, {:data, data}}` - data sent by the port\n  * `{port, :closed}` - reply to the `{pid, :close}` message\n  * `{port, :connected}` - reply to the `{pid, {:connect, new_pid}}` message\n  * `{:EXIT, port, reason}` - exit signals in case the port crashes. If reason\n    is not `:normal`, this message will only be received if the owner process\n    is trapping exits"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.Elixir.Port <response> Open mechanisms\n\nThe port can be opened through four main mechanisms.\n\nAs a short summary, prefer to using the `:spawn` and `:spawn_executable`\noptions mentioned below. The other two options, `:spawn_driver` and `:fd`\nare for advanced usage within the VM. Also consider using `System.cmd/3`\nif all you want is to execute a program and retrieve its return value."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.Elixir.Port <response> # spawn\n\nThe `:spawn` tuple receives a binary that is going to be executed as a\nfull invocation. For example, we can use it to invoke \"echo hello\" directly:\n\n    iex> port = Port.open({:spawn, \"echo hello\"}, [:binary])\n    iex> flush()\n    {#Port<0.1444>, {:data, \"hello\\n\"}}\n\n`:spawn` will retrieve the program name from the argument and traverse your\noperating system `$PATH` environment variable looking for a matching program.\n\nAlthough the above is handy, it means it is impossible to invoke an executable\nthat has whitespaces on its name or in any of its arguments. For those reasons,\nmost times it is preferable to execute `:spawn_executable`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.Elixir.Port <response> # spawn_executable\n\nSpawn executable is a more restricted and explicit version of spawn. It expects\nfull file paths to the executable you want to execute. If they are in your `$PATH`,\nthey can be retrieved by calling `System.find_executable/1`:\n\n    iex> path = System.find_executable(\"echo\")\n    iex> port = Port.open({:spawn_executable, path}, [:binary, args: [\"hello world\"]])\n    iex> flush()\n    {#Port<0.1380>, {:data, \"hello world\\n\"}}\n\nWhen using `:spawn_executable`, the list of arguments can be passed via\nthe `:args` option as done above. For the full list of options, see the\ndocumentation for the Erlang function `:erlang.open_port/2`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.Elixir.Port <response> # fd\n\nThe `:fd` name option allows developers to access `in` and `out` file\ndescriptors used by the Erlang VM. You would use those only if you are\nreimplementing core part of the Runtime System, such as the `:user` and\n`:shell` processes."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Port.Elixir.Port <response> Zombie operating system processes\n\nA port can be closed via the `close/1` function or by sending a `{pid, :close}`\nmessage. However, if the VM crashes, a long-running program started by the port\nwill have its stdin and stdout channels closed but **it won't be automatically\nterminated**.\n\nWhile most Unix command line tools will exit once its communication channels\nare closed, not all command line applications will do so. You can easily check\nthis by starting the port and then shutting down the VM and inspecting your\noperating system to see if the port process is still running.\n\nWhile we encourage graceful termination by detecting if stdin/stdout has been\nclosed, we do not always have control over how third-party software terminates.\nIn those cases, you can wrap the application in a script that checks for stdin.\nHere is such script that has been verified to work on bash shells:\n\n    #!/usr/bin/env bash\n\n    # Start the program in the background\n    exec \"$@\" &\n    pid1=$!\n\n    # Silence warnings from here on\n    exec >/dev/null 2>&1\n\n    # Read from stdin in the background and\n    # kill running program when stdin closes\n    exec 0<&0 $(\n      while read; do :; done\n      kill -KILL $pid1\n    ) &\n    pid2=$!\n\n    # Clean up\n    wait $pid1\n    ret=$?\n    kill -KILL $pid2\n    exit $ret\n\nNote the program above hijacks stdin, so you won't be able to communicate\nwith the underlying software via stdin (on the positive side, software that\nreads from stdin typically terminates when stdin closes).\n\nNow instead of:\n\n    Port.open(\n      {:spawn_executable, \"/path/to/program\"},\n      args: [\"a\", \"b\", \"c\"]\n    )\n\nYou may invoke:\n\n    Port.open(\n      {:spawn_executable, \"/path/to/wrapper\"},\n      args: [\"/path/to/program\", \"a\", \"b\", \"c\"]\n    )"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.alive?(pid) <response> Tells whether the given process is alive on the local node.\n\nIf the process identified by `pid` is alive (that is, it's not exiting and has\nnot exited yet) than this function returns `true`. Otherwise, it returns\n`false`.\n\n`pid` must refer to a process running on the local node or `ArgumentError` is raised.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.cancel_timer(timer_ref, options \\\\ []) <response> Cancels a timer returned by `send_after/3`.\n\nWhen the result is an integer, it represents the time in milliseconds\nleft until the timer would have expired.\n\nWhen the result is `false`, a timer corresponding to `timer_ref` could not be\nfound. This can happen either because the timer expired, because it has\nalready been canceled, or because `timer_ref` never corresponded to a timer.\n\nEven if the timer had expired and the message was sent, this function does not\ntell you if the timeout message has arrived at its destination yet.\n\nInlined by the compiler.\n\n## Options\n\n  * `:async` - (boolean) when `false`, the request for cancellation is\n    synchronous. When `true`, the request for cancellation is asynchronous,\n    meaning that the request to cancel the timer is issued and `:ok` is\n    returned right away. Defaults to `false`.\n\n  * `:info` - (boolean) whether to return information about the timer being\n    cancelled. When the `:async` option is `false` and `:info` is `true`, then\n    either an integer or `false` (like described above) is returned. If\n    `:async` is `false` and `:info` is `false`, `:ok` is returned. If `:async`\n    is `true` and `:info` is `true`, a message in the form `{:cancel_timer,\n    timer_ref, result}` (where `result` is an integer or `false` like\n    described above) is sent to the caller of this function when the\n    cancellation has been performed. If `:async` is `true` and `:info` is\n    `false`, no message is sent. Defaults to `true`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.delete(key) <response> Deletes the given `key` from the process dictionary.\n\nReturns the value that was under `key` in the process dictionary,\nor `nil` if `key` was not stored in the process dictionary.\n\n## Examples\n\n    iex> Process.put(:comments, [\"comment\", \"other comment\"])\n    iex> Process.delete(:comments)\n    [\"comment\", \"other comment\"]\n    iex> Process.delete(:comments)\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.demonitor(monitor_ref, options \\\\ []) <response> Demonitors the monitor identified by the given `reference`.\n\nIf `monitor_ref` is a reference which the calling process\nobtained by calling `monitor/1`, that monitoring is turned off.\nIf the monitoring is already turned off, nothing happens.\n\nSee `:erlang.demonitor/2` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    pid = spawn(fn -> 1 + 2 end)\n    ref = Process.monitor(pid)\n    Process.demonitor(ref)\n    #=> true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.exit(pid, reason) <response> Sends an exit signal with the given `reason` to `pid`.\n\nThe following behaviour applies if `reason` is any term except `:normal`\nor `:kill`:\n\n  1. If `pid` is not trapping exits, `pid` will exit with the given\n     `reason`.\n\n  2. If `pid` is trapping exits, the exit signal is transformed into a\n     message `{:EXIT, from, reason}` and delivered to the message queue\n     of `pid`.\n\nIf `reason` is the atom `:normal`, `pid` will not exit (unless `pid` is\nthe calling process, in which case it will exit with the reason `:normal`).\nIf it is trapping exits, the exit signal is transformed into a message\n`{:EXIT, from, :normal}` and delivered to its message queue.\n\nIf `reason` is the atom `:kill`, that is if `Process.exit(pid, :kill)` is called,\nan untrappable exit signal is sent to `pid` which will unconditionally exit\nwith reason `:killed`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.exit(pid, :kill)\n    #=> true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.flag(flag, value) <response> Sets the given `flag` to `value` for the calling process.\n\nReturns the old value of `flag`.\n\nSee `:erlang.process_flag/2` for more information.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.flag(pid, flag, value) <response> Sets the given `flag` to `value` for the given process `pid`.\n\nReturns the old value of `flag`.\n\nIt raises `ArgumentError` if `pid` is not a local process.\n\nThe allowed values for `flag` are only a subset of those allowed in `flag/2`,\nnamely `:save_calls`.\n\nSee `:erlang.process_flag/3` for more information.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.get() <response> Returns all key-value pairs in the process dictionary.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.get(key, default \\\\ nil) <response> Returns the value for the given `key` in the process dictionary,\nor `default` if `key` is not set.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> Process.get(:locale, \"pt\")\n    \"pt\"\n    iex> Process.put(:locale, \"fr\")\n    nil\n    iex> Process.get(:locale, \"pt\")\n    \"fr\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.get_keys() <response> Returns all keys in the process dictionary.\n\nInlined by the compiler.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> :locale in Process.get_keys()\n    false\n    iex> Process.put(:locale, \"pt\")\n    nil\n    iex> :locale in Process.get_keys()\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.get_keys(value) <response> Returns all keys in the process dictionary that have the given `value`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.group_leader() <response> Returns the PID of the group leader for the calling process.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.group_leader()\n    #=> #PID<0.53.0>"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.group_leader(pid, leader) <response> Sets the group leader of the given `pid` to `leader`.\n\nTypically, this is used when a process started from a certain shell should\nhave a group leader other than `:init`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.hibernate(mod, fun_name, args) <response> Puts the calling process into a \"hibernation\" state.\n\nThe calling process is put into a waiting state\nwhere its memory allocation has been reduced as much as possible,\nwhich is useful if the process does not expect to receive any messages\nin the near future.\n\nSee `:erlang.hibernate/3` for more information.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.info(pid) <response> Returns information about the process identified by `pid`, or returns `nil` if the process\nis not alive.\n\nUse this only for debugging information.\n\nSee `:erlang.process_info/1` for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.info(pid, spec) <response> Returns information about the process identified by `pid`,\nor returns `nil` if the process is not alive.\n\nSee `:erlang.process_info/2` for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.link(pid_or_port) <response> Creates a link between the calling process and the given item (process or\nport).\n\nLinks are bidirectional. Linked processes can be unlinked by using `unlink/1`.\n\nIf such a link exists already, this function does nothing since there can only\nbe one link between two given processes. If a process tries to create a link\nto itself, nothing will happen.\n\nWhen two processes are linked, each one receives exit signals from the other\n(see also `exit/2`). Let's assume `pid1` and `pid2` are linked. If `pid2`\nexits with a reason other than `:normal` (which is also the exit reason used\nwhen a process finishes its job) and `pid1` is not trapping exits (see\n`flag/2`), then `pid1` will exit with the same reason as `pid2` and in turn\nemit an exit signal to all its other linked processes. The behaviour when\n`pid1` is trapping exits is described in `exit/2`.\n\nSee `:erlang.link/1` for more information.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.list() <response> Returns a list of PIDs corresponding to all the\nprocesses currently existing on the local node.\n\nNote that if a process is exiting, it is considered to exist but not be\nalive. This means that for such process, `alive?/1` will return `false` but\nits PID will be part of the list of PIDs returned by this function.\n\nSee `:erlang.processes/0` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.list()\n    #=> [#PID<0.0.0>, #PID<0.1.0>, #PID<0.2.0>, #PID<0.3.0>, ...]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.monitor(item) <response> Starts monitoring the given `item` from the calling process.\n\nOnce the monitored process dies, a message is delivered to the\nmonitoring process in the shape of:\n\n    {:DOWN, ref, :process, object, reason}\n\nwhere:\n\n  * `ref` is a monitor reference returned by this function;\n  * `object` is either a `pid` of the monitored process (if monitoring\n    a PID) or `{name, node}` (if monitoring a remote or local name);\n  * `reason` is the exit reason.\n\nIf the process is already dead when calling `Process.monitor/1`, a\n`:DOWN` message is delivered immediately.\n\nSee [\"The need for monitoring\"](https://elixir-lang.org/getting-started/mix-otp/genserver.html#the-need-for-monitoring)\nfor an example. See `:erlang.monitor/2` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    pid = spawn(fn -> 1 + 2 end)\n    #=> #PID<0.118.0>\n    Process.monitor(pid)\n    #=> #Reference<0.906660723.3006791681.40191>\n    Process.exit(pid, :kill)\n    #=> true\n    receive do\n      msg -> msg\n    end\n    #=> {:DOWN, #Reference<0.906660723.3006791681.40191>, :process, #PID<0.118.0>, :noproc}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.put(key, value) <response> Stores the given `key`-`value` pair in the process dictionary.\n\nThe return value of this function is the value that was previously stored\nunder `key`, or `nil` in case no value was stored under it.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> Process.put(:locale, \"en\")\n    nil\n    iex> Process.put(:locale, \"fr\")\n    \"en\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.read_timer(timer_ref) <response> Reads a timer created by `send_after/3`.\n\nWhen the result is an integer, it represents the time in milliseconds\nleft until the timer will expire.\n\nWhen the result is `false`, a timer corresponding to `timer_ref` could not be\nfound. This can be either because the timer expired, because it has already\nbeen canceled, or because `timer_ref` never corresponded to a timer.\n\nEven if the timer had expired and the message was sent, this function does not\ntell you if the timeout message has arrived at its destination yet.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.register(pid_or_port, name) <response> Registers the given `pid_or_port` under the given `name`.\n\n`name` must be an atom and can then be used instead of the\nPID/port identifier when sending messages with `Kernel.send/2`.\n\n`register/2` will fail with `ArgumentError` in any of the following cases:\n\n  * the PID/Port is not existing locally and alive\n  * the name is already registered\n  * the `pid_or_port` is already registered under a different `name`\n\nThe following names are reserved and cannot be assigned to\nprocesses nor ports:\n\n  * `nil`\n  * `false`\n  * `true`\n  * `:undefined`\n\n## Examples\n\n    Process.register(self(), :test)\n    #=> true\n    send(:test, :hello)\n    #=> :hello\n    send(:wrong_name, :hello)\n    ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.registered() <response> Returns a list of names which have been registered using `register/2`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.register(self(), :test)\n    Process.registered()\n    #=> [:test, :elixir_config, :inet_db, ...]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.send(dest, msg, options) <response> Sends a message to the given `dest`.\n\n`dest` may be a remote or local PID, a local port, a locally\nregistered name, or a tuple in the form of `{registered_name, node}` for a\nregistered name at another node.\n\nInlined by the compiler.\n\n## Options\n\n  * `:noconnect` - when used, if sending the message would require an\n    auto-connection to another node the message is not sent and `:noconnect` is\n    returned.\n\n  * `:nosuspend` - when used, if sending the message would cause the sender to\n    be suspended the message is not sent and `:nosuspend` is returned.\n\nOtherwise the message is sent and `:ok` is returned.\n\n## Examples\n\n    iex> Process.send({:name, :node_that_does_not_exist}, :hi, [:noconnect])\n    :noconnect"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.send_after(dest, msg, time, opts \\\\ []) <response> Sends `msg` to `dest` after `time` milliseconds.\n\nIf `dest` is a PID, it must be the PID of a local process, dead or alive.\nIf `dest` is an atom, it must be the name of a registered process\nwhich is looked up at the time of delivery. No error is produced if the name does\nnot refer to a process.\n\nThe message is not sent immediately. Therefore, `dest` can receive other messages\nin-between even when `time` is `0`.\n\nThis function returns a timer reference, which can be read with `read_timer/1`\nor canceled with `cancel_timer/1`.\n\nThe timer will be automatically canceled if the given `dest` is a PID\nwhich is not alive or when the given PID exits. Note that timers will not be\nautomatically canceled when `dest` is an atom (as the atom resolution is done\non delivery).\n\nInlined by the compiler.\n\n## Options\n\n  * `:abs` - (boolean) when `false`, `time` is treated as relative to the\n  current monotonic time. When `true`, `time` is the absolute value of the\n  Erlang monotonic time at which `msg` should be delivered to `dest`.\n  To read more about Erlang monotonic time and other time-related concepts,\n  look at the documentation for the `System` module. Defaults to `false`.\n\n## Examples\n\n    timer_ref = Process.send_after(pid, :hi, 1000)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.sleep(timeout) <response> Sleeps the current process for the given `timeout`.\n\n`timeout` is either the number of milliseconds to sleep as an\ninteger or the atom `:infinity`. When `:infinity` is given,\nthe current process will sleep forever, and not\nconsume or reply to messages.\n\n**Use this function with extreme care**. For almost all situations\nwhere you would use `sleep/1` in Elixir, there is likely a\nmore correct, faster and precise way of achieving the same with\nmessage passing.\n\nFor example, if you are waiting for a process to perform some\naction, it is better to communicate the progress of such action\nwith messages.\n\nIn other words, **do not**:\n\n    Task.start_link(fn ->\n      do_something()\n      ...\n    end)\n\n    # Wait until work is done\n    Process.sleep(2000)\n\nBut **do**:\n\n    parent = self()\n\n    Task.start_link(fn ->\n      do_something()\n      send(parent, :work_is_done)\n      ...\n    end)\n\n    receive do\n      :work_is_done -> :ok\n    after\n      # Optional timeout\n      30_000 -> :timeout\n    end\n\nFor cases like the one above, `Task.async/1` and `Task.await/2` are\npreferred.\n\nSimilarly, if you are waiting for a process to terminate,\nmonitor that process instead of sleeping. **Do not**:\n\n    Task.start_link(fn ->\n      ...\n    end)\n\n    # Wait until task terminates\n    Process.sleep(2000)\n\nInstead **do**:\n\n    {:ok, pid} =\n      Task.start_link(fn ->\n        ...\n      end)\n\n    ref = Process.monitor(pid)\n\n    receive do\n      {:DOWN, ^ref, _, _, _} -> :task_is_down\n    after\n      # Optional timeout\n      30_000 -> :timeout\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.spawn(fun, opts) <response> Spawns the given function according to the given options.\n\nThe result depends on the given options. In particular,\nif `:monitor` is given as an option, it will return a tuple\ncontaining the PID and the monitoring reference, otherwise\njust the spawned process PID.\n\nMore options are available; for the comprehensive list of available options\ncheck `:erlang.spawn_opt/4`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.spawn(fn -> 1 + 2 end, [:monitor])\n    #=> {#PID<0.93.0>, #Reference<0.18808174.1939079169.202418>}\n    Process.spawn(fn -> 1 + 2 end, [:link])\n    #=> #PID<0.95.0>"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.spawn(mod, fun, args, opts) <response> Spawns the given function `fun` from module `mod`, passing the given `args`\naccording to the given options.\n\nThe result depends on the given options. In particular,\nif `:monitor` is given as an option, it will return a tuple\ncontaining the PID and the monitoring reference, otherwise\njust the spawned process PID.\n\nIt also accepts extra options, for the list of available options\ncheck `:erlang.spawn_opt/4`.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.unlink(pid_or_port) <response> Removes the link between the calling process and the given item (process or\nport).\n\nIf there is no such link, this function does nothing. If `pid_or_port` does\nnot exist, this function does not produce any errors and simply does nothing.\n\nThe return value of this function is always `true`.\n\nSee `:erlang.unlink/1` for more information.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.unregister(name) <response> Removes the registered `name`, associated with a PID\nor a port identifier.\n\nFails with `ArgumentError` if the name is not registered\nto any PID or port.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.register(self(), :test)\n    #=> true\n    Process.unregister(:test)\n    #=> true\n    Process.unregister(:wrong_name)\n    ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.whereis(name) <response> Returns the PID or port identifier registered under `name` or `nil` if the\nname is not registered.\n\nSee `:erlang.whereis/1` for more information.\n\n## Examples\n\n    Process.register(self(), :test)\n    Process.whereis(:test)\n    #=> #PID<0.84.0>\n    Process.whereis(:wrong_name)\n    #=> nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Process.Elixir.Process <response> Conveniences for working with processes and the process dictionary.\n\nBesides the functions available in this module, the `Kernel` module\nexposes and auto-imports some basic functionality related to processes\navailable through the following functions:\n\n  * `Kernel.spawn/1` and `Kernel.spawn/3`\n  * `Kernel.spawn_link/1` and `Kernel.spawn_link/3`\n  * `Kernel.spawn_monitor/1` and `Kernel.spawn_monitor/3`\n  * `Kernel.self/0`\n  * `Kernel.send/2`\n\nWhile this module provides low-level conveniences to work with processes,\ndevelopers typically use abstractions such as `Agent`, `GenServer`,\n`Registry`, `Supervisor` and `Task` for building their systems and\nresort to this module for gathering information, trapping exits, links\nand monitoring."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.assert_impl!(protocol, base) <response> Checks if the given module is loaded and is an implementation\nof the given protocol.\n\nReturns `:ok` if so, otherwise raises `ArgumentError`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.assert_protocol!(module) <response> Checks if the given module is loaded and is protocol.\n\nReturns `:ok` if so, otherwise raises `ArgumentError`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.consolidate(protocol, types) <response> Receives a protocol and a list of implementations and\nconsolidates the given protocol.\n\nConsolidation happens by changing the protocol `impl_for`\nin the abstract format to have fast lookup rules. Usually\nthe list of implementations to use during consolidation\nare retrieved with the help of `extract_impls/2`.\n\nIt returns the updated version of the protocol bytecode.\nIf the first element of the tuple is `:ok`, it means\nthe protocol was consolidated.\n\nA given bytecode or protocol implementation can be checked\nto be consolidated or not by analyzing the protocol\nattribute:\n\n    Protocol.consolidated?(Enumerable)\n\nThis function does not load the protocol at any point\nnor loads the new bytecode for the compiled module.\nHowever each implementation must be available and\nit will be loaded."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.consolidated?(protocol) <response> Returns `true` if the protocol was consolidated."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.extract_impls(protocol, paths) <response> Extracts all types implemented for the given protocol from\nthe given paths.\n\nThe paths can be either a charlist or a string. Internally\nthey are worked on as charlists, so passing them as lists\navoid extra conversion.\n\nDoes not load any of the implementations.\n\n## Examples\n\n    # Get Elixir's ebin directory path and retrieve all protocols\n    iex> path = :code.lib_dir(:elixir, :ebin)\n    iex> mods = Protocol.extract_impls(Enumerable, [path])\n    iex> List in mods\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.extract_protocols(paths) <response> Extracts all protocols from the given paths.\n\nThe paths can be either a charlist or a string. Internally\nthey are worked on as charlists, so passing them as lists\navoid extra conversion.\n\nDoes not load any of the protocols.\n\n## Examples\n\n    # Get Elixir's ebin directory path and retrieve all protocols\n    iex> path = :code.lib_dir(:elixir, :ebin)\n    iex> mods = Protocol.extract_protocols([path])\n    iex> Enumerable in mods\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.Elixir.Protocol <response> Reference and functions for working with protocols.\n\nA protocol specifies an API that should be defined by its\nimplementations. A protocol is defined with `Kernel.defprotocol/2`\nand its implementations with `Kernel.defimpl/3`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.Elixir.Protocol <response> A real case\n\nIn Elixir, we have two nouns for checking how many items there\nare in a data structure: `length` and `size`.  `length` means the\ninformation must be computed. For example, `length(list)` needs to\ntraverse the whole list to calculate its length. On the other hand,\n`tuple_size(tuple)` and `byte_size(binary)` do not depend on the\ntuple and binary size as the size information is precomputed in\nthe data structure.\n\nAlthough Elixir includes specific functions such as `tuple_size`,\n`binary_size` and `map_size`, sometimes we want to be able to\nretrieve the size of a data structure regardless of its type.\nIn Elixir we can write polymorphic code, i.e. code that works\nwith different shapes/types, by using protocols. A size protocol\ncould be implemented as follows:\n\n    defprotocol Size do\n      @doc \"Calculates the size (and not the length!) of a data structure\"\n      def size(data)\n    end\n\nNow that the protocol can be implemented for every data structure\nthe protocol may have a compliant implementation for:\n\n    defimpl Size, for: BitString do\n      def size(binary), do: byte_size(binary)\n    end\n\n    defimpl Size, for: Map do\n      def size(map), do: map_size(map)\n    end\n\n    defimpl Size, for: Tuple do\n      def size(tuple), do: tuple_size(tuple)\n    end\n\nNote that we didn't implement it for lists as we don't have the\n`size` information on lists, rather its value needs to be\ncomputed with `length`.\n\nThe data structure you are implementing the protocol for\nmust be the first argument to all functions defined in the\nprotocol.\n\nIt is possible to implement protocols for all Elixir types:\n\n  * Structs (see the \"Protocols and Structs\" section below)\n  * `Tuple`\n  * `Atom`\n  * `List`\n  * `BitString`\n  * `Integer`\n  * `Float`\n  * `Function`\n  * `PID`\n  * `Map`\n  * `Port`\n  * `Reference`\n  * `Any` (see the \"Fallback to `Any`\" section below)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.Elixir.Protocol <response> Protocols and Structs\n\nThe real benefit of protocols comes when mixed with structs.\nFor instance, Elixir ships with many data types implemented as\nstructs, like `MapSet`. We can implement the `Size` protocol\nfor those types as well:\n\n    defimpl Size, for: MapSet do\n      def size(map_set), do: MapSet.size(map_set)\n    end\n\nWhen implementing a protocol for a struct, the `:for` option can\nbe omitted if the `defimpl/3` call is inside the module that defines\nthe struct:\n\n    defmodule User do\n      defstruct [:email, :name]\n\n      defimpl Size do\n        # two fields\n        def size(%User{}), do: 2\n      end\n    end\n\nIf a protocol implementation is not found for a given type,\ninvoking the protocol will raise unless it is configured to\nfall back to `Any`. Conveniences for building implementations\non top of existing ones are also available, look at `defstruct/1`\nfor more information about deriving\nprotocols."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.Elixir.Protocol <response> Fallback to `Any`\n\nIn some cases, it may be convenient to provide a default\nimplementation for all types. This can be achieved by setting\nthe `@fallback_to_any` attribute to `true` in the protocol\ndefinition:\n\n    defprotocol Size do\n      @fallback_to_any true\n      def size(data)\n    end\n\nThe `Size` protocol can now be implemented for `Any`:\n\n    defimpl Size, for: Any do\n      def size(_), do: 0\n    end\n\nAlthough the implementation above is arguably not a reasonable\none. For example, it makes no sense to say a PID or an integer\nhave a size of `0`. That's one of the reasons why `@fallback_to_any`\nis an opt-in behaviour. For the majority of protocols, raising\nan error when a protocol is not implemented is the proper behaviour."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.Elixir.Protocol <response> Multiple implementations\n\nProtocols can also be implemented for multiple types at once:\n\n    defprotocol Reversible do\n      def reverse(term)\n    end\n\n    defimpl Reversible, for: [Map, List] do\n      def reverse(term), do: Enum.reverse(term)\n    end\n\nInside `defimpl/3`, you can use `@protocol` to access the protocol\nbeing implemented and `@for` to access the module it is being\ndefined for."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.Elixir.Protocol <response> Types\n\nDefining a protocol automatically defines a zero-arity type named `t`, which\ncan be used as follows:\n\n    @spec print_size(Size.t()) :: :ok\n    def print_size(data) do\n      result =\n        case Size.size(data) do\n          0 -> \"data has no items\"\n          1 -> \"data has one item\"\n          n -> \"data has #{n} items\"\n        end\n\n      IO.puts(result)\n    end\n\nThe `@spec` above expresses that all types allowed to implement the\ngiven protocol are valid argument types for the given function."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.Elixir.Protocol <response> Reflection\n\nAny protocol module contains three extra functions:\n\n  * `__protocol__/1` - returns the protocol information. The function takes\n    one of the following atoms:\n\n    * `:consolidated?` - returns whether the protocol is consolidated\n\n    * `:functions` - returns a keyword list of protocol functions and their arities\n\n    * `:impls` - if consolidated, returns `{:consolidated, modules}` with the list of modules\n      implementing the protocol, otherwise `:not_consolidated`\n\n    * `:module` - the protocol module atom name\n\n  * `impl_for/1` - returns the module that implements the protocol for the given argument,\n    `nil` otherwise\n\n  * `impl_for!/1` - same as above but raises `Protocol.UndefinedError` if an implementation is\n    not found\n\nFor example, for the `Enumerable` protocol we have:\n\n    iex> Enumerable.__protocol__(:functions)\n    [count: 1, member?: 2, reduce: 3, slice: 1]\n\n    iex> Enumerable.impl_for([])\n    Enumerable.List\n\n    iex> Enumerable.impl_for(42)\n    nil\n\nIn addition, every protocol implementation module contains the `__impl__/1`\nfunction. The function takes one of the following atoms:\n\n  * `:for` - returns the module responsible for the data structure of the\n    protocol implementation\n\n  * `:protocol` - returns the protocol module for which this implementation\n  is provided\n\nFor example, the module implementing the `Enumerable` protocol for lists is\n`Enumerable.List`. Therefore, we can invoke `__impl__/1` on this module:\n\n    iex(1)> Enumerable.List.__impl__(:for)\n    List\n\n    iex(2)> Enumerable.List.__impl__(:protocol)\n    Enumerable"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Protocol.Elixir.Protocol <response> Consolidation\n\nIn order to speed up protocol dispatching, whenever all protocol implementations\nare known up-front, typically after all Elixir code in a project is compiled,\nElixir provides a feature called *protocol consolidation*. Consolidation directly\nlinks protocols to their implementations in a way that invoking a function from a\nconsolidated protocol is equivalent to invoking two remote functions.\n\nProtocol consolidation is applied by default to all Mix projects during compilation.\nThis may be an issue during test. For instance, if you want to implement a protocol\nduring test, the implementation will have no effect, as the protocol has already been\nconsolidated. One possible solution is to include compilation directories that are\nspecific to your test environment in your mix.exs:\n\n    def project do\n      ...\n      elixirc_paths: elixirc_paths(Mix.env())\n      ...\n    end\n\n    defp elixirc_paths(:test), do: [\"lib\", \"test/support\"]\n    defp elixirc_paths(_), do: [\"lib\"]\n\nAnd then you can define the implementations specific to the test environment\ninside `test/support/some_file.ex`.\n\nAnother approach is to disable protocol consolidation during tests in your\nmix.exs:\n\n    def project do\n      ...\n      consolidate_protocols: Mix.env() != :test\n      ...\n    end\n\nIf you are using `Mix.install/2`, you can do by passing the `consolidate_protocols`\noption:\n\n    Mix.install(\n      deps,\n      consolidate_protocols: false\n    )\n\nAlthough doing so is not recommended as it may affect the performance of\nyour code.\n\nFinally, note all protocols are compiled with `debug_info` set to `true`,\nregardless of the option set by the `elixirc` compiler. The debug info is\nused for consolidation and it is removed after consolidation unless\nglobally set."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Range.disjoint?(range1, range2) <response> Checks if two ranges are disjoint.\n\n## Examples\n\n    iex> Range.disjoint?(1..5, 6..9)\n    true\n    iex> Range.disjoint?(5..1, 6..9)\n    true\n    iex> Range.disjoint?(1..5, 5..9)\n    false\n    iex> Range.disjoint?(1..5, 2..7)\n    false\n\nSteps are also considered when computing the ranges to be disjoint:\n\n    iex> Range.disjoint?(1..10//2, 2..10//2)\n    true\n\n    # First element in common is 29\n    iex> Range.disjoint?(1..100//14, 8..100//21)\n    false\n    iex> Range.disjoint?(57..-1//-14, 8..100//21)\n    false\n    iex> Range.disjoint?(1..100//14, 50..8//-21)\n    false\n    iex> Range.disjoint?(1..28//14, 8..28//21)\n    true\n\n    # First element in common is 14\n    iex> Range.disjoint?(2..28//3, 9..28//5)\n    false\n    iex> Range.disjoint?(26..2//-3, 29..9//-5)\n    false\n\n    # Starting from the back without alignment\n    iex> Range.disjoint?(27..11//-3, 30..0//-7)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Range.new(first, last) <response> Creates a new range.\n\nIf `first` is less than `last`, the range will be increasing from\n`first` to `last`. If `first` is equal to `last`, the range will contain\none element, which is the number itself.\n\nIf `first` is greater than `last`, the range will be decreasing from `first`\nto `last`, albeit this behaviour is deprecated. Therefore, it is advised to\nexplicitly list the step with `new/3`.\n\n## Examples\n\n    iex> Range.new(-100, 100)\n    -100..100"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Range.new(first, last, step) <response> Creates a new range with `step`.\n\n## Examples\n\n    iex> Range.new(-100, 100, 2)\n    -100..100//2"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Range.shift(arg, steps_to_shift) <response> Shifts a range by the given number of steps.\n\n## Examples\n\n    iex> Range.shift(0..10, 1)\n    1..11\n    iex> Range.shift(0..10, 2)\n    2..12\n\n    iex> Range.shift(0..10//2, 2)\n    4..14//2"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Range.size(range) <response> Returns the size of `range`.\n\n## Examples\n\n    iex> Range.size(1..10)\n    10\n    iex> Range.size(1..10//2)\n    5\n    iex> Range.size(1..10//3)\n    4\n    iex> Range.size(1..10//-1)\n    0\n\n    iex> Range.size(10..1)\n    10\n    iex> Range.size(10..1//-1)\n    10\n    iex> Range.size(10..1//-2)\n    5\n    iex> Range.size(10..1//-3)\n    4\n    iex> Range.size(10..1//1)\n    0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Range.Elixir.Range <response> Ranges represent a sequence of zero, one or many, ascending\nor descending integers with a common difference called step.\n\nThe most common form of creating and matching on ranges is\nvia the [`first..last`](`../2`) and [`first..last//step`](`..///3`)\nnotations, auto-imported from `Kernel`:\n\n    iex> 1 in 1..10\n    true\n    iex> 5 in 1..10\n    true\n    iex> 10 in 1..10\n    true\n\nRanges are always inclusive in Elixir. When a step is defined,\nintegers will only belong to the range if they match the step:\n\n    iex> 5 in 1..10//2\n    true\n    iex> 4 in 1..10//2\n    false\n\nWhen defining a range without a step, the step will be\ndefined based on the first and last position of the\nrange, If `last >= first`, it will be an increasing range\nwith a step of 1. Otherwise, it is a decreasing range.\nNote however implicit decreasing ranges are deprecated.\nTherefore, if you need a decreasing range from `3` to `1`,\nprefer to write `3..1//-1` instead.\n\n`../0` can also be used as a shortcut to create the range `0..-1//1`,\nalso known as the full-slice range:\n\n    iex> ..\n    0..-1//1"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Range.Elixir.Range <response> Use cases\n\nRanges typically have two uses in Elixir: as a collection or\nto represent a slice of another data structure."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Range.Elixir.Range <response> # Ranges as collections\n\nRanges in Elixir are enumerables and therefore can be used\nwith the `Enum` module:\n\n    iex> Enum.to_list(1..3)\n    [1, 2, 3]\n    iex> Enum.to_list(3..1//-1)\n    [3, 2, 1]\n    iex> Enum.to_list(1..5//2)\n    [1, 3, 5]\n\nRanges may also have a single element:\n\n    iex> Enum.to_list(1..1)\n    [1]\n    iex> Enum.to_list(1..1//2)\n    [1]\n\nOr even no elements at all:\n\n    iex> Enum.to_list(10..0//1)\n    []\n    iex> Enum.to_list(0..10//-1)\n    []\n\nThe full-slice range, returned by `../0`, is an empty collection:\n\n    iex> Enum.to_list(..)\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Range.Elixir.Range <response> # Ranges as slices\n\nRanges are also frequently used to slice collections.\nYou can slice strings or any enumerable:\n\n    iex> String.slice(\"elixir\", 1..4)\n    \"lixi\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], 1..4)\n    [1, 2, 3, 4]\n\nIn those cases, the first and last values of the range\nare mapped to positions in the collections.\n\nIf a negative number is given, it maps to a position\nfrom the back:\n\n    iex> String.slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], 1..-2//1)\n    [1, 2, 3, 4]\n\nThe range `0..-1//1`, returned by `../0`, returns the\ncollection as is, which is why it is called the full-slice\nrange:\n\n    iex> String.slice(\"elixir\", ..)\n    \"elixir\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], ..)\n    [0, 1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Range.Elixir.Range <response> Definition\n\nAn increasing range `first..last//step` is a range from `first`\nto `last` increasing by `step` where  `step` must be a positive\ninteger and all values `v` must be `first <= v and v <= last`.\nTherefore, a range `10..0//1` is an empty range because there\nis no value `v` that is `10 <= v and v <= 0`.\n\nSimilarly, a decreasing range `first..last//step` is a range\nfrom `first` to `last` decreasing by `step` where `step` must\nbe a negative integer and  values `v` must be `first >= v and v >= last`.\nTherefore, a range `0..10//-1` is an empty range because there\nis no value `v` that is `0 >= v and v >= 10`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Range.Elixir.Range <response> Representation\n\nInternally, ranges are represented as structs:\n\n    iex> range = 1..9//2\n    1..9//2\n    iex> first..last//step = range\n    iex> first\n    1\n    iex> last\n    9\n    iex> step\n    2\n    iex> range.step\n    2\n\nYou can access the range fields (`first`, `last`, and `step`)\ndirectly but you should not modify nor create ranges by hand.\nInstead use the proper operators or `new/2` and `new/3`.\n\nRanges implement the `Enumerable` protocol with memory\nefficient versions of all `Enumerable` callbacks:\n\n    iex> range = 1..10\n    1..10\n    iex> Enum.reduce(range, 0, fn i, acc -> i * i + acc end)\n    385\n    iex> Enum.count(range)\n    10\n    iex> Enum.member?(range, 11)\n    false\n    iex> Enum.member?(range, 8)\n    true\n\nSuch function calls are efficient memory-wise no matter the\nsize of the range. The implementation of the `Enumerable`\nprotocol uses logic based solely on the endpoints and does\nnot materialize the whole list of integers."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Record.extract(name, opts) <response> Extracts record information from an Erlang file.\n\nReturns a quoted expression containing the fields as a list\nof tuples.\n\n`name`, which is the name of the extracted record, is expected to be an atom\n*at compile time*.\n\n## Options\n\nThis function requires one of the following options, which are exclusive to each\nother (i.e., only one of them can be used in the same call):\n\n  * `:from` - (binary representing a path to a file) path to the Erlang file\n    that contains the record definition to extract; with this option, this\n    function uses the same path lookup used by the `-include` attribute used in\n    Erlang modules.\n\n  * `:from_lib` - (binary representing a path to a file) path to the Erlang\n    file that contains the record definition to extract; with this option,\n    this function uses the same path lookup used by the `-include_lib`\n    attribute used in Erlang modules.\n\nIt additionally accepts the following optional, non-exclusive options:\n\n  * `:includes` - (a list of directories as binaries) if the record being\n    extracted depends on relative includes, this option allows developers\n    to specify the directory where those relative includes exist.\n\n  * `:macros` - (keyword list of macro names and values) if the record\n    being extracted depends on the values of macros, this option allows\n    the value of those macros to be set.\n\nThese options are expected to be literals (including the binary values) at\ncompile time.\n\n## Examples\n\n    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n    [\n      size: :undefined,\n      type: :undefined,\n      access: :undefined,\n      atime: :undefined,\n      mtime: :undefined,\n      ctime: :undefined,\n      mode: :undefined,\n      links: :undefined,\n      major_device: :undefined,\n      minor_device: :undefined,\n      inode: :undefined,\n      uid: :undefined,\n      gid: :undefined\n    ]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Record.extract_all(opts) <response> Extracts all records information from an Erlang file.\n\nReturns a keyword list of `{record_name, fields}` tuples where `record_name`\nis the name of an extracted record and `fields` is a list of `{field, value}`\ntuples representing the fields for that record.\n\n## Options\n\nAccepts the same options as listed for `Record.extract/2`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Record.Elixir.Record <response> Module to work with, define, and import records.\n\nRecords are simply tuples where the first element is an atom:\n\n    iex> Record.is_record({User, \"john\", 27})\n    true\n\nThis module provides conveniences for working with records at\ncompilation time, where compile-time field names are used to\nmanipulate the tuples, providing fast operations on top of\nthe tuples' compact structure.\n\nIn Elixir, records are used mostly in two situations:\n\n  1. to work with short, internal data\n  2. to interface with Erlang records\n\nThe macros `defrecord/3` and `defrecordp/3` can be used to create records\nwhile `extract/2` and `extract_all/1` can be used to extract records from\nErlang files."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Record.Elixir.Record <response> Types\n\nTypes can be defined for tuples with the `record/2` macro (only available in\ntypespecs). This macro will expand to a tuple as seen in the example below:\n\n    defmodule MyModule do\n      require Record\n      Record.defrecord(:user, name: \"john\", age: 25)\n\n      @type user :: record(:user, name: String.t(), age: integer)\n      # expands to: \"@type user :: {:user, String.t(), integer}\"\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Record.Elixir.Record <response> Reflection\n\nA list of all records in a module, if any, can be retrieved by reading the\n`@__records__` module attribute. It returns a list of maps with the record\nkind, name, tag, and fields. The attribute is only available inside the\nmodule definition."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.compile(source, options \\\\ \"\") <response> Compiles the regular expression.\n\nThe given options can either be a binary with the characters\nrepresenting the same regex options given to the\n`~r` (see `sigil_r/2`) sigil, or a list of options, as\nexpected by the Erlang's [`:re`](`:re`) module.\n\nIt returns `{:ok, regex}` in case of success,\n`{:error, reason}` otherwise.\n\n## Examples\n\n    iex> Regex.compile(\"foo\")\n    {:ok, ~r/foo/}\n\n    iex> Regex.compile(\"*foo\")\n    {:error, {'nothing to repeat', 0}}\n\n    iex> Regex.compile(\"foo\", \"i\")\n    {:ok, ~r/foo/i}\n\n    iex> Regex.compile(\"foo\", [:caseless])\n    {:ok, Regex.compile!(\"foo\", [:caseless])}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.compile!(source, options \\\\ \"\") <response> Compiles the regular expression and raises `Regex.CompileError` in case of errors."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.escape(string) <response> Escapes a string to be literally matched in a regex.\n\n## Examples\n\n    iex> Regex.escape(\".\")\n    \"\\\\.\"\n\n    iex> Regex.escape(\"\\\\what if\")\n    \"\\\\\\\\what\\\\ if\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.match?(regex, string) <response> Returns a boolean indicating whether there was a match or not.\n\n## Examples\n\n    iex> Regex.match?(~r/foo/, \"foo\")\n    true\n\n    iex> Regex.match?(~r/foo/, \"bar\")\n    false\n\nElixir also provides text-based match operator `=~/2` and function `String.match?/2` as\nan alternative to test strings against regular expressions and\nstrings."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.named_captures(regex, string, options \\\\ []) <response> Returns the given captures as a map or `nil` if no captures are found.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n\n## Examples\n\n    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n    %{\"foo\" => \"d\"}\n\n    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n\n    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.names(regex) <response> Returns a list of names in the regex.\n\n## Examples\n\n    iex> Regex.names(~r/(?<foo>bar)/)\n    [\"foo\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.opts(regex) <response> Returns the regex options, as a string or list depending on how\nit was compiled.\n\nSee the documentation of `Regex.compile/2` for more information.\n\n## Examples\n\n    iex> Regex.opts(~r/foo/m)\n    \"m\"\n\n    iex> Regex.opts(Regex.compile!(\"foo\", [:caseless]))\n    [:caseless]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.re_pattern(regex) <response> Returns the underlying `re_pattern` in the regular expression."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.recompile(regex) <response> Recompiles the existing regular expression if necessary.\n\nThis checks the version stored in the regular expression\nand recompiles the regex in case of version mismatch."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.recompile!(regex) <response> Recompiles the existing regular expression and raises `Regex.CompileError` in case of errors."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.regex?(term) <response> Returns `true` if the given `term` is a regex.\nOtherwise returns `false`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.replace(regex, string, replacement, options \\\\ []) <response> Receives a regex, a binary and a replacement, returns a new\nbinary where all matches are replaced by the replacement.\n\nThe replacement can be either a string or a function. The string\nis used as a replacement for every match and it allows specific\ncaptures to be accessed via `\\N` or `\\g{N}`, where `N` is the\ncapture. In case `\\0` is used, the whole match is inserted. Note\nthat in regexes the backslash needs to be escaped, hence in practice\nyou'll need to use `\\\\N` and `\\\\g{N}`.\n\nWhen the replacement is a function, the function may have arity\nN where each argument maps to a capture, with the first argument\nbeing the whole match. If the function expects more arguments\nthan captures found, the remaining arguments will receive `\"\"`.\n\n## Options\n\n  * `:global` - when `false`, replaces only the first occurrence\n    (defaults to `true`)\n\n## Examples\n\n    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n    \"abc\"\n\n    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n    \"adc\"\n\n    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n    \"a[b]c\"\n\n    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n    \"[b][d]\"\n\n    iex> Regex.replace(~r/\\.(\\d)$/, \"500.5\", \".\\\\g{1}0\")\n    \"500.50\"\n\n    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n    \"[b][d]\"\n\n    iex> Regex.replace(~r/a/, \"abcadc\", \"A\", global: false)\n    \"Abcadc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.run(regex, string, options \\\\ []) <response> Runs the regular expression against the given string until the first match.\nIt returns a list with all captures or `nil` if no match occurred.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n    to see the possible capture values.\n  * `:offset` - (since v1.12.0) specifies the starting offset to match in the given string.\n    Defaults to zero.\n\n## Examples\n\n    iex> Regex.run(~r/c(d)/, \"abcd\")\n    [\"cd\", \"d\"]\n\n    iex> Regex.run(~r/e/, \"abcd\")\n    nil\n\n    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n    [{2, 2}, {3, 1}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.scan(regex, string, options \\\\ []) <response> Same as `run/3`, but scans the target several times collecting all\nmatches of the regular expression.\n\nA list of lists is returned, where each entry in the primary list represents a\nmatch and each entry in the secondary list represents the captured contents.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n    to see the possible capture values.\n  * `:offset` - (since v1.12.0) specifies the starting offset to match in the given string.\n    Defaults to zero.\n\n## Examples\n\n    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n\n    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n    [[\"cd\"], [\"ce\"]]\n\n    iex> Regex.scan(~r/e/, \"abcd\")\n    []\n\n    iex> Regex.scan(~r/\\p{Sc}/u, \"$, Â£, and â¬\")\n    [[\"$\"], [\"Â£\"], [\"â¬\"]]\n\n    iex> Regex.scan(~r/=+/, \"=Ã¼â Æ8===\", return: :index)\n    [[{0, 1}], [{9, 3}]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.source(regex) <response> Returns the regex source as a binary.\n\n## Examples\n\n    iex> Regex.source(~r/foo/)\n    \"foo\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.split(regex, string, options \\\\ []) <response> Splits the given target based on the given pattern and in the given number of\nparts.\n\n## Options\n\n  * `:parts` - when specified, splits the string into the given number of\n    parts. If not specified, `:parts` defaults to `:infinity`, which will\n    split the string into the maximum number of parts possible based on the\n    given pattern.\n\n  * `:trim` - when `true`, removes empty strings (`\"\"`) from the result.\n    Defaults to `false`.\n\n  * `:on` - specifies which captures to split the string on, and in what\n    order. Defaults to `:first` which means captures inside the regex do not\n    affect the splitting process.\n\n  * `:include_captures` - when `true`, includes in the result the matches of\n    the regular expression. The matches are not counted towards the maximum\n    number of parts if combined with the `:parts` option. Defaults to `false`.\n\n## Examples\n\n    iex> Regex.split(~r{-}, \"a-b-c\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> Regex.split(~r{-}, \"a-b-c\", parts: 2)\n    [\"a\", \"b-c\"]\n\n    iex> Regex.split(~r{-}, \"abc\")\n    [\"abc\"]\n\n    iex> Regex.split(~r{}, \"abc\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\")\n    [\"\", \"\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second])\n    [\"a\", \"c\"]\n\n    iex> Regex.split(~r{(x)}, \"Elixir\", include_captures: true)\n    [\"Eli\", \"x\", \"ir\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second], include_captures: true)\n    [\"a\", \"b\", \"c\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.version() <response> Returns the version of the underlying Regex engine."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.Elixir.Regex <response> Provides regular expressions for Elixir.\n\nRegex is based on PCRE (Perl Compatible Regular Expressions) and\nbuilt on top of Erlang's `:re` module. More information can be found\nin the [`:re` module documentation](`:re`).\n\nRegular expressions in Elixir can be created using the sigils\n`~r` (see `sigil_r/2`) or `~R` (see `sigil_R/2`):\n\n    # A simple regular expression that matches foo anywhere in the string\n    ~r/foo/\n\n    # A regular expression with case insensitive and Unicode options\n    ~r/foo/iu\n\nRegular expressions created via sigils are pre-compiled and stored\nin the `.beam` file. Note that this may be a problem if you are precompiling\nElixir, see the \"Precompilation\" section for more information.\n\nA Regex is represented internally as the `Regex` struct. Therefore,\n`%Regex{}` can be used whenever there is a need to match on them.\nKeep in mind that all of the structs fields are private. There is\nalso not guarantee two regular expressions from the same source are\nequal, for example:\n\n    ~r/(?<foo>.)(?<bar>.)/ == ~r/(?<foo>.)(?<bar>.)/\n\nmay return `true` or `false` depending on your machine, endianness,\navailable optimizations and others. You can, however, retrieve the source\nof a compiled regular expression by accessing the `source` field, and then\ncompare those directly:\n\n    ~r/(?<foo>.)(?<bar>.)/.source == ~r/(?<foo>.)(?<bar>.)/.source"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.Elixir.Regex <response> Modifiers\n\nThe modifiers available when creating a Regex are:\n\n  * `:unicode` (u) - enables Unicode specific patterns like `\\p` and causes\n    character classes like `\\w`, `\\W`, `\\s`, and the like to also match on Unicode\n    (see examples below in \"Character classes\"). It expects valid Unicode\n    strings to be given on match\n\n  * `:caseless` (i) - adds case insensitivity\n\n  * `:dotall` (s) - causes dot to match newlines and also set newline to\n    anycrlf; the new line setting can be overridden by setting `(*CR)` or\n    `(*LF)` or `(*CRLF)` or `(*ANY)` according to `:re` documentation\n\n  * `:multiline` (m) - causes `^` and `$` to mark the beginning and end of\n    each line; use `\\A` and `\\z` to match the end or beginning of the string\n\n  * `:extended` (x) - whitespace characters are ignored except when escaped\n    and allow `#` to delimit comments\n\n  * `:firstline` (f) - forces the unanchored pattern to match before or at the\n    first newline, though the matched text may continue over the newline\n\n  * `:ungreedy` (U) - inverts the \"greediness\" of the regexp\n    (the previous `r` option is deprecated in favor of `U`)\n\nThe options not available are:\n\n  * `:anchored` - not available, use `^` or `\\A` instead\n  * `:dollar_endonly` - not available, use `\\z` instead\n  * `:no_auto_capture` - not available, use `?:` instead\n  * `:newline` - not available, use `(*CR)` or `(*LF)` or `(*CRLF)` or\n    `(*ANYCRLF)` or `(*ANY)` at the beginning of the regexp according to the\n    `:re` documentation"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.Elixir.Regex <response> Captures\n\nMany functions in this module handle what to capture in a regex\nmatch via the `:capture` option. The supported values are:\n\n  * `:all` - all captured subpatterns including the complete matching string\n    (this is the default)\n\n  * `:first` - only the first captured subpattern, which is always the\n    complete matching part of the string; all explicitly captured subpatterns\n    are discarded\n\n  * `:all_but_first` - all but the first matching subpattern, i.e. all\n    explicitly captured subpatterns, but not the complete matching part of\n    the string\n\n  * `:none` - does not return matching subpatterns at all\n\n  * `:all_names` - captures all named subpattern matches in the Regex as a list\n    ordered **alphabetically** by the names of the subpatterns\n\n  * `list(binary)` - a list of named captures to capture"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.Elixir.Regex <response> Character classes\n\nRegex supports several built in named character classes. These are used by\nenclosing the class name in `[: :]` inside a group. For example:\n\n    iex> String.match?(\"123\", ~r/^[[:alnum:]]+$/)\n    true\n    iex> String.match?(\"123 456\", ~r/^[[:alnum:][:blank:]]+$/)\n    true\n\nThe supported class names are:\n\n  * alnum - Letters and digits\n  * alpha - Letters\n  * blank - Space or tab only\n  * cntrl - Control characters\n  * digit - Decimal digits (same as \\\\d)\n  * graph - Printing characters, excluding space\n  * lower - Lowercase letters\n  * print - Printing characters, including space\n  * punct - Printing characters, excluding letters, digits, and space\n  * space - Whitespace (the same as \\s from PCRE 8.34)\n  * upper - Uppercase letters\n  * word  - \"Word\" characters (same as \\w)\n  * xdigit - Hexadecimal digits\n\nThere is another character class, `ascii`, that erroneously matches\nLatin-1 characters instead of the 0-127 range specified by POSIX. This\ncannot be fixed without altering the behaviour of other classes, so we\nrecommend matching the range with `[\\\\0-\\x7f]` instead.\n\nNote the behaviour of those classes may change according to the Unicode\nand other modifiers:\n\n    iex> String.match?(\"josÃ©\", ~r/^[[:lower:]]+$/)\n    false\n    iex> String.match?(\"josÃ©\", ~r/^[[:lower:]]+$/u)\n    true\n    iex> Regex.replace(~r/\\s/, \"Unicode\\u00A0spaces\", \"-\")\n    \"UnicodeÂ spaces\"\n    iex> Regex.replace(~r/\\s/u, \"Unicode\\u00A0spaces\", \"-\")\n    \"Unicode-spaces\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Regex.Elixir.Regex <response> Precompilation\n\nRegular expressions built with sigil are precompiled and stored in `.beam`\nfiles. Precompiled regexes will be checked in runtime and may work slower\nbetween operating systems and OTP releases. This is rarely a problem, as most Elixir code\nshared during development is compiled on the target (such as dependencies,\narchives, and escripts) and, when running in production, the code must either\nbe compiled on the target (via `mix compile` or similar) or released on the\nhost (via `mix releases` or similar) with a matching OTP, operating system\nand architecture as the target.\n\nIf you know you are running on a different system than the current one and\nyou are doing multiple matches with the regex, you can manually invoke\n`Regex.recompile/1` or `Regex.recompile!/1` to perform a runtime version\ncheck and recompile the regex if necessary."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.Partition.child_spec(init_arg) <response> Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.Partition.key_name(registry, partition) <response> Returns the name of key partition table."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.Partition.pid_name(name, partition) <response> Returns the name of pid partition table."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.Partition.start_link(registry, arg) <response> Starts the registry partition.\n\nThe process is only responsible for monitoring, demonitoring\nand cleaning up when monitored processes crash."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.Supervisor.child_spec(init_arg) <response> Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.child_spec(options) <response> Returns a specification to start a registry under a supervisor.\n\nSee `Supervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.count(registry) <response> Returns the number of registered keys in a registry.\nIt runs in constant time.\n\n## Examples\nIn the example below we register the current process and ask for the\nnumber of keys in the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueCountTest)\n    iex> Registry.count(Registry.UniqueCountTest)\n    0\n    iex> {:ok, _} = Registry.register(Registry.UniqueCountTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.UniqueCountTest, \"world\", :world)\n    iex> Registry.count(Registry.UniqueCountTest)\n    2\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateCountTest)\n    iex> Registry.count(Registry.DuplicateCountTest)\n    0\n    iex> {:ok, _} = Registry.register(Registry.DuplicateCountTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateCountTest, \"hello\", :world)\n    iex> Registry.count(Registry.DuplicateCountTest)\n    2"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.count_match(registry, key, pattern, guards \\\\ []) <response> Returns the number of `{pid, value}` pairs under the given `key` in `registry`\nthat match `pattern`.\n\nPattern must be an atom or a tuple that will match the structure of the\nvalue stored in the registry. The atom `:_` can be used to ignore a given\nvalue or tuple element, while the atom `:\"$1\"` can be used to temporarily assign part\nof pattern to a variable for a subsequent comparison.\n\nOptionally, it is possible to pass a list of guard conditions for more precise matching.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\nAvoid usage of special match variables `:\"$_\"` and `:\"$$\"`, because it might not work as expected.\n\nZero will be returned if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process under the same\nkey in a duplicate registry but with different values:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.CountMatchTest)\n    iex> {:ok, _} = Registry.register(Registry.CountMatchTest, \"hello\", {1, :atom, 1})\n    iex> {:ok, _} = Registry.register(Registry.CountMatchTest, \"hello\", {2, :atom, 2})\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {1, :_, :_})\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {2, :_, :_})\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :atom, :_})\n    2\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:\"$1\", :_, :\"$1\"})\n    2\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :_, :\"$1\"}, [{:>, :\"$1\", 1}])\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :\"$1\", :_}, [{:is_atom, :\"$1\"}])\n    2"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.count_select(registry, spec) <response> Works like `select/2`, but only returns the number of matching records.\n\n## Examples\n\nIn the example below we register the current process under different\nkeys in a unique registry but with the same value:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.CountSelectTest)\n    iex> {:ok, _} = Registry.register(Registry.CountSelectTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.CountSelectTest, \"world\", :value)\n    iex> Registry.count_select(Registry.CountSelectTest, [{{:_, :_, :value}, [], [true]}])\n    2"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.delete_meta(registry, key) <response> Deletes registry metadata for the given `key` in `registry`.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.DeleteMetaTest)\n    iex> Registry.put_meta(Registry.DeleteMetaTest, :custom_key, \"custom_value\")\n    :ok\n    iex> Registry.meta(Registry.DeleteMetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.delete_meta(Registry.DeleteMetaTest, :custom_key)\n    :ok\n    iex> Registry.meta(Registry.DeleteMetaTest, :custom_key)\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.dispatch(registry, key, mfa_or_fun, opts \\\\ []) <response> Invokes the callback with all entries under `key` in each partition\nfor the given `registry`.\n\nThe list of `entries` is a non-empty list of two-element tuples where\nthe first element is the PID and the second element is the value\nassociated to the PID. If there are no entries for the given key,\nthe callback is never invoked.\n\nIf the registry is partitioned, the callback is invoked multiple times\nper partition. If the registry is partitioned and `parallel: true` is\ngiven as an option, the dispatching happens in parallel. In both cases,\nthe callback is only invoked if there are entries for that partition.\n\nSee the module documentation for examples of using the `dispatch/3`\nfunction for building custom dispatching or a pubsub system."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.keys(registry, pid) <response> Returns the known keys for the given `pid` in `registry` in no particular order.\n\nIf the registry is unique, the keys are unique. Otherwise\nthey may contain duplicates if the process was registered\nunder the same key multiple times. The list will be empty\nif the process is dead or it has no keys in this registry.\n\n## Examples\n\nRegistering under a unique registry does not allow multiple entries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueKeysTest)\n    iex> Registry.keys(Registry.UniqueKeysTest, self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueKeysTest, \"hello\", :world)\n    iex> Registry.register(Registry.UniqueKeysTest, \"hello\", :later) # registry is :unique\n    {:error, {:already_registered, self()}}\n    iex> Registry.keys(Registry.UniqueKeysTest, self())\n    [\"hello\"]\n\nSuch is possible for duplicate registries though:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateKeysTest)\n    iex> Registry.keys(Registry.DuplicateKeysTest, self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateKeysTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateKeysTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateKeysTest, self())\n    [\"hello\", \"hello\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.lookup(registry, key) <response> Finds the `{pid, value}` pair for the given `key` in `registry` in no particular order.\n\nAn empty list if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process and look it up\nboth from itself and other processes:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueLookupTest)\n    iex> Registry.lookup(Registry.UniqueLookupTest, \"hello\")\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueLookupTest, \"hello\", :world)\n    iex> Registry.lookup(Registry.UniqueLookupTest, \"hello\")\n    [{self(), :world}]\n    iex> Task.async(fn -> Registry.lookup(Registry.UniqueLookupTest, \"hello\") end) |> Task.await()\n    [{self(), :world}]\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateLookupTest)\n    iex> Registry.lookup(Registry.DuplicateLookupTest, \"hello\")\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :world)\n    iex> Registry.lookup(Registry.DuplicateLookupTest, \"hello\")\n    [{self(), :world}]\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :another)\n    iex> Enum.sort(Registry.lookup(Registry.DuplicateLookupTest, \"hello\"))\n    [{self(), :another}, {self(), :world}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.match(registry, key, pattern, guards \\\\ []) <response> Returns `{pid, value}` pairs under the given `key` in `registry` that match `pattern`.\n\nPattern must be an atom or a tuple that will match the structure of the\nvalue stored in the registry. The atom `:_` can be used to ignore a given\nvalue or tuple element, while the atom `:\"$1\"` can be used to temporarily assign part\nof pattern to a variable for a subsequent comparison.\n\nOptionally, it is possible to pass a list of guard conditions for more precise matching.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\nAvoid usage of special match variables `:\"$_\"` and `:\"$$\"`, because it might not work as expected.\n\nAn empty list will be returned if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process under the same\nkey in a duplicate registry but with different values:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.MatchTest)\n    iex> {:ok, _} = Registry.register(Registry.MatchTest, \"hello\", {1, :atom, 1})\n    iex> {:ok, _} = Registry.register(Registry.MatchTest, \"hello\", {2, :atom, 2})\n    iex> Registry.match(Registry.MatchTest, \"hello\", {1, :_, :_})\n    [{self(), {1, :atom, 1}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {2, :_, :_})\n    [{self(), {2, :atom, 2}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :atom, :_}) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:\"$1\", :_, :\"$1\"}) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n    iex> guards = [{:>, :\"$1\", 1}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :_, :\"$1\"}, guards)\n    [{self(), {2, :atom, 2}}]\n    iex> guards = [{:is_atom, :\"$1\"}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :\"$1\", :_}, guards) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.meta(registry, key) <response> Reads registry metadata given on `start_link/1`.\n\nAtoms and tuples are allowed as keys.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.MetaTest, meta: [custom_key: \"custom_value\"])\n    iex> Registry.meta(Registry.MetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.meta(Registry.MetaTest, :unknown_key)\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.put_meta(registry, key, value) <response> Stores registry metadata.\n\nAtoms and tuples are allowed as keys.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.PutMetaTest)\n    iex> Registry.put_meta(Registry.PutMetaTest, :custom_key, \"custom_value\")\n    :ok\n    iex> Registry.meta(Registry.PutMetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.put_meta(Registry.PutMetaTest, {:tuple, :key}, \"tuple_value\")\n    :ok\n    iex> Registry.meta(Registry.PutMetaTest, {:tuple, :key})\n    {:ok, \"tuple_value\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.register(registry, key, value) <response> Registers the current process under the given `key` in `registry`.\n\nA value to be associated with this registration must also be given.\nThis value will be retrieved whenever dispatching or doing a key\nlookup.\n\nThis function returns `{:ok, owner}` or `{:error, reason}`.\nThe `owner` is the PID in the registry partition responsible for\nthe PID. The owner is automatically linked to the caller.\n\nIf the registry has unique keys, it will return `{:ok, owner}` unless\nthe key is already associated to a PID, in which case it returns\n`{:error, {:already_registered, pid}}`.\n\nIf the registry has duplicate keys, multiple registrations from the\ncurrent process under the same key are allowed.\n\n## Examples\n\nRegistering under a unique registry does not allow multiple entries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueRegisterTest)\n    iex> {:ok, _} = Registry.register(Registry.UniqueRegisterTest, \"hello\", :world)\n    iex> Registry.register(Registry.UniqueRegisterTest, \"hello\", :later)\n    {:error, {:already_registered, self()}}\n    iex> Registry.keys(Registry.UniqueRegisterTest, self())\n    [\"hello\"]\n\nSuch is possible for duplicate registries though:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateRegisterTest)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateRegisterTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateRegisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateRegisterTest, self())\n    [\"hello\", \"hello\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.select(registry, spec) <response> Select key, pid, and values registered using full match specs.\n\nThe `spec` consists of a list of three part tuples, in the shape of `[{match_pattern, guards, body}]`.\n\nThe first part, the match pattern, must be a tuple that will match the structure of the\nthe data stored in the registry, which is `{key, pid, value}`. The atom `:_` can be used to\nignore a given value or tuple element, while the atom `:\"$1\"` can be used to temporarily\nassign part of pattern to a variable for a subsequent comparison. This can be combined\nlike `{:\"$1\", :_, :_}`.\n\nThe second part, the guards, is a list of conditions that allow filtering the results.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\n\nThe third part, the body, is a list of shapes of the returned entries. Like guards, you have access to\nassigned variables like `:\"$1\"`, which you can combine with hardcoded values to freely shape entries\nNote that tuples have to be wrapped in an additional tuple. To get a result format like\n`%{key: key, pid: pid, value: value}`, assuming you bound those variables in order in the match part,\nyou would provide a body like `[%{key: :\"$1\", pid: :\"$2\", value: :\"$3\"}]`. Like guards, you can use\nsome operations like `:element` to modify the output format.\n\nDo not use special match variables `:\"$_\"` and `:\"$$\"`, because they might not work as expected.\n\nNote that for large registries with many partitions this will be costly as it builds the result by\nconcatenating all the partitions.\n\n## Examples\n\nThis example shows how to get everything from the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.SelectAllTest)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"world\", :value)\n    iex> Registry.select(Registry.SelectAllTest, [{{:\"$1\", :\"$2\", :\"$3\"}, [], [{{:\"$1\", :\"$2\", :\"$3\"}}]}])\n    [{\"world\", self(), :value}, {\"hello\", self(), :value}]\n\nGet all keys in the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.SelectAllTest)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"world\", :value)\n    iex> Registry.select(Registry.SelectAllTest, [{{:\"$1\", :_, :_}, [], [:\"$1\"]}])\n    [\"world\", \"hello\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.start_link(options) <response> Starts the registry as a supervisor process.\n\nManually it can be started as:\n\n    Registry.start_link(keys: :unique, name: MyApp.Registry)\n\nIn your supervisor tree, you would write:\n\n    Supervisor.start_link([\n      {Registry, keys: :unique, name: MyApp.Registry}\n    ], strategy: :one_for_one)\n\nFor intensive workloads, the registry may also be partitioned (by specifying\nthe `:partitions` option). If partitioning is required then a good default is to\nset the number of partitions to the number of schedulers available:\n\n    Registry.start_link(\n      keys: :unique,\n      name: MyApp.Registry,\n      partitions: System.schedulers_online()\n    )\n\nor:\n\n    Supervisor.start_link([\n      {Registry, keys: :unique, name: MyApp.Registry, partitions: System.schedulers_online()}\n    ], strategy: :one_for_one)\n\n## Options\n\nThe registry requires the following keys:\n\n  * `:keys` - chooses if keys are `:unique` or `:duplicate`\n  * `:name` - the name of the registry and its tables\n\nThe following keys are optional:\n\n  * `:partitions` - the number of partitions in the registry. Defaults to `1`.\n  * `:listeners` - a list of named processes which are notified of `:register`\n    and `:unregister` events. The registered process must be monitored by the\n    listener if the listener wants to be notified if the registered process\n    crashes.\n  * `:meta` - a keyword list of metadata to be attached to the registry."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.unregister(registry, key) <response> Unregisters all entries for the given `key` associated to the current\nprocess in `registry`.\n\nAlways returns `:ok` and automatically unlinks the current process from\nthe owner if there are no more keys associated to the current process. See\nalso `register/3` to read more about the \"owner\".\n\n## Examples\n\nFor unique registries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueUnregisterTest)\n    iex> Registry.register(Registry.UniqueUnregisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.UniqueUnregisterTest, self())\n    [\"hello\"]\n    iex> Registry.unregister(Registry.UniqueUnregisterTest, \"hello\")\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterTest, self())\n    []\n\nFor duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateUnregisterTest)\n    iex> Registry.register(Registry.DuplicateUnregisterTest, \"hello\", :world)\n    iex> Registry.register(Registry.DuplicateUnregisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateUnregisterTest, self())\n    [\"hello\", \"hello\"]\n    iex> Registry.unregister(Registry.DuplicateUnregisterTest, \"hello\")\n    :ok\n    iex> Registry.keys(Registry.DuplicateUnregisterTest, self())\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.unregister_match(registry, key, pattern, guards \\\\ []) <response> Unregisters entries for keys matching a pattern associated to the current\nprocess in `registry`.\n\n## Examples\n\nFor unique registries it can be used to conditionally unregister a key on\nthe basis of whether or not it matches a particular value.\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueUnregisterMatchTest)\n    iex> Registry.register(Registry.UniqueUnregisterMatchTest, \"hello\", :world)\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    [\"hello\"]\n    iex> Registry.unregister_match(Registry.UniqueUnregisterMatchTest, \"hello\", :foo)\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    [\"hello\"]\n    iex> Registry.unregister_match(Registry.UniqueUnregisterMatchTest, \"hello\", :world)\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    []\n\nFor duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateUnregisterMatchTest)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_a)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_b)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_c)\n    iex> Registry.keys(Registry.DuplicateUnregisterMatchTest, self())\n    [\"hello\", \"hello\", \"hello\"]\n    iex> Registry.unregister_match(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_a)\n    :ok\n    iex> Registry.keys(Registry.DuplicateUnregisterMatchTest, self())\n    [\"hello\", \"hello\"]\n    iex> Registry.lookup(Registry.DuplicateUnregisterMatchTest, \"hello\")\n    [{self(), :world_b}, {self(), :world_c}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.update_value(registry, key, callback) <response> Updates the value for `key` for the current process in the unique `registry`.\n\nReturns a `{new_value, old_value}` tuple or `:error` if there\nis no such key assigned to the current process.\n\nIf a non-unique registry is given, an error is raised.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UpdateTest)\n    iex> {:ok, _} = Registry.register(Registry.UpdateTest, \"hello\", 1)\n    iex> Registry.lookup(Registry.UpdateTest, \"hello\")\n    [{self(), 1}]\n    iex> Registry.update_value(Registry.UpdateTest, \"hello\", &(&1 + 1))\n    {2, 1}\n    iex> Registry.lookup(Registry.UpdateTest, \"hello\")\n    [{self(), 2}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.values(registry, key, pid) <response> Reads the values for the given `key` for `pid` in `registry`.\n\nFor unique registries, it is either an empty list or a list\nwith a single element. For duplicate registries, it is a list\nwith zero, one, or multiple elements.\n\n## Examples\n\nIn the example below we register the current process and look it up\nboth from itself and other processes:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueLookupTest)\n    iex> Registry.values(Registry.UniqueLookupTest, \"hello\", self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueLookupTest, \"hello\", :world)\n    iex> Registry.values(Registry.UniqueLookupTest, \"hello\", self())\n    [:world]\n    iex> Task.async(fn -> Registry.values(Registry.UniqueLookupTest, \"hello\", self()) end) |> Task.await()\n    []\n    iex> parent = self()\n    iex> Task.async(fn -> Registry.values(Registry.UniqueLookupTest, \"hello\", parent) end) |> Task.await()\n    [:world]\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateLookupTest)\n    iex> Registry.values(Registry.DuplicateLookupTest, \"hello\", self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :world)\n    iex> Registry.values(Registry.DuplicateLookupTest, \"hello\", self())\n    [:world]\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :another)\n    iex> Enum.sort(Registry.values(Registry.DuplicateLookupTest, \"hello\", self()))\n    [:another, :world]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.Elixir.Registry <response> A local, decentralized and scalable key-value process storage.\n\nIt allows developers to lookup one or more processes with a given key.\nIf the registry has `:unique` keys, a key points to 0 or 1 process.\nIf the registry allows `:duplicate` keys, a single key may point to any\nnumber of processes. In both cases, different keys could identify the\nsame process.\n\nEach entry in the registry is associated to the process that has\nregistered the key. If the process crashes, the keys associated to that\nprocess are automatically removed. All key comparisons in the registry\nare done using the match operation (`===/2`).\n\nThe registry can be used for different purposes, such as name lookups (using\nthe `:via` option), storing properties, custom dispatching rules, or a pubsub\nimplementation. We explore some of those use cases below.\n\nThe registry may also be transparently partitioned, which provides\nmore scalable behaviour for running registries on highly concurrent\nenvironments with thousands or millions of entries."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.Elixir.Registry <response> Using in `:via`\n\nOnce the registry is started with a given name using\n`Registry.start_link/1`, it can be used to register and access named\nprocesses using the `{:via, Registry, {registry, key}}` tuple:\n\n    {:ok, _} = Registry.start_link(keys: :unique, name: Registry.ViaTest)\n    name = {:via, Registry, {Registry.ViaTest, \"agent\"}}\n    {:ok, _} = Agent.start_link(fn -> 0 end, name: name)\n    Agent.get(name, & &1)\n    #=> 0\n    Agent.update(name, &(&1 + 1))\n    Agent.get(name, & &1)\n    #=> 1\n\nIn the previous example, we were not interested in associating a value to the\nprocess:\n\n    Registry.lookup(Registry.ViaTest, \"agent\")\n    #=> [{self(), nil}]\n\nHowever, in some cases it may be desired to associate a value to the process\nusing the alternate `{:via, Registry, {registry, key, value}}` tuple:\n\n    {:ok, _} = Registry.start_link(keys: :unique, name: Registry.ViaTest)\n    name = {:via, Registry, {Registry.ViaTest, \"agent\", :hello}}\n    {:ok, agent_pid} = Agent.start_link(fn -> 0 end, name: name)\n    Registry.lookup(Registry.ViaTest, \"agent\")\n    #=> [{agent_pid, :hello}]\n\nTo this point, we have been starting `Registry` using `start_link/1`.\nTypically the registry is started as part of a supervision tree though:\n\n    {Registry, keys: :unique, name: Registry.ViaTest}\n\nOnly registries with unique keys can be used in `:via`. If the name is\nalready taken, the case-specific `start_link` function (`Agent.start_link/2`\nin the example above) will return `{:error, {:already_started, current_pid}}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.Elixir.Registry <response> Using as a dispatcher\n\n`Registry` has a dispatch mechanism that allows developers to implement custom\ndispatch logic triggered from the caller. For example, let's say we have a\nduplicate registry started as so:\n\n    {:ok, _} = Registry.start_link(keys: :duplicate, name: Registry.DispatcherTest)\n\nBy calling `register/3`, different processes can register under a given key\nand associate any value under that key. In this case, let's register the\ncurrent process under the key `\"hello\"` and attach the `{IO, :inspect}` tuple\nto it:\n\n    {:ok, _} = Registry.register(Registry.DispatcherTest, \"hello\", {IO, :inspect})\n\nNow, an entity interested in dispatching events for a given key may call\n`dispatch/3` passing in the key and a callback. This callback will be invoked\nwith a list of all the values registered under the requested key, alongside\nthe PID of the process that registered each value, in the form of `{pid,\nvalue}` tuples. In our example, `value` will be the `{module, function}` tuple\nin the code above:\n\n    Registry.dispatch(Registry.DispatcherTest, \"hello\", fn entries ->\n      for {pid, {module, function}} <- entries, do: apply(module, function, [pid])\n    end)\n    # Prints #PID<...> where the PID is for the process that called register/3 above\n    #=> :ok\n\nDispatching happens in the process that calls `dispatch/3` either serially or\nconcurrently in case of multiple partitions (via spawned tasks). The\nregistered processes are not involved in dispatching unless involving them is\ndone explicitly (for example, by sending them a message in the callback).\n\nFurthermore, if there is a failure when dispatching, due to a bad\nregistration, dispatching will always fail and the registered process will not\nbe notified. Therefore let's make sure we at least wrap and report those\nerrors:\n\n    require Logger\n\n    Registry.dispatch(Registry.DispatcherTest, \"hello\", fn entries ->\n      for {pid, {module, function}} <- entries do\n        try do\n          apply(module, function, [pid])\n        catch\n          kind, reason ->\n            formatted = Exception.format(kind, reason, __STACKTRACE__)\n            Logger.error(\"Registry.dispatch/3 failed with #{formatted}\")\n        end\n      end\n    end)\n    # Prints #PID<...>\n    #=> :ok\n\nYou could also replace the whole `apply` system by explicitly sending\nmessages. That's the example we will see next."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.Elixir.Registry <response> Using as a PubSub\n\nRegistries can also be used to implement a local, non-distributed, scalable\nPubSub by relying on the `dispatch/3` function, similarly to the previous\nsection: in this case, however, we will send messages to each associated\nprocess, instead of invoking a given module-function.\n\nIn this example, we will also set the number of partitions to the number of\nschedulers online, which will make the registry more performant on highly\nconcurrent environments:\n\n    {:ok, _} =\n      Registry.start_link(\n        keys: :duplicate,\n        name: Registry.PubSubTest,\n        partitions: System.schedulers_online()\n      )\n\n    {:ok, _} = Registry.register(Registry.PubSubTest, \"hello\", [])\n\n    Registry.dispatch(Registry.PubSubTest, \"hello\", fn entries ->\n      for {pid, _} <- entries, do: send(pid, {:broadcast, \"world\"})\n    end)\n    #=> :ok\n\nThe example above broadcasted the message `{:broadcast, \"world\"}` to all\nprocesses registered under the \"topic\" (or \"key\" as we called it until now)\n`\"hello\"`.\n\nThe third argument given to `register/3` is a value associated to the\ncurrent process. While in the previous section we used it when dispatching,\nin this particular example we are not interested in it, so we have set it\nto an empty list. You could store a more meaningful value if necessary."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.Elixir.Registry <response> Registrations\n\nLooking up, dispatching and registering are efficient and immediate at\nthe cost of delayed unsubscription. For example, if a process crashes,\nits keys are automatically removed from the registry but the change may\nnot propagate immediately. This means certain operations may return processes\nthat are already dead. When such may happen, it will be explicitly stated\nin the function documentation.\n\nHowever, keep in mind those cases are typically not an issue. After all, a\nprocess referenced by a PID may crash at any time, including between getting\nthe value from the registry and sending it a message. Many parts of the standard\nlibrary are designed to cope with that, such as `Process.monitor/1` which will\ndeliver the `:DOWN` message immediately if the monitored process is already dead\nand `send/2` which acts as a no-op for dead processes."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Registry.Elixir.Registry <response> ETS\n\nNote that the registry uses one ETS table plus two ETS tables per partition."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Set.Elixir.Set <response> Generic API for sets.\n\nThis module is deprecated, use the `MapSet` module instead."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.chunk_by(enum, fun) <response> Chunks the `enum` by buffering elements for which `fun` returns the same value.\n\nElements are only emitted when `fun` returns a new value or the `enum` finishes.\n\n## Examples\n\n    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n    iex> Enum.to_list(stream)\n    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.chunk_every(enum, count) <response> Shortcut to `chunk_every(enum, count, count)`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.chunk_every(enum, count, step, leftover \\\\ []) <response> Streams the enumerable in chunks, containing `count` elements each,\nwhere each new chunk starts `step` elements into the enumerable.\n\n`step` is optional and, if not passed, defaults to `count`, i.e.\nchunks do not overlap.\n\nIf the last chunk does not have `count` elements to fill the chunk,\nelements are taken from `leftover` to fill in the chunk. If `leftover`\ndoes not have enough elements to fill the chunk, then a partial chunk\nis returned with less than `count` elements.\n\nIf `:discard` is given in `leftover`, the last chunk is discarded\nunless it has exactly `count` elements.\n\n## Examples\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list()\n    [[1, 2], [3, 4], [5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list()\n    [[1, 2, 3], [4, 5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0])) |> Enum.to_list()\n    [[1, 2, 3], [4, 0, 0]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.chunk_while(enum, acc, chunk_fun, after_fun) <response> Chunks the `enum` with fine grained control when every chunk is emitted.\n\n`chunk_fun` receives the current element and the accumulator and\nmust return `{:cont, element, acc}` to emit the given chunk and\ncontinue with accumulator or `{:cont, acc}` to not emit any chunk\nand continue with the return accumulator.\n\n`after_fun` is invoked when iteration is done and must also return\n`{:cont, element, acc}` or `{:cont, acc}`.\n\n## Examples\n\n    iex> chunk_fun = fn element, acc ->\n    ...>   if rem(element, 2) == 0 do\n    ...>     {:cont, Enum.reverse([element | acc]), []}\n    ...>   else\n    ...>     {:cont, [element | acc]}\n    ...>   end\n    ...> end\n    iex> after_fun = fn\n    ...>   [] -> {:cont, []}\n    ...>   acc -> {:cont, Enum.reverse(acc), []}\n    ...> end\n    iex> stream = Stream.chunk_while(1..10, [], chunk_fun, after_fun)\n    iex> Enum.to_list(stream)\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.concat(enumerables) <response> Creates a stream that enumerates each enumerable in an enumerable.\n\n## Examples\n\n    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.concat(first, second) <response> Creates a stream that enumerates the first argument, followed by the second.\n\n## Examples\n\n    iex> stream = Stream.concat(1..3, 4..6)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> stream1 = Stream.cycle([1, 2, 3])\n    iex> stream2 = Stream.cycle([4, 5, 6])\n    iex> stream = Stream.concat(stream1, stream2)\n    iex> Enum.take(stream, 6)\n    [1, 2, 3, 1, 2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.cycle(enumerable) <response> Creates a stream that cycles through the given enumerable,\ninfinitely.\n\n## Examples\n\n    iex> stream = Stream.cycle([1, 2, 3])\n    iex> Enum.take(stream, 5)\n    [1, 2, 3, 1, 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.dedup(enum) <response> Creates a stream that only emits elements if they are different from the last emitted element.\n\nThis function only ever needs to store the last emitted element.\n\nElements are compared using `===/2`.\n\n## Examples\n\n    iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3, 2, 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.dedup_by(enum, fun) <response> Creates a stream that only emits elements if the result of calling `fun` on the element is\ndifferent from the (stored) result of calling `fun` on the last emitted element.\n\n## Examples\n\n    iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}, {1, :x}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.drop(enum, n) <response> Lazily drops the next `n` elements from the enumerable.\n\nIf a negative `n` is given, it will drop the last `n` elements from\nthe collection. Note that the mechanism by which this is implemented\nwill delay the emission of any element until `n` additional elements have\nbeen emitted by the enum.\n\n## Examples\n\n    iex> stream = Stream.drop(1..10, 5)\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]\n\n    iex> stream = Stream.drop(1..10, -5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.drop_every(enum, nth) <response> Creates a stream that drops every `nth` element from the enumerable.\n\nThe first element is always dropped, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.drop_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.drop_every(1..1000, 1)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.drop_every([1, 2, 3, 4, 5], 0)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.drop_while(enum, fun) <response> Lazily drops elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.duplicate(value, n) <response> Duplicates the given element `n` times in a stream.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty stream is returned.\n\n## Examples\n\n    iex> stream = Stream.duplicate(\"hello\", 0)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.duplicate(\"hi\", 1)\n    iex> Enum.to_list(stream)\n    [\"hi\"]\n\n    iex> stream = Stream.duplicate(\"bye\", 2)\n    iex> Enum.to_list(stream)\n    [\"bye\", \"bye\"]\n\n    iex> stream = Stream.duplicate([1, 2], 3)\n    iex> Enum.to_list(stream)\n    [[1, 2], [1, 2], [1, 2]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.each(enum, fun) <response> Executes the given function for each element.\n\nThe values in the stream do not change, therefore this\nfunction is useful for adding side effects (like printing)\nto a stream. See `map/2` if producing a different stream\nis desired.\n\n## Examples\n\n    iex> stream = Stream.each([1, 2, 3], fn x -> send(self(), x) end)\n    iex> Enum.to_list(stream)\n    iex> receive do: (x when is_integer(x) -> x)\n    1\n    iex> receive do: (x when is_integer(x) -> x)\n    2\n    iex> receive do: (x when is_integer(x) -> x)\n    3"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.filter(enum, fun) <response> Creates a stream that filters elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.flat_map(enum, mapper) <response> Maps the given `fun` over `enumerable` and flattens the result.\n\nThis function returns a new stream built by appending the result of invoking `fun`\non each element of `enumerable` together.\n\n## Examples\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [x, x * 2] end)\n    iex> Enum.to_list(stream)\n    [1, 2, 2, 4, 3, 6]\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [[x]] end)\n    iex> Enum.to_list(stream)\n    [[1], [2], [3]]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.intersperse(enumerable, intersperse_element) <response> Lazily intersperses `intersperse_element` between each element of the enumeration.\n\n## Examples\n\n    iex> Stream.intersperse([1, 2, 3], 0) |> Enum.to_list()\n    [1, 0, 2, 0, 3]\n\n    iex> Stream.intersperse([1], 0) |> Enum.to_list()\n    [1]\n\n    iex> Stream.intersperse([], 0) |> Enum.to_list()\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.interval(n) <response> Creates a stream that emits a value after the given period `n`\nin milliseconds.\n\nThe values emitted are an increasing counter starting at `0`.\nThis operation will block the caller by the given interval\nevery time a new element is streamed.\n\nDo not use this function to generate a sequence of numbers.\nIf blocking the caller process is not necessary, use\n`Stream.iterate(0, & &1 + 1)` instead.\n\n## Examples\n\n    iex> Stream.interval(10) |> Enum.take(10)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.into(enum, collectable, transform \\\\ fn x -> x end) <response> Injects the stream values into the given collectable as a side-effect.\n\nThis function is often used with `run/1` since any evaluation\nis delayed until the stream is executed. See `run/1` for an example."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.iterate(start_value, next_fun) <response> Emits a sequence of values, starting with `start_value`. Successive\nvalues are generated by calling `next_fun` on the previous value.\n\n## Examples\n\n    iex> Stream.iterate(0, &(&1 + 1)) |> Enum.take(5)\n    [0, 1, 2, 3, 4]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.map(enum, fun) <response> Creates a stream that will apply the given function on\nenumeration.\n\n## Examples\n\n    iex> stream = Stream.map([1, 2, 3], fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.map_every(enum, nth, fun) <response> Creates a stream that will apply the given function on\nevery `nth` element from the enumerable.\n\nThe first element is always passed to the given function.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.map_every(1..10, 2, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n\n    iex> stream = Stream.map_every([1, 2, 3, 4, 5], 1, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.map_every(1..5, 0, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.reject(enum, fun) <response> Creates a stream that will reject elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [1, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.repeatedly(generator_fun) <response> Returns a stream generated by calling `generator_fun` repeatedly.\n\n## Examples\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Stream.repeatedly(&:rand.uniform/0) |> Enum.take(3)\n    [0.5455598952593053, 0.6039309974353404, 0.6684893034823949]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.resource(start_fun, next_fun, after_fun) <response> Emits a sequence of values for the given resource.\n\nSimilar to `transform/3` but the initial accumulated value is\ncomputed lazily via `start_fun` and executes an `after_fun` at\nthe end of enumeration (both in cases of success and failure).\n\nSuccessive values are generated by calling `next_fun` with the\nprevious accumulator (the initial value being the result returned\nby `start_fun`) and it must return a tuple containing a list\nof elements to be emitted and the next accumulator. The enumeration\nfinishes if it returns `{:halt, acc}`.\n\nAs the name says, this function is useful to stream values from\nresources.\n\n## Examples\n\n    Stream.resource(\n      fn -> File.open!(\"sample\") end,\n      fn file ->\n        case IO.read(file, :line) do\n          data when is_binary(data) -> {[data], file}\n          _ -> {:halt, file}\n        end\n      end,\n      fn file -> File.close(file) end\n    )\n\n    iex> Stream.resource(\n    ...>  fn ->\n    ...>    {:ok, pid} = StringIO.open(\"string\")\n    ...>    pid\n    ...>  end,\n    ...>  fn pid ->\n    ...>    case IO.getn(pid, \"\", 1) do\n    ...>      :eof -> {:halt, pid}\n    ...>      char -> {[char], pid}\n    ...>    end\n    ...>  end,\n    ...>  fn pid -> StringIO.close(pid) end\n    ...> ) |> Enum.to_list()\n    [\"s\", \"t\", \"r\", \"i\", \"n\", \"g\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.run(stream) <response> Runs the given stream.\n\nThis is useful when a stream needs to be run, for side effects,\nand there is no interest in its return result.\n\n## Examples\n\nOpen up a file, replace all `#` by `%` and stream to another file\nwithout loading the whole file in memory:\n\n    File.stream!(\"/path/to/file\")\n    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n    |> Stream.into(File.stream!(\"/path/to/other/file\"))\n    |> Stream.run()\n\nNo computation will be done until we call one of the `Enum` functions\nor `run/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.scan(enum, fun) <response> Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the first element in the enumerable\nas the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.scan(enum, acc, fun) <response> Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the given `acc` as the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.take(enum, count) <response> Lazily takes the next `count` elements from the enumerable and stops\nenumeration.\n\nIf a negative `count` is given, the last `count` values will be taken.\nFor such, the collection is fully enumerated keeping up to `2 * count`\nelements in memory. Once the end of the collection is reached,\nthe last `count` elements will be executed. Therefore, using\na negative `count` on an infinite collection will never return.\n\n## Examples\n\n    iex> stream = Stream.take(1..100, 5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take(1..100, -5)\n    iex> Enum.to_list(stream)\n    [96, 97, 98, 99, 100]\n\n    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 1, 2]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.take_every(enum, nth) <response> Creates a stream that takes every `nth` element from the enumerable.\n\nThe first element is always included, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.take_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [1, 3, 5, 7, 9]\n\n    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take_every(1..1000, 0)\n    iex> Enum.to_list(stream)\n    []"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.take_while(enum, fun) <response> Lazily takes elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.timer(n) <response> Creates a stream that emits a single value after `n` milliseconds.\n\nThe value emitted is `0`. This operation will block the caller by\nthe given time until the element is streamed.\n\n## Examples\n\n    iex> Stream.timer(10) |> Enum.to_list()\n    [0]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.transform(enum, acc, reducer) <response> Transforms an existing stream.\n\nIt expects an accumulator and a function that receives two arguments,\nthe stream element and the updated accumulator. It must return a tuple,\nwhere the first element is a new stream (often a list) or the atom `:halt`,\nand the second element is the accumulator to be used by the next element.\n\nNote: this function is equivalent to `Enum.flat_map_reduce/3`, except this\nfunction does not return the accumulator once the stream is processed.\n\n## Examples\n\n`Stream.transform/3` is useful as it can be used as the basis to implement\nmany of the functions defined in this module. For example, we can implement\n`Stream.take(enum, n)` as follows:\n\n    iex> enum = 1001..9999\n    iex> n = 3\n    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n    ...> end)\n    iex> Enum.to_list(stream)\n    [1001, 1002, 1003]\n\n`Stream.transform/5` further generalizes this function to allow wrapping\naround resources."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.transform(enum, start_fun, reducer, after_fun) <response> Similar to `Stream.transform/5`, except `last_fun` is not supplied.\n\nThis function can be seen as a combination of `Stream.resource/3` with\n`Stream.transform/3`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.transform(enum, start_fun, reducer, last_fun, after_fun) <response> Transforms an existing stream with function-based start, last, and after\ncallbacks.\n\nOnce transformation starts, `start_fun` is invoked to compute the initial\naccumulator. Then, for each element in the enumerable, the `reducer` function\nis invoked with the element and the accumulator, returning new elements and a\nnew accumulator, as in `transform/3`.\n\nOnce the collection is done, `last_fun` is invoked with the accumulator to\nemit any remaining items. Then `after_fun` is invoked, to close any resource,\nbut not emitting any new items. `last_fun` is only invoked if the given\nenumerable terminates successfully (either because it is done or it halted\nitself). `after_fun` is always invoked, therefore `after_fun` must be the\none used for closing resources."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.unfold(next_acc, next_fun) <response> Emits a sequence of values for the given accumulator.\n\nSuccessive values are generated by calling `next_fun` with the previous\naccumulator and it must return a tuple with the current value and next\naccumulator. The enumeration finishes if it returns `nil`.\n\n## Examples\n\n    iex> Stream.unfold(5, fn\n    ...>   0 -> nil\n    ...>   n -> {n, n - 1}\n    ...> end) |> Enum.to_list()\n    [5, 4, 3, 2, 1]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.uniq(enum) <response> Creates a stream that only emits elements if they are unique.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Examples\n\n    iex> Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.uniq_by(enum, fun) <response> Creates a stream that only emits elements if they are unique, by removing the\nelements for which function `fun` returned duplicate elements.\n\nThe function `fun` maps every element to a term which is used to\ndetermine if two elements are duplicates.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Example\n\n    iex> Stream.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}]\n\n    iex> Stream.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end) |> Enum.to_list()\n    [a: {:tea, 2}, c: {:coffee, 1}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.with_index(enum, offset \\\\ 0) <response> Creates a stream where each element in the enumerable will\nbe wrapped in a tuple alongside its index.\n\nIf an `offset` is given, we will index from the given offset instead of from zero.\n\n## Examples\n\n    iex> stream = Stream.with_index([1, 2, 3])\n    iex> Enum.to_list(stream)\n    [{1, 0}, {2, 1}, {3, 2}]\n\n    iex> stream = Stream.with_index([1, 2, 3], 3)\n    iex> Enum.to_list(stream)\n    [{1, 3}, {2, 4}, {3, 5}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip(enumerables) <response> Zips corresponding elements from a finite collection of enumerables\ninto one stream of tuples.\n\nThe zipping finishes as soon as any enumerable in the given collection completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([\"foo\", \"bar\", \"baz\"])\n    iex> Stream.zip([concat, [:a, :b, :c], cycle]) |> Enum.to_list()\n    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip(enumerable1, enumerable2) <response> Zips two enumerables together, lazily.\n\nThe zipping finishes as soon as either enumerable completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([:a, :b, :c])\n    iex> Stream.zip(concat, cycle) |> Enum.to_list()\n    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip_with(enumerables, zip_fun) <response> Lazily zips corresponding elements from a finite collection of enumerables into a new\nenumerable, transforming them with the `zip_fun` function as it goes.\n\nThe first element from each of the enums in `enumerables` will be put into a list which is then passed to\nthe one-arity `zip_fun` function. Then, the second elements from each of the enums are put into a list and passed to\n`zip_fun`, and so on until any one of the enums in `enumerables` completes.\n\nReturns a new enumerable with the results of calling `zip_fun`.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat], fn [a, b] -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat, 1..3], fn [a, b, c] -> a + b + c end) |> Enum.to_list()\n    [3, 6, 9]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.zip_with(enumerable1, enumerable2, zip_fun) <response> Lazily zips corresponding elements from two enumerables into a new one, transforming them with\nthe `zip_fun` function as it goes.\n\nThe `zip_fun` will be called with the first element from `enumerable1` and the first\nelement from `enumerable2`, then with the second element from each, and so on until\neither one of the enumerables completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with(concat, concat, fn a, b -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.Elixir.Stream <response> Functions for creating and composing streams.\n\nStreams are composable, lazy enumerables (for an introduction on\nenumerables, see the `Enum` module). Any enumerable that generates\nelements one by one during enumeration is called a stream. For example,\nElixir's `Range` is a stream:\n\n    iex> range = 1..5\n    1..5\n    iex> Enum.map(range, &(&1 * 2))\n    [2, 4, 6, 8, 10]\n\nIn the example above, as we mapped over the range, the elements being\nenumerated were created one by one, during enumeration. The `Stream`\nmodule allows us to map the range, without triggering its enumeration:\n\n    iex> range = 1..3\n    iex> stream = Stream.map(range, &(&1 * 2))\n    iex> Enum.map(stream, &(&1 + 1))\n    [3, 5, 7]\n\nNote that we started with a range and then we created a stream that is\nmeant to multiply each element in the range by 2. At this point, no\ncomputation was done. Only when `Enum.map/2` is called we actually\nenumerate over each element in the range, multiplying it by 2 and adding 1.\nWe say the functions in `Stream` are *lazy* and the functions in `Enum`\nare *eager*.\n\nDue to their laziness, streams are useful when working with large\n(or even infinite) collections. When chaining many operations with `Enum`,\nintermediate lists are created, while `Stream` creates a recipe of\ncomputations that are executed at a later moment. Let's see another\nexample:\n\n    1..3\n    |> Enum.map(&IO.inspect(&1))\n    |> Enum.map(&(&1 * 2))\n    |> Enum.map(&IO.inspect(&1))\n    1\n    2\n    3\n    2\n    4\n    6\n    #=> [2, 4, 6]\n\nNote that we first printed each element in the list, then multiplied each\nelement by 2 and finally printed each new value. In this example, the list\nwas enumerated three times. Let's see an example with streams:\n\n    stream = 1..3\n    |> Stream.map(&IO.inspect(&1))\n    |> Stream.map(&(&1 * 2))\n    |> Stream.map(&IO.inspect(&1))\n    Enum.to_list(stream)\n    1\n    2\n    2\n    4\n    3\n    6\n    #=> [2, 4, 6]\n\nAlthough the end result is the same, the order in which the elements were\nprinted changed! With streams, we print the first element and then print\nits double. In this example, the list was enumerated just once!\n\nThat's what we meant when we said earlier that streams are composable,\nlazy enumerables. Note that we could call `Stream.map/2` multiple times,\neffectively composing the streams and keeping them lazy. The computations\nare only performed when you call a function from the `Enum` module.\n\nLike with `Enum`, the functions in this module work in linear time. This\nmeans that, the time it takes to perform an operation grows at the same\nrate as the length of the list. This is expected on operations such as\n`Stream.map/2`. After all, if we want to traverse every element on a\nstream, the longer the stream, the more elements we need to traverse,\nand the longer it will take."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Stream.Elixir.Stream <response> Creating Streams\n\nThere are many functions in Elixir's standard library that return\nstreams, some examples are:\n\n  * `IO.stream/2`         - streams input lines, one by one\n  * `URI.query_decoder/1` - decodes a query string, pair by pair\n\nThis module also provides many convenience functions for creating streams,\nlike `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n\nNote the functions in this module are guaranteed to return enumerables.\nSince enumerables can have different shapes (structs, anonymous functions,\nand so on), the functions in this module may return any of those shapes\nand this may change at any time. For example, a function that today\nreturns an anonymous function may return a struct in future releases."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Chars.to_string(term) <response> Converts `term` to a string."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Chars.Elixir.String.Chars <response> The `String.Chars` protocol is responsible for\nconverting a structure to a binary (only if applicable).\n\nThe only function required to be implemented is\n`to_string/1`, which does the conversion.\n\nThe `to_string/1` function automatically imported\nby `Kernel` invokes this protocol. String\ninterpolation also invokes `to_string/1` in its\narguments. For example, `\"foo#{bar}\"` is the same\nas `\"foo\" <> to_string(bar)`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.at(string, position) <response> Returns the grapheme at the `position` of the given UTF-8 `string`.\nIf `position` is greater than `string` length, then it returns `nil`.\n\n## Examples\n\n    iex> String.at(\"elixir\", 0)\n    \"e\"\n\n    iex> String.at(\"elixir\", 1)\n    \"l\"\n\n    iex> String.at(\"elixir\", 10)\n    nil\n\n    iex> String.at(\"elixir\", -1)\n    \"r\"\n\n    iex> String.at(\"elixir\", -10)\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.bag_distance(string1, string2) <response> Computes the bag distance between two strings.\n\nReturns a float value between 0 and 1 representing the bag\ndistance between `string1` and `string2`.\n\nThe bag distance is meant to be an efficient approximation\nof the distance between two strings to quickly rule out strings\nthat are largely different.\n\nThe algorithm is outlined in the \"String Matching with Metric\nTrees Using an Approximate Distance\" paper by Ilaria Bartolini,\nPaolo Ciaccia, and Marco Patella.\n\n## Examples\n\n    iex> String.bag_distance(\"abc\", \"\")\n    0.0\n    iex> String.bag_distance(\"abcd\", \"a\")\n    0.25\n    iex> String.bag_distance(\"abcd\", \"ab\")\n    0.5\n    iex> String.bag_distance(\"abcd\", \"abc\")\n    0.75\n    iex> String.bag_distance(\"abcd\", \"abcd\")\n    1.0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.capitalize(string, mode \\\\ :default) <response> Converts the first character in the given string to\nuppercase and the remainder to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\ncapitalizes only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.capitalize(\"abcd\")\n    \"Abcd\"\n\n    iex> String.capitalize(\"ï¬n\")\n    \"Fin\"\n\n    iex> String.capitalize(\"olÃ¡\")\n    \"OlÃ¡\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.chunk(string, trait) <response> Splits the string into chunks of characters that share a common trait.\n\nThe trait can be one of two options:\n\n  * `:valid` - the string is split into chunks of valid and invalid\n    character sequences\n\n  * `:printable` - the string is split into chunks of printable and\n    non-printable character sequences\n\nReturns a list of binaries each of which contains only one kind of\ncharacters.\n\nIf the given string is empty, an empty list is returned.\n\n## Examples\n\n    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n    [\"abc\\0\"]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0xFFFF::utf16>>, :valid)\n    [\"abc\\0\", <<0xFFFF::utf16>>]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0FFFF::utf8>>, :printable)\n    [\"abc\", <<0, 0x0FFFF::utf8>>]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.codepoints(string) <response> Returns a list of code points encoded as strings.\n\nTo retrieve code points in their natural integer\nrepresentation, see `to_charlist/1`. For details about\ncode points and graphemes, see the `String` module\ndocumentation.\n\n## Examples\n\n    iex> String.codepoints(\"olÃ¡\")\n    [\"o\", \"l\", \"Ã¡\"]\n\n    iex> String.codepoints(\"Ð¾Ð¿ÑÐ¸Ð¼Ð¸ Ð·Ð°ÑÐ¸Ð¸\")\n    [\"Ð¾\", \"Ð¿\", \"Ñ\", \"Ð¸\", \"Ð¼\", \"Ð¸\", \" \", \"Ð·\", \"Ð°\", \"Ñ\", \"Ð¸\", \"Ð¸\"]\n\n    iex> String.codepoints(\"á¼á¼ªá¿¼\")\n    [\"á¼\", \"á¼ª\", \"á¿¼\"]\n\n    iex> String.codepoints(\"\\u00e9\")\n    [\"Ã©\"]\n\n    iex> String.codepoints(\"\\u0065\\u0301\")\n    [\"e\", \"Ì\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.contains?(string, contents) <response> Searches if `string` contains any of the given `contents`.\n\n`contents` can be either a string, a list of strings,\nor a compiled pattern. If `contents` is a list, this\nfunction will search if any of the strings in `contents`\nare part of `string`.\n\n> Note: if you want to check if `string` is listed in `contents`,\n> where `contents` is a list, use `Enum.member?(contents, string)`\n> instead.\n\n## Examples\n\n    iex> String.contains?(\"elixir of life\", \"of\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"life\", \"death\"])\n    true\n    iex> String.contains?(\"elixir of life\", [\"death\", \"mercury\"])\n    false\n\nThe argument can also be a compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\"life\", \"death\"])\n    iex> String.contains?(\"elixir of life\", pattern)\n    true\n\nAn empty string will always match:\n\n    iex> String.contains?(\"elixir of life\", \"\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.contains?(\"elixir of life\", [])\n    false\n\n    iex> String.contains?(\"\", [])\n    false\n\nBe aware that this function can match within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following returns `true`:\n\n    iex> String.contains?(String.normalize(\"Ã©\", :nfd), \"e\")\n    true\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it will return `false`:\n\n    iex> String.contains?(String.normalize(\"Ã©\", :nfc), \"e\")\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.downcase(string, mode \\\\ :default) <response> Converts all characters in the given string to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nlowercases only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.downcase(\"ABCD\")\n    \"abcd\"\n\n    iex> String.downcase(\"AB 123 XPTO\")\n    \"ab 123 xpto\"\n\n    iex> String.downcase(\"OLÃ\")\n    \"olÃ¡\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.downcase(\"OLÃ\", :ascii)\n    \"olÃ\"\n\nThe `:greek` mode properly handles the context sensitive sigma in Greek:\n\n    iex> String.downcase(\"Î£Î£\")\n    \"ÏÏ\"\n\n    iex> String.downcase(\"Î£Î£\", :greek)\n    \"ÏÏ\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.downcase(\"IÄ°\")\n    \"iiÌ\"\n\n    iex> String.downcase(\"IÄ°\", :turkic)\n    \"Ä±i\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.duplicate(subject, n) <response> Returns a string `subject` repeated `n` times.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.duplicate(\"abc\", 0)\n    \"\"\n\n    iex> String.duplicate(\"abc\", 1)\n    \"abc\"\n\n    iex> String.duplicate(\"abc\", 2)\n    \"abcabc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.ends_with?(string, suffix) <response> Returns `true` if `string` ends with any of the suffixes given.\n\n`suffixes` can be either a single suffix or a list of suffixes.\n\n## Examples\n\n    iex> String.ends_with?(\"language\", \"age\")\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"age\"])\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"elixir\"])\n    false\n\nAn empty suffix will always match:\n\n    iex> String.ends_with?(\"language\", \"\")\n    true\n    iex> String.ends_with?(\"language\", [\"\", \"other\"])\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.equivalent?(string1, string2) <response> Returns `true` if `string1` is canonically equivalent to `string2`.\n\nIt performs Normalization Form Canonical Decomposition (NFD) on the\nstrings before comparing them. This function is equivalent to:\n\n    String.normalize(string1, :nfd) == String.normalize(string2, :nfd)\n\nIf you plan to compare multiple strings, multiple times in a row, you\nmay normalize them upfront and compare them directly to avoid multiple\nnormalization passes.\n\n## Examples\n\n    iex> String.equivalent?(\"abc\", \"abc\")\n    true\n\n    iex> String.equivalent?(\"man\\u0303ana\", \"maÃ±ana\")\n    true\n\n    iex> String.equivalent?(\"abc\", \"ABC\")\n    false\n\n    iex> String.equivalent?(\"nÃ¸\", \"nÃ³\")\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.first(string) <response> Returns the first grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\n## Examples\n\n    iex> String.first(\"elixir\")\n    \"e\"\n\n    iex> String.first(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    \"Õ¥\"\n\n    iex> String.first(\"\")\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.graphemes(string) <response> Returns Unicode graphemes in the string as per Extended Grapheme\nCluster algorithm.\n\nThe algorithm is outlined in the [Unicode Standard Annex #29,\nUnicode Text Segmentation](https://www.unicode.org/reports/tr29/).\n\nFor details about code points and graphemes, see the `String` module documentation.\n\n## Examples\n\n    iex> String.graphemes(\"ÅaÃ¯ve\")\n    [\"Å\", \"a\", \"Ã¯\", \"v\", \"e\"]\n\n    iex> String.graphemes(\"\\u00e9\")\n    [\"Ã©\"]\n\n    iex> String.graphemes(\"\\u0065\\u0301\")\n    [\"eÌ\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.jaro_distance(string1, string2) <response> Computes the Jaro distance (similarity) between two strings.\n\nReturns a float value between `0.0` (equates to no similarity) and `1.0`\n(is an exact match) representing [Jaro](https://en.wikipedia.org/wiki/Jaro-Winkler_distance)\ndistance between `string1` and `string2`.\n\nThe Jaro distance metric is designed and best suited for short\nstrings such as person names. Elixir itself uses this function\nto provide the \"did you mean?\" functionality. For instance, when you\nare calling a function in a module and you have a typo in the\nfunction name, we attempt to suggest the most similar function\nname available, if any, based on the `jaro_distance/2` score.\n\n## Examples\n\n    iex> String.jaro_distance(\"Dwayne\", \"Duane\")\n    0.8222222222222223\n    iex> String.jaro_distance(\"even\", \"odd\")\n    0.0\n    iex> String.jaro_distance(\"same\", \"same\")\n    1.0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.last(string) <response> Returns the last grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\nIt traverses the whole string to find its last grapheme.\n\n## Examples\n\n    iex> String.last(\"\")\n    nil\n\n    iex> String.last(\"elixir\")\n    \"r\"\n\n    iex> String.last(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    \"Õ«\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.length(string) <response> Returns the number of Unicode graphemes in a UTF-8 string.\n\n## Examples\n\n    iex> String.length(\"elixir\")\n    6\n\n    iex> String.length(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    5"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.match?(string, regex) <response> Checks if `string` matches the given regular expression.\n\n## Examples\n\n    iex> String.match?(\"foo\", ~r/foo/)\n    true\n\n    iex> String.match?(\"bar\", ~r/foo/)\n    false\n\nElixir also provides text-based match operator `=~/2` and function `Regex.match?/2` as\nalternatives to test strings against regular expressions."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.myers_difference(string1, string2) <response> Returns a keyword list that represents an edit script.\n\nCheck `List.myers_difference/2` for more information.\n\n## Examples\n\n    iex> string1 = \"fox hops over the dog\"\n    iex> string2 = \"fox jumps over the lazy cat\"\n    iex> String.myers_difference(string1, string2)\n    [eq: \"fox \", del: \"ho\", ins: \"jum\", eq: \"ps over the \", del: \"dog\", ins: \"lazy cat\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.next_codepoint(arg) <response> Returns the next code point in a string.\n\nThe result is a tuple with the code point and the\nremainder of the string or `nil` in case\nthe string reached its end.\n\nAs with other functions in the `String` module, `next_codepoint/1`\nworks with binaries that are invalid UTF-8. If the string starts\nwith a sequence of bytes that is not valid in UTF-8 encoding, the\nfirst element of the returned tuple is a binary with the first byte.\n\n## Examples\n\n    iex> String.next_codepoint(\"olÃ¡\")\n    {\"o\", \"lÃ¡\"}\n\n    iex> invalid = \"\\x80\\x80OK\" # first two bytes are invalid in UTF-8\n    iex> {_, rest} = String.next_codepoint(invalid)\n    {<<128>>, <<128, 79, 75>>}\n    iex> String.next_codepoint(rest)\n    {<<128>>, \"OK\"}\n\n## Comparison with binary pattern matching\n\nBinary pattern matching provides a similar way to decompose\na string:\n\n    iex> <<codepoint::utf8, rest::binary>> = \"Elixir\"\n    \"Elixir\"\n    iex> codepoint\n    69\n    iex> rest\n    \"lixir\"\n\nthough not entirely equivalent because `codepoint` comes as\nan integer, and the pattern won't match invalid UTF-8.\n\nBinary pattern matching, however, is simpler and more efficient,\nso pick the option that better suits your use case."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.next_grapheme(string) <response> Returns the next grapheme in a string.\n\nThe result is a tuple with the grapheme and the\nremainder of the string or `nil` in case\nthe String reached its end.\n\n## Examples\n\n    iex> String.next_grapheme(\"olÃ¡\")\n    {\"o\", \"lÃ¡\"}\n\n    iex> String.next_grapheme(\"\")\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.normalize(string, form) <response> Converts all characters in `string` to Unicode normalization\nform identified by `form`.\n\nInvalid Unicode codepoints are skipped and the remaining of\nthe string is converted. If you want the algorithm to stop\nand return on invalid codepoint, use `:unicode.characters_to_nfd_binary/1`,\n`:unicode.characters_to_nfc_binary/1`, `:unicode.characters_to_nfkd_binary/1`,\nand `:unicode.characters_to_nfkc_binary/1` instead.\n\nNormalization forms `:nfkc` and `:nfkd` should not be blindly applied\nto arbitrary text. Because they erase many formatting distinctions,\nthey will prevent round-trip conversion to and from many legacy\ncharacter sets.\n\n## Forms\n\nThe supported forms are:\n\n  * `:nfd` - Normalization Form Canonical Decomposition.\n    Characters are decomposed by canonical equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfc` - Normalization Form Canonical Composition.\n    Characters are decomposed and then recomposed by canonical equivalence.\n\n  * `:nfkd` - Normalization Form Compatibility Decomposition.\n    Characters are decomposed by compatibility equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfkc` - Normalization Form Compatibility Composition.\n    Characters are decomposed and then recomposed by compatibility equivalence.\n\n## Examples\n\n    iex> String.normalize(\"yÃªsÌÌ£\", :nfd)\n    \"yeÌsÌ£Ì\"\n\n    iex> String.normalize(\"lenÌa\", :nfc)\n    \"leÃ±a\"\n\n    iex> String.normalize(\"ï¬\", :nfkd)\n    \"fi\"\n\n    iex> String.normalize(\"fi\", :nfkc)\n    \"fi\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.pad_leading(string, count, padding \\\\ [\" \"]) <response> Returns a new string padded with a leading filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_leading(\"abc\", 5)\n    \"  abc\"\n\n    iex> String.pad_leading(\"abc\", 4, \"12\")\n    \"1abc\"\n\n    iex> String.pad_leading(\"abc\", 6, \"12\")\n    \"121abc\"\n\n    iex> String.pad_leading(\"abc\", 5, [\"1\", \"23\"])\n    \"123abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.pad_trailing(string, count, padding \\\\ [\" \"]) <response> Returns a new string padded with a trailing filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_trailing(\"abc\", 5)\n    \"abc  \"\n\n    iex> String.pad_trailing(\"abc\", 4, \"12\")\n    \"abc1\"\n\n    iex> String.pad_trailing(\"abc\", 6, \"12\")\n    \"abc121\"\n\n    iex> String.pad_trailing(\"abc\", 5, [\"1\", \"23\"])\n    \"abc123\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.printable?(string, character_limit \\\\ :infinity) <response> Checks if a string contains only printable characters up to `character_limit`.\n\nTakes an optional `character_limit` as a second argument. If `character_limit` is `0`, this\nfunction will return `true`.\n\n## Examples\n\n    iex> String.printable?(\"abc\")\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>)\n    false\n\n    iex> String.printable?(\"abc\" <> <<0>>, 2)\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>, 0)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace(subject, pattern, replacement, options \\\\ []) <response> Returns a new string created by replacing occurrences of `pattern` in\n`subject` with `replacement`.\n\nThe `subject` is always a string.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe `replacement` may be a string or a function that receives the matched\npattern and must return the replacement as a string or iodata.\n\nBy default it replaces all occurrences but this behaviour can be controlled\nthrough the `:global` option; see the \"Options\" section below.\n\n## Options\n\n  * `:global` - (boolean) if `true`, all occurrences of `pattern` are replaced\n    with `replacement`, otherwise only the first occurrence is\n    replaced. Defaults to `true`\n\n## Examples\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\")\n    \"a-b-c\"\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n    \"a-b,c\"\n\nThe pattern may also be a list of strings and the replacement may also\nbe a function that receives the matches:\n\n    iex> String.replace(\"a,b,c\", [\"a\", \"c\"], fn <<char>> -> <<char + 1>> end)\n    \"b,b,d\"\n\nWhen the pattern is a regular expression, one can give `\\N` or\n`\\g{N}` in the `replacement` string to access a specific capture in the\nregular expression:\n\n    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\g{1}\")\n    \"a,bb,cc\"\n\nNote that we had to escape the backslash escape character (i.e., we used `\\\\N`\ninstead of just `\\N` to escape the backslash; same thing for `\\\\g{N}`). By\ngiving `\\0`, one can inject the whole match in the replacement string.\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern(\",\")\n    iex> String.replace(\"a,b,c\", pattern, \"[]\")\n    \"a[]b[]c\"\n\nWhen an empty string is provided as a `pattern`, the function will treat it as\nan implicit empty string between each grapheme and the string will be\ninterspersed. If an empty string is provided as `replacement` the `subject`\nwill be returned:\n\n    iex> String.replace(\"ELIXIR\", \"\", \".\")\n    \".E.L.I.X.I.R.\"\n\n    iex> String.replace(\"ELIXIR\", \"\", \"\")\n    \"ELIXIR\"\n\nBe aware that this function can replace within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following will replace only the letter \"e\",\nmoving the accent to the letter \"o\":\n\n    iex> String.replace(String.normalize(\"Ã©\", :nfd), \"e\", \"o\")\n    \"oÌ\"\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it won't be replaced at all:\n\n    iex> String.replace(String.normalize(\"Ã©\", :nfc), \"e\", \"o\")\n    \"Ã©\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_leading(string, match, replacement) <response> Replaces all leading occurrences of `match` by `replacement` of `match` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe beginning of `string`, and it's impossible to replace \"multiple\"\noccurrences of `\"\"`.\n\n## Examples\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"\")\n    \"world\"\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"ola \")\n    \"ola ola world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_prefix(string, match, replacement) <response> Replaces prefix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just prepended to `string`.\n\n## Examples\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"\")\n    \"hello world\"\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"ola \")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"ola \")\n    \"ola hello world\"\n\n    iex> String.replace_prefix(\"world\", \"\", \"hello \")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_suffix(string, match, replacement) <response> Replaces suffix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just appended to `string`.\n\n## Examples\n\n    iex> String.replace_suffix(\"hello\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \"\")\n    \"hello world\"\n\n    iex> String.replace_suffix(\"hello\", \" world\", \" mundo\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \" mundo\")\n    \"hello world mundo\"\n\n    iex> String.replace_suffix(\"hello\", \"\", \" world\")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.replace_trailing(string, match, replacement) <response> Replaces all trailing occurrences of `match` by `replacement` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe end of `string`, and it's impossible to replace \"multiple\" occurrences of\n`\"\"`.\n\n## Examples\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \"\")\n    \"hello\"\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \" mundo\")\n    \"hello mundo mundo\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.reverse(string) <response> Reverses the graphemes in given string.\n\n## Examples\n\n    iex> String.reverse(\"abcd\")\n    \"dcba\"\n\n    iex> String.reverse(\"hello world\")\n    \"dlrow olleh\"\n\n    iex> String.reverse(\"hello âog\")\n    \"goâ olleh\"\n\nKeep in mind reversing the same string twice does\nnot necessarily yield the original string:\n\n    iex> \"Ìe\"\n    \"Ìe\"\n    iex> String.reverse(\"Ìe\")\n    \"eÌ\"\n    iex> String.reverse(String.reverse(\"Ìe\"))\n    \"eÌ\"\n\nIn the first example the accent is before the vowel, so\nit is considered two graphemes. However, when you reverse\nit once, you have the vowel followed by the accent, which\nbecomes one grapheme. Reversing it again will keep it as\none single grapheme."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.slice(string, range) <response> Returns a substring from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nIf the start of the range is not a valid offset for the given\nstring or if the range is in reverse order, returns `\"\"`.\n\nIf the start or end of the range is negative, the whole string\nis traversed first in order to convert the negative indices into\npositive ones.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or\n`Kernel.binary_slice/2` instead\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> String.slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -100..100)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> String.slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole string as is:\n\n    iex> String.slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the string:\n\n    iex> String.slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> String.slice(\"elixir\", 10..3)\n    \"\"\n    iex> String.slice(\"a\", 1..1500)\n    \"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.slice(string, start, length) <response> Returns a substring starting at the offset `start`, and of the given `length`.\n\nIf the offset is greater than string length, then it returns `\"\"`.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or `Kernel.binary_slice/3`\ninstead.\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1, 3)\n    \"lix\"\n\n    iex> String.slice(\"elixir\", 1, 10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", 10, 3)\n    \"\"\n\nIf the start position is negative, it is normalized\nagainst the string length and clamped to 0:\n\n    iex> String.slice(\"elixir\", -4, 4)\n    \"ixir\"\n\n    iex> String.slice(\"elixir\", -10, 3)\n    \"eli\"\n\nIf start is more than the string length, an empty\nstring is returned:\n\n    iex> String.slice(\"elixir\", 10, 1500)\n    \"\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.split(binary) <response> Divides a string into substrings at each Unicode whitespace\noccurrence with leading and trailing whitespace ignored. Groups\nof whitespace are treated as a single occurrence. Divisions do\nnot occur on non-breaking whitespace.\n\n## Examples\n\n    iex> String.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\" foo   bar \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"no\\u00a0break\")\n    [\"no\\u00a0break\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.split(string, pattern, options \\\\ []) <response> Divides a string into parts based on a pattern.\n\nReturns a list of these parts.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe string is split into as many parts as possible by\ndefault, but can be controlled via the `:parts` option.\n\nEmpty strings are only removed from the result if the\n`:trim` option is set to `true`.\n\nWhen the pattern used is a regular expression, the string is\nsplit using `Regex.split/3`.\n\n## Options\n\n  * `:parts` (positive integer or `:infinity`) - the string\n    is split into at most as many parts as this option specifies.\n    If `:infinity`, the string will be split into all possible\n    parts. Defaults to `:infinity`.\n\n  * `:trim` (boolean) - if `true`, empty strings are removed from\n    the resulting list.\n\nThis function also accepts all options accepted by `Regex.split/3`\nif `pattern` is a regular expression.\n\n## Examples\n\nSplitting with a string pattern:\n\n    iex> String.split(\"a,b,c\", \",\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", \",\", parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", \" \", trim: true)\n    [\"a\", \"b\", \"c\"]\n\nA list of patterns:\n\n    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n    [\"1\", \"2\", \"3\", \"4\"]\n\nA regular expression:\n\n    iex> String.split(\"a,b,c\", ~r{,})\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", ~r{b}, include_captures: true)\n    [\"a\", \"b\", \"c\"]\n\nA compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.split(\"1,2 3,4\", pattern)\n    [\"1\", \"2\", \"3\", \"4\"]\n\nSplitting on empty string returns graphemes:\n\n    iex> String.split(\"abc\", \"\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> String.split(\"abc\", \"\", trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", \"\", parts: 1)\n    [\"abc\"]\n\n    iex> String.split(\"abc\", \"\", parts: 3)\n    [\"\", \"a\", \"bc\"]\n\nBe aware that this function can split within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following will split the string into two parts:\n\n    iex> String.split(String.normalize(\"Ã©\", :nfd), \"e\")\n    [\"\", \"Ì\"]\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it will split the string into just one part:\n\n    iex> String.split(String.normalize(\"Ã©\", :nfc), \"e\")\n    [\"Ã©\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.split_at(string, position) <response> Splits a string into two at the specified offset. When the offset given is\nnegative, location is counted from the end of the string.\n\nThe offset is capped to the length of the string. Returns a tuple with\ntwo elements.\n\nNote: keep in mind this function splits on graphemes and for such it\nhas to linearly traverse the string. If you want to split a string or\na binary based on the number of bytes, use `Kernel.binary_part/3`\ninstead.\n\n## Examples\n\n    iex> String.split_at(\"sweetelixir\", 5)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"sweetelixir\", -6)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"abc\", 0)\n    {\"\", \"abc\"}\n\n    iex> String.split_at(\"abc\", 1000)\n    {\"abc\", \"\"}\n\n    iex> String.split_at(\"abc\", -1000)\n    {\"\", \"abc\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.splitter(string, pattern, options \\\\ []) <response> Returns an enumerable that splits a string on demand.\n\nThis is in contrast to `split/3` which splits the\nentire string upfront.\n\nThis function does not support regular expressions\nby design. When using regular expressions, it is often\nmore efficient to have the regular expressions traverse\nthe string at once than in parts, like this function does.\n\n## Options\n\n  * :trim - when `true`, does not emit empty patterns\n\n## Examples\n\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", [\" \", \",\"]) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]\n\n    iex> String.splitter(\"abcd\", \"\") |> Enum.take(10)\n    [\"\", \"a\", \"b\", \"c\", \"d\", \"\"]\n\n    iex> String.splitter(\"abcd\", \"\", trim: true) |> Enum.take(10)\n    [\"a\", \"b\", \"c\", \"d\"]\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", pattern) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.starts_with?(string, prefix) <response> Returns `true` if `string` starts with any of the prefixes given.\n\n`prefix` can be either a string, a list of strings, or a compiled\npattern.\n\n## Examples\n\n    iex> String.starts_with?(\"elixir\", \"eli\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"elixir\"])\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"ruby\"])\n    false\n\nAn empty string will always match:\n\n    iex> String.starts_with?(\"elixir\", \"\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.starts_with?(\"elixir\", [])\n    false\n\n    iex> String.starts_with?(\"\", [])\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_atom(string) <response> Converts a string to an atom.\n\nWarning: this function creates atoms dynamically and atoms are\nnot garbage-collected. Therefore, `string` should not be an\nuntrusted value, such as input received from a socket or during\na web request. Consider using `to_existing_atom/1` instead.\n\nBy default, the maximum number of atoms is `1_048_576`. This limit\ncan be raised or lowered using the VM option `+t`.\n\nThe maximum atom size is of 255 Unicode code points.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_atom(\"my_atom\")\n    :my_atom"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_charlist(string) <response> Converts a string into a charlist.\n\nSpecifically, this function takes a UTF-8 encoded binary and returns a list of its integer\ncode points. It is similar to `codepoints/1` except that the latter returns a list of code points as\nstrings.\n\nIn case you need to work with bytes, take a look at the\n[`:binary` module](`:binary`).\n\n## Examples\n\n    iex> String.to_charlist(\"Ã¦Ã\")\n    'Ã¦Ã'"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_existing_atom(string) <response> Converts a string to an existing atom.\n\nThe maximum atom size is of 255 Unicode code points.\nRaises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `String.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.\n\n## Examples\n\n    iex> _ = :my_atom\n    iex> String.to_existing_atom(\"my_atom\")\n    :my_atom"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_float(string) <response> Returns a float whose text representation is `string`.\n\n`string` must be the string representation of a float including a decimal point.\nIn order to parse a string without decimal point as a float then `Float.parse/1`\nshould be used. Otherwise, an `ArgumentError` will be raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_float(\"2.2017764e+0\")\n    2.2017764\n\n    iex> String.to_float(\"3.0\")\n    3.0\n\n    String.to_float(\"3\")\n    ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_integer(string) <response> Returns an integer whose text representation is `string`.\n\n`string` must be the string representation of an integer.\nOtherwise, an `ArgumentError` will be raised. If you want\nto parse a string that may contain an ill-formatted integer,\nuse `Integer.parse/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"123\")\n    123\n\nPassing a string that does not represent an integer leads to an error:\n\n    String.to_integer(\"invalid data\")\n    ** (ArgumentError) argument error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.to_integer(string, base) <response> Returns an integer whose text representation is `string` in base `base`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"3FF\", 16)\n    1023"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim(string) <response> Returns a string where all leading and trailing Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim(\"\\n  abc\\n  \")\n    \"abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim(string, to_trim) <response> Returns a string where all leading and trailing `to_trim` characters have been\nremoved.\n\n## Examples\n\n    iex> String.trim(\"a  abc  a\", \"a\")\n    \"  abc  \""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_leading(string) <response> Returns a string where all leading Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"\\n  abc   \")\n    \"abc   \""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_leading(string, to_trim) <response> Returns a string where all leading `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"__ abc _\", \"_\")\n    \" abc _\"\n\n    iex> String.trim_leading(\"1 abc\", \"11\")\n    \"1 abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_trailing(string) <response> Returns a string where all trailing Unicode whitespaces\nhas been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"   abc\\n  \")\n    \"   abc\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.trim_trailing(string, to_trim) <response> Returns a string where all trailing `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"_ abc __\", \"_\")\n    \"_ abc \"\n\n    iex> String.trim_trailing(\"abc 1\", \"11\")\n    \"abc 1\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.upcase(string, mode \\\\ :default) <response> Converts all characters in the given string to uppercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nuppercases only the letters a to z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.upcase(\"abcd\")\n    \"ABCD\"\n\n    iex> String.upcase(\"ab 123 xpto\")\n    \"AB 123 XPTO\"\n\n    iex> String.upcase(\"olÃ¡\")\n    \"OLÃ\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.upcase(\"olÃ¡\", :ascii)\n    \"OLÃ¡\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.upcase(\"Ä±i\")\n    \"II\"\n\n    iex> String.upcase(\"Ä±i\", :turkic)\n    \"IÄ°\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.valid?(string) <response> Checks whether `string` contains only valid characters.\n\n## Examples\n\n    iex> String.valid?(\"a\")\n    true\n\n    iex> String.valid?(\"Ã¸\")\n    true\n\n    iex> String.valid?(<<0xFFFF::16>>)\n    false\n\n    iex> String.valid?(<<0xEF, 0xB7, 0x90>>)\n    true\n\n    iex> String.valid?(\"asd\" <> <<0xFFFF::16>>)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Strings in Elixir are UTF-8 encoded binaries.\n\nStrings in Elixir are a sequence of Unicode characters,\ntypically written between double quoted strings, such\nas `\"hello\"` and `\"hÃ©llÃ²\"`.\n\nIn case a string must have a double-quote in itself,\nthe double quotes must be escaped with a backslash,\nfor example: `\"this is a string with \\\"double quotes\\\"\"`.\n\nYou can concatenate two strings with the `<>/2` operator:\n\n    iex> \"hello\" <> \" \" <> \"world\"\n    \"hello world\"\n\nThe functions in this module act according to\n[The Unicode Standard, Version 14.0.0](http://www.unicode.org/versions/Unicode14.0.0/)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Interpolation\n\nStrings in Elixir also support interpolation. This allows\nyou to place some value in the middle of a string by using\nthe `#{}` syntax:\n\n    iex> name = \"joe\"\n    iex> \"hello #{name}\"\n    \"hello joe\"\n\nAny Elixir expression is valid inside the interpolation.\nIf a string is given, the string is interpolated as is.\nIf any other value is given, Elixir will attempt to convert\nit to a string using the `String.Chars` protocol. This\nallows, for example, to output an integer from the interpolation:\n\n    iex> \"2 + 2 = #{2 + 2}\"\n    \"2 + 2 = 4\"\n\nIn case the value you want to interpolate cannot be\nconverted to a string, because it doesn't have a human\ntextual representation, a protocol error will be raised."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Escape characters\n\nBesides allowing double-quotes to be escaped with a backslash,\nstrings also support the following escape characters:\n\n  * `\\0` - Null byte\n  * `\\a` - Bell\n  * `\\b` - Backspace\n  * `\\t` - Horizontal tab\n  * `\\n` - Line feed (New lines)\n  * `\\v` - Vertical tab\n  * `\\f` - Form feed\n  * `\\r` - Carriage return\n  * `\\e` - Command Escape\n  * `\\s` - Space\n  * `\\#` - Returns the `#` character itself, skipping interpolation\n  * `\\\\` - Single backslash\n  * `\\xNN` - A byte represented by the hexadecimal `NN`\n  * `\\uNNNN` - A Unicode code point represented by `NNNN`\n\nNote it is generally not advised to use `\\xNN` in Elixir\nstrings, as introducing an invalid byte sequence would\nmake the string invalid. If you have to introduce a\ncharacter by its hexadecimal representation, it is best\nto work with Unicode code points, such as `\\uNNNN`. In fact,\nunderstanding Unicode code points can be essential when doing\nlow-level manipulations of string, so let's explore them in\ndetail next."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Unicode and code points\n\nIn order to facilitate meaningful communication between computers\nacross multiple languages, a standard is required so that the ones\nand zeros on one machine mean the same thing when they are transmitted\nto another. The Unicode Standard acts as an official registry of\nvirtually all the characters we know: this includes characters from\nclassical and historical texts, emoji, and formatting and control\ncharacters as well.\n\nUnicode organizes all of the characters in its repertoire into code\ncharts, and each character is given a unique numerical index. This\nnumerical index is known as a Code Point.\n\nIn Elixir you can use a `?` in front of a character literal to reveal\nits code point:\n\n    iex> ?a\n    97\n    iex> ?Å\n    322\n\nNote that most Unicode code charts will refer to a code point by its\nhexadecimal (hex) representation, e.g. `97` translates to `0061` in hex,\nand we can represent any Unicode character in an Elixir string by\nusing the `\\u` escape character followed by its code point number:\n\n    iex> \"\\u0061\" === \"a\"\n    true\n    iex> 0x0061 = 97 = ?a\n    97\n\nThe hex representation will also help you look up information about a\ncode point, e.g. [https://codepoints.net/U+0061](https://codepoints.net/U+0061)\nhas a data sheet all about the lower case `a`, a.k.a. code point 97.\nRemember you can get the hex presentation of a number by calling\n`Integer.to_string/2`:\n\n    iex> Integer.to_string(?a, 16)\n    \"61\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> UTF-8 encoded and encodings\n\nNow that we understand what the Unicode standard is and what code points\nare, we can finally talk about encodings. Whereas the code point is **what**\nwe store, an encoding deals with **how** we store it: encoding is an\nimplementation. In other words, we need a mechanism to convert the code\npoint numbers into bytes so they can be stored in memory, written to disk, and such.\n\nElixir uses UTF-8 to encode its strings, which means that code points are\nencoded as a series of 8-bit bytes. UTF-8 is a **variable width** character\nencoding that uses one to four bytes to store each code point. It is capable\nof encoding all valid Unicode code points. Let's see an example:\n\n    iex> string = \"hÃ©llo\"\n    \"hÃ©llo\"\n    iex> String.length(string)\n    5\n    iex> byte_size(string)\n    6\n\nAlthough the string above has 5 characters, it uses 6 bytes, as two bytes\nare used to represent the character `Ã©`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Grapheme clusters\n\nThis module also works with the concept of grapheme cluster\n(from now on referenced as graphemes). Graphemes can consist\nof multiple code points that may be perceived as a single character\nby readers. For example, \"Ã©\" can be represented either as a single\n\"e with acute\" code point, as seen above in the string `\"hÃ©llo\"`,\nor as the letter \"e\" followed by a \"combining acute accent\"\n(two code points):\n\n    iex> string = \"\\u0065\\u0301\"\n    \"eÌ\"\n    iex> byte_size(string)\n    3\n    iex> String.length(string)\n    1\n    iex> String.codepoints(string)\n    [\"e\", \"Ì\"]\n    iex> String.graphemes(string)\n    [\"eÌ\"]\n\nAlthough it looks visually the same as before, the example above\nis made of two characters, it is perceived by users as one.\n\nGraphemes can also be two characters that are interpreted as one\nby some languages. For example, some languages may consider \"ch\"\nas a single character. However, since this information depends on\nthe locale, it is not taken into account by this module.\n\nIn general, the functions in this module rely on the Unicode\nStandard, but do not contain any of the locale specific behaviour.\nMore information about graphemes can be found in the [Unicode\nStandard Annex #29](https://www.unicode.org/reports/tr29/).\n\nFor converting a binary to a different encoding and for Unicode\nnormalization mechanisms, see Erlang's `:unicode` module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> String and binary operations\n\nTo act according to the Unicode Standard, many functions\nin this module run in linear time, as they need to traverse\nthe whole string considering the proper Unicode code points.\n\nFor example, `String.length/1` will take longer as\nthe input grows. On the other hand, `Kernel.byte_size/1` always runs\nin constant time (i.e. regardless of the input size).\n\nThis means often there are performance costs in using the\nfunctions in this module, compared to the more low-level\noperations that work directly with binaries:\n\n  * `Kernel.binary_part/3` - retrieves part of the binary\n  * `Kernel.bit_size/1` and `Kernel.byte_size/1` - size related functions\n  * `Kernel.is_bitstring/1` and `Kernel.is_binary/1` - type-check function\n  * Plus a number of functions for working with binaries (bytes)\n    in the [`:binary` module](`:binary`)\n\nA `utf8` modifier is also available inside the binary syntax `<<>>`.\nIt can be used to match code points out of a binary/string:\n\n    iex> <<eacute::utf8>> = \"Ã©\"\n    iex> eacute\n    233\n\nYou can also fully convert a string into a list of integer code points,\nknown as \"charlists\" in Elixir, by calling `String.to_charlist/1`:\n\n    iex> String.to_charlist(\"hÃ©llo\")\n    [104, 233, 108, 108, 111]\n\nIf you would rather see the underlying bytes of a string, instead of\nits codepoints, a common trick is to concatenate the null byte `<<0>>`\nto it:\n\n    iex> \"hÃ©llo\" <> <<0>>\n    <<104, 195, 169, 108, 108, 111, 0>>\n\nAlternatively, you can view a string's binary representation by\npassing an option to `IO.inspect/2`:\n\n    IO.inspect(\"hÃ©llo\", binaries: :as_binaries)\n    #=> <<104, 195, 169, 108, 108, 111>>"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Self-synchronization\n\nThe UTF-8 encoding is self-synchronizing. This means that\nif malformed data (i.e., data that is not possible according\nto the definition of the encoding) is encountered, only one\ncode point needs to be rejected.\n\nThis module relies on this behaviour to ignore such invalid\ncharacters. For example, `length/1` will return\na correct result even if an invalid code point is fed into it.\n\nIn other words, this module expects invalid data to be detected\nelsewhere, usually when retrieving data from the external source.\nFor example, a driver that reads strings from a database will be\nresponsible to check the validity of the encoding. `String.chunk/2`\ncan be used for breaking a string into valid and invalid parts."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.String.Elixir.String <response> Compile binary patterns\n\nMany functions in this module work with patterns. For example,\n`String.split/3` can split a string into multiple strings given\na pattern. This pattern can be a string, a list of strings or\na compiled pattern:\n\n    iex> String.split(\"foo bar\", \" \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo bar!\", [\" \", \"!\"])\n    [\"foo\", \"bar\", \"\"]\n\n    iex> pattern = :binary.compile_pattern([\" \", \"!\"])\n    iex> String.split(\"foo bar!\", pattern)\n    [\"foo\", \"bar\", \"\"]\n\nThe compiled pattern is useful when the same match will\nbe done over and over again. Note though that the compiled\npattern cannot be stored in a module attribute as the pattern\nis generated at runtime and does not survive compile time."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.close(pid) <response> Stops the IO device and returns the remaining input/output\nbuffers.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.close(pid)\n    {:ok, {\"in\", \"out\"}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.contents(pid) <response> Returns the current input/output buffers for the given IO\ndevice.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.contents(pid)\n    {\"in\", \"out\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.flush(pid) <response> Flushes the output buffer and returns its current contents.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.flush(pid)\n    \"out\"\n    iex> StringIO.contents(pid)\n    {\"in\", \"\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.open(string, options_or_function \\\\ []) <response> Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\n`options_or_function` can be a keyword list of options or\na function.\n\nIf options are provided, the result will be `{:ok, pid}`, returning the\nIO device created. The option `:capture_prompt`, when set to `true`, causes\nprompts (which are specified as arguments to `IO.get*` functions) to be\nincluded in the device's output.\n\nIf a function is provided, the device will be created and sent to the\nfunction. When the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"foo\")\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \"\"}\n\n    iex> {:ok, pid} = StringIO.open(\"foo\", capture_prompt: true)\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \">\"}\n\n    iex> StringIO.open(\"foo\", fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.open(string, options, function) <response> Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\nThe device will be created and sent to the function given.\nWhen the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.\n\n## Options\n\n  * `:capture_prompt` - if set to `true`, prompts (specified as\n    arguments to `IO.get*` functions) are captured in the output.\n    Defaults to `false`.\n\n  * `:encoding` (since v1.10.0) - encoding of the IO device. Allowed\n    values are `:unicode` (default) and `:latin1`.\n\n## Examples\n\n    iex> StringIO.open(\"foo\", [], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}\n\n    iex> StringIO.open(\"foo\", [capture_prompt: true], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \">The input was foo\"}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.Elixir.StringIO <response> Controls an IO device process that wraps a string.\n\nA `StringIO` IO device can be passed as a \"device\" to\nmost of the functions in the `IO` module."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.StringIO.Elixir.StringIO <response> Examples\n\n    iex> {:ok, pid} = StringIO.open(\"foo\")\n    iex> IO.read(pid, 2)\n    \"fo\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.supervise(children, options) <response> Receives a list of `children` (workers or supervisors) to\nsupervise and a set of `options`.\n\nReturns a tuple containing the supervisor specification. This tuple can be\nused as the return value of the `c:Supervisor.init/1` callback when implementing a\nmodule-based supervisor.\n\n## Examples\n\n    supervise(children, strategy: :one_for_one)\n\n## Options\n\n  * `:strategy` - the restart strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, `:one_for_all`, or\n    `:simple_one_for_one`. You can learn more about strategies\n    in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\nThe `:strategy` option is required and by default a maximum of 3 restarts is\nallowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.supervisor(module, args, options \\\\ []) <response> Defines the given `module` as a supervisor which will be started\nwith the given arguments.\n\n    supervisor(module, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: :infinity,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.worker(module, args, options \\\\ []) <response> Defines the given `module` as a worker which will be started\nwith the given arguments.\n\n    worker(ExUnit.Runner, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: 5000,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.Elixir.Supervisor.Spec <response> Outdated functions for building child specifications.\n\nThe functions in this module are deprecated and they do not work\nwith the module-based child specs introduced in Elixir v1.5.\nPlease see the `Supervisor` documentation instead.\n\nConvenience functions for defining supervisor specifications."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.Elixir.Supervisor.Spec <response> Example\n\nBy using the functions in this module one can specify the children\nto be used under a supervisor, started with `Supervisor.start_link/2`:\n\n    import Supervisor.Spec\n\n    children = [\n      worker(MyWorker, [arg1, arg2, arg3]),\n      supervisor(MySupervisor, [arg1])\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nSometimes, it may be handy to define supervisors backed\nby a module:\n\n    defmodule MySupervisor do\n      use Supervisor\n\n      def start_link(arg) do\n        Supervisor.start_link(__MODULE__, arg)\n      end\n\n      def init(arg) do\n        children = [\n          worker(MyWorker, [arg], restart: :temporary)\n        ]\n\n        supervise(children, strategy: :simple_one_for_one)\n      end\n    end\n\nNote that in this case we don't have to explicitly import\n`Supervisor.Spec` since `use Supervisor` automatically does so.\nDefining a module-based supervisor can be useful, for example,\nto perform initialization tasks in the `c:Supervisor.init/1` callback."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.Elixir.Supervisor.Spec <response> Supervisor and worker options\n\nIn the example above, we defined specs for workers and supervisors.\nThese specs (both for workers as well as supervisors) accept the\nfollowing options:\n\n  * `:id` - a name used to identify the child specification\n    internally by the supervisor; defaults to the given module\n    name for the child worker/supervisor\n\n  * `:function` - the function to invoke on the child to start it\n\n  * `:restart` - an atom that defines when a terminated child process should\n    be restarted (see the \"Restart values\" section below)\n\n  * `:shutdown` - an atom that defines how a child process should be\n    terminated (see the \"Shutdown values\" section below)\n\n  * `:modules` - it should be a list with one element `[module]`,\n    where module is the name of the callback module only if the\n    child process is a `Supervisor` or `GenServer`; if the child\n    process is a `GenEvent`, `:modules` should be `:dynamic`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.Elixir.Supervisor.Spec <response> # Restart values (:restart)\n\nThe following restart values are supported in the `:restart` option:\n\n  * `:permanent` - the child process is always restarted\n\n  * `:temporary` - the child process is never restarted (not even\n    when the supervisor's strategy is `:rest_for_one` or `:one_for_all`)\n\n  * `:transient` - the child process is restarted only if it\n    terminates abnormally, i.e., with an exit reason other than\n    `:normal`, `:shutdown` or `{:shutdown, term}`\n\nNote that supervisor that reached maximum restart intensity will exit with `:shutdown` reason.\nIn this case the supervisor will only restart if its child specification was defined with\nthe `:restart` option set to `:permanent` (the default)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Spec.Elixir.Supervisor.Spec <response> # Shutdown values (`:shutdown`)\n\nThe following shutdown values are supported in the `:shutdown` option:\n\n  * `:brutal_kill` - the child process is unconditionally terminated\n    using `Process.exit(child, :kill)`\n\n  * `:infinity` - if the child process is a supervisor, this is a mechanism\n    to give the subtree enough time to shut down; it can also be used with\n    workers with care\n\n  * a non-negative integer - the amount of time in milliseconds\n    that the supervisor tells the child process to terminate by calling\n    `Process.exit(child, :shutdown)` and then waits for an exit signal back.\n    If no exit signal is received within the specified time,\n    the child process is unconditionally terminated\n    using `Process.exit(child, :kill)`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.child_spec(module_or_map, overrides) <response> Builds and overrides a child specification.\n\nSimilar to `start_link/2` and `init/2`, it expects a module, `{module, arg}`,\nor a [child specification](`t:child_spec/0`).\n\nIf a two-element tuple in the shape of `{module, arg}` is given,\nthe child specification is retrieved by calling `module.child_spec(arg)`.\n\nIf a module is given, the child specification is retrieved by calling\n`module.child_spec([])`.\n\nAfter the child specification is retrieved, the fields on `overrides`\nare directly applied on the child spec. If `overrides` has keys that\ndo not map to any child specification field, an error is raised.\n\nSee the \"Child specification\" section in the module documentation\nfor all of the available keys for overriding.\n\n## Examples\n\nThis function is often used to set an `:id` option when\nthe same module needs to be started multiple times in the\nsupervision tree:\n\n    Supervisor.child_spec({Agent, fn -> :ok end}, id: {Agent, 1})\n    #=> %{id: {Agent, 1},\n    #=>   start: {Agent, :start_link, [fn -> :ok end]}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.count_children(supervisor) <response> Returns a map containing count values for the given supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the total count of children, dead or alive\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not these\n    child supervisors are still alive\n\n  * `:workers` - the count of all workers, whether or not these child workers\n    are still alive"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.delete_child(supervisor, child_id) <response> Deletes the child specification identified by `child_id`.\n\nThe corresponding child process must not be running; use `terminate_child/2`\nto terminate it if it's running.\n\nIf successful, this function returns `:ok`. This function may return an error\nwith an appropriate error tuple if the `child_id` is not found, or if the\ncurrent process is running or being restarted."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.init(children, options) <response> Receives a list of child specifications to initialize and a set of `options`.\n\nThis is typically invoked at the end of the `c:init/1` callback of\nmodule-based supervisors. See the sections \"Supervisor strategies and options\" and\n\"Module-based supervisors\" in the module documentation for more information.\n\nThis function returns a tuple containing the supervisor\nflags and child specifications.\n\n## Examples\n\n    def init(_init_arg) do\n      children = [\n        {Counter, 0}\n      ]\n\n      Supervisor.init(children, strategy: :one_for_one)\n    end\n\n## Options\n\n  * `:strategy` - the supervision strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, or `:one_for_all`\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in seconds in which `:max_restarts`\n    applies. Defaults to `5`.\n\nThe `:strategy` option is required and by default a maximum of 3 restarts\nis allowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.restart_child(supervisor, child_id) <response> Restarts a child process identified by `child_id`.\n\nThe child specification must exist and the corresponding child process must not\nbe running.\n\nNote that for temporary children, the child specification is automatically deleted\nwhen the child terminates, and thus it is not possible to restart such children.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child, info}`,\nthe PID is added to the supervisor and this function returns the same value.\n\nIf the child process start function returns `:ignore`, the PID remains set to\n`:undefined` and this function returns `{:ok, :undefined}`.\n\nThis function may return an error with an appropriate error tuple if the\n`child_id` is not found, or if the current process is running or being\nrestarted.\n\nIf the child process start function returns an error tuple or an erroneous value,\nor if it fails, this function returns `{:error, error}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.start_child(supervisor, child_spec) <response> Adds a child specification to `supervisor` and starts that child.\n\n`child_spec` should be a valid child specification. The child process will\nbe started as defined in the child specification.\n\nIf a child specification with the specified ID already exists, `child_spec` is\ndiscarded and this function returns an error with `:already_started` or\n`:already_present` if the corresponding child process is running or not,\nrespectively.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child,\ninfo}`, then child specification and PID are added to the supervisor and\nthis function returns the same value.\n\nIf the child process start function returns `:ignore`, the child specification\nis added to the supervisor, the PID is set to `:undefined` and this function\nreturns `{:ok, :undefined}`.\n\nIf the child process start function returns an error tuple or an erroneous\nvalue, or if it fails, the child specification is discarded and this function\nreturns `{:error, error}` where `error` is a term containing information about\nthe error and child specification."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.start_link(children, options) <response> Starts a supervisor with the given children.\n\n`children` is a list of the following forms:\n\n  * a [child specification](`t:child_spec/0`)\n\n  * a module, where `module.child_spec([])` will be invoked to retrieve\n    its child specification\n\n  * a two-element tuple in the shape of `{module, arg}`, where `module.child_spec(arg)`\n    will be invoked to retrieve its child specification\n\nA strategy is required to be provided through the `:strategy` option. See\n\"Supervisor strategies and options\" for examples and other options.\n\nThe options can also be used to register a supervisor name.\nThe supported values are described under the \"Name registration\"\nsection in the `GenServer` module docs.\n\nIf the supervisor and all child processes are successfully spawned\n(if the start function of each child process returns `{:ok, child}`,\n`{:ok, child, info}`, or `:ignore`), this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nIf the start function of any of the child processes fails or returns an error\ntuple or an erroneous value, the supervisor first terminates with reason\n`:shutdown` all the child processes that have already been started, and then\nterminates itself and returns `{:error, {:shutdown, reason}}`.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.start_link(module, init_arg, options \\\\ []) <response> Starts a module-based supervisor process with the given `module` and `init_arg`.\n\nTo start the supervisor, the `c:init/1` callback will be invoked in the given\n`module`, with `init_arg` as its argument. The `c:init/1` callback must return a\nsupervisor specification which can be created with the help of the `init/2`\nfunction.\n\nIf the `c:init/1` callback returns `:ignore`, this function returns\n`:ignore` as well and the supervisor terminates with reason `:normal`.\nIf it fails or returns an incorrect value, this function returns\n`{:error, term}` where `term` is a term with information about the\nerror, and the supervisor terminates with reason `term`.\n\nThe `:name` option can also be given in order to register a supervisor\nname, the supported values are described in the \"Name registration\"\nsection in the `GenServer` module docs."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.stop(supervisor, reason \\\\ :normal, timeout \\\\ :infinity) <response> Synchronously stops the given supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.terminate_child(supervisor, child_id) <response> Terminates the given child identified by `child_id`.\n\nThe process is terminated, if there's one. The child specification is\nkept unless the child is temporary.\n\nA non-temporary child process may later be restarted by the supervisor.\nThe child process can also be restarted explicitly by calling `restart_child/2`.\nUse `delete_child/2` to remove the child specification.\n\nIf successful, this function returns `:ok`. If there is no child\nspecification for the given child ID, this function returns\n`{:error, :not_found}`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.which_children(supervisor) <response> Returns a list with information about all children of the given supervisor.\n\nNote that calling this function when supervising a large number of children\nunder low memory conditions can cause an out of memory exception.\n\nThis function returns a list of `{id, child, type, modules}` tuples, where:\n\n  * `id` - as defined in the child specification\n\n  * `child` - the PID of the corresponding child process, `:restarting` if the\n    process is about to be restarted, or `:undefined` if there is no such\n    process\n\n  * `type` - `:worker` or `:supervisor`, as specified by the child specification\n\n  * `modules` - as specified by the child specification"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> A behaviour module for implementing supervisors.\n\nA supervisor is a process which supervises other processes, which we\nrefer to as *child processes*. Supervisors are used to build a hierarchical\nprocess structure called a *supervision tree*. Supervision trees provide\nfault-tolerance and encapsulate how our applications start and shutdown.\n\nA supervisor may be started directly with a list of child specifications via\n`start_link/2` or you may define a module-based supervisor that implements\nthe required callbacks. The sections below use `start_link/2` to start\nsupervisors in most examples, but it also includes a specific section\non module-based ones."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Examples\n\nIn order to start a supervisor, we need to first define a child process\nthat will be supervised. As an example, we will define a `GenServer`,\na generic server, that keeps a counter. Other processes can then send\nmessages to this process to read the counter and bump its value.\n\n> Note: in practice you would not define a counter as a GenServer. Instead,\n> if you need a counter, you would pass it around as inputs and outputs to\n> the functions that need it. The reason we picked a counter in this example\n> is due to its simplicity, as it allows us to focus on how supervisors work.\n\n    defmodule Counter do\n      use GenServer\n\n      def start_link(arg) when is_integer(arg) do\n        GenServer.start_link(__MODULE__, arg, name: __MODULE__)\n      end\n\n      ## Callbacks\n\n      @impl true\n      def init(counter) do\n        {:ok, counter}\n      end\n\n      @impl true\n      def handle_call(:get, _from, counter) do\n        {:reply, counter, counter}\n      end\n\n      def handle_call({:bump, value}, _from, counter) do\n        {:reply, counter, counter + value}\n      end\n    end\n\nThe `Counter` receives an argument on `start_link`. This argument\nis passed to the `init/1` callback which becomes the initial value\nof the counter. Our counter handles two operations (known as calls):\n`:get`, to get the current counter value, and `:bump`, that bumps\nthe counter by the given `value` and returns the old counter.\n\nWe can now start a supervisor that will start and supervise our\ncounter process. The first step is to define a list of **child\nspecifications** that control how each child behaves. Each child\nspecification is a map, as shown below:\n\n    children = [\n      # The Counter is a child started via Counter.start_link(0)\n      %{\n        id: Counter,\n        start: {Counter, :start_link, [0]}\n      }\n    ]\n\n    # Now we start the supervisor with the children and a strategy\n    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n\n    # After started, we can query the supervisor for information\n    Supervisor.count_children(pid)\n    #=> %{active: 1, specs: 1, supervisors: 0, workers: 1}\n\nNote that when starting the GenServer, we are registering it\nwith name `Counter` via the `name: __MODULE__` option. This allows\nus to call it directly and get its value:\n\n    GenServer.call(Counter, :get)\n    #=> 0\n\n    GenServer.cast(Counter, {:bump, 3})\n    #=> 0\n\n    GenServer.call(Counter, :get)\n    #=> 3\n\nHowever, there is a bug in our counter server. If we call `:bump` with\na non-numeric value, it is going to crash:\n\n    GenServer.call(Counter, {:bump, \"oops\"})\n    ** (exit) exited in: GenServer.call(Counter, {:bump, \"oops\"}, 5000)\n\nLuckily, since the server is being supervised by a supervisor, the\nsupervisor will automatically start a new one, reset back to its initial\nvalue of `0`:\n\n    GenServer.call(Counter, :get)\n    #=> 0\n\nSupervisors support different strategies; in the example above, we\nhave chosen `:one_for_one`. Furthermore, each supervisor can have many\nworkers and/or supervisors as children, with each one having its own\nconfiguration (as outlined in the \"Child specification\" section).\n\nThe rest of this document will cover how child processes are specified,\nhow they can be started and stopped, different supervision strategies\nand more."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Child specification\n\nThe child specification describes how the supervisor starts, shuts down,\nand restarts child processes.\n\nThe child specification is a map containing up to 6 elements. The first two keys\nin the following list are required, and the remaining ones are optional:\n\n  * `:id` - any term used to identify the child specification internally by\n    the supervisor; defaults to the given module. This key is required.\n    For supervisors, in the case of conflicting `:id` values, the supervisor\n    will refuse to initialize and require explicit IDs. This is not the case\n    for [dynamic supervisors](`DynamicSupervisor`) though.\n\n  * `:start` - a tuple with the module-function-args to be invoked\n    to start the child process. This key is required.\n\n  * `:restart` - an atom that defines when a terminated child process\n     should be restarted (see the \"Restart values\" section below).\n     This key is optional and defaults to `:permanent`.\n\n  * `:shutdown` - an integer or atom that defines how a child process should\n    be terminated (see the \"Shutdown values\" section below). This key\n    is optional and defaults to `5_000` if the type is `:worker` or\n    `:infinity` if the type is `:supervisor`.\n\n  * `:type` - specifies that the child process is a `:worker` or a\n    `:supervisor`. This key is optional and defaults to `:worker`.\n\n  * `:modules` - a list of modules used by hot code upgrade mechanisms\n    to determine which processes are using certain modules. It is typically\n    set to the callback module of behaviours like `GenServer`, `Supervisor`,\n    and such. It is set automatically based on the `:start` value and it is rarely\n    changed in practice.\n\nLet's understand what the `:shutdown` and `:restart` options control."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> # Shutdown values (:shutdown)\n\nThe following shutdown values are supported in the `:shutdown` option:\n\n  * `:brutal_kill` - the child process is unconditionally and immediately\n    terminated using `Process.exit(child, :kill)`.\n\n  * any integer >= 0 - the amount of time in milliseconds that the\n    supervisor will wait for its children to terminate after emitting a\n    `Process.exit(child, :shutdown)` signal. If the child process is\n    not trapping exits, the initial `:shutdown` signal will terminate\n    the child process immediately. If the child process is trapping\n    exits, it has the given amount of time to terminate.\n    If it doesn't terminate within the specified time, the child process\n    is unconditionally terminated by the supervisor via\n    `Process.exit(child, :kill)`.\n\n  * `:infinity` - works as an integer except the supervisor will wait\n    indefinitely for the child to terminate. If the child process is a\n    supervisor, the recommended value is `:infinity` to give the supervisor\n    and its children enough time to shut down. This option can be used with\n    regular workers but doing so is discouraged and requires extreme care.\n    If not used carefully, the child process will never terminate,\n    preventing your application from terminating as well."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> # Restart values (:restart)\n\nThe `:restart` option controls what the supervisor should consider to\nbe a successful termination or not. If the termination is successful,\nthe supervisor won't restart the child. If the child process crashed,\nthe supervisor will start a new one.\n\nThe following restart values are supported in the `:restart` option:\n\n  * `:permanent` - the child process is always restarted.\n\n  * `:temporary` - the child process is never restarted, regardless\n    of the supervision strategy: any termination (even abnormal) is\n    considered successful.\n\n  * `:transient` - the child process is restarted only if it\n    terminates abnormally, i.e., with an exit reason other than\n    `:normal`, `:shutdown`, or `{:shutdown, term}`.\n\nFor a more complete understanding of the exit reasons and their\nimpact, see the \"Exit reasons and restarts\" section."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> `child_spec/1` function\n\nWhen starting a supervisor, we may pass a list of child specifications. Those\nspecifications are maps that tell how the supervisor should start, stop and\nrestart each of its children:\n\n    %{\n      id: Counter,\n      start: {Counter, :start_link, [0]}\n    }\n\nThe map above defines a child with `:id` of `Counter` that is started\nby calling `Counter.start_link(0)`.\n\nHowever, defining the child specification for each child as a map can be\nquite error prone, as we may change the `Counter` implementation and forget\nto update its specification. That's why Elixir allows you to pass a tuple with\nthe module name and the `start_link` argument instead of the specification:\n\n    children = [\n      {Counter, 0}\n    ]\n\nThe supervisor will then invoke `Counter.child_spec(0)` to retrieve a child\nspecification. Now the `Counter` module is responsible for building its own\nspecification, for example, we could write:\n\n    def child_spec(arg) do\n      %{\n        id: Counter,\n        start: {Counter, :start_link, [arg]}\n      }\n    end\n\nLuckily for us, `use GenServer` already defines a `Counter.child_spec/1`\nexactly like above, so you don't need to write the definition above yourself.\nIf you want to customize the automatically generated `child_spec/1` function,\nyou can pass the options directly to `use GenServer`:\n\n    use GenServer, restart: :transient\n\nFinally, note it is also possible to simply pass the `Counter` module as\na child:\n\n    children = [\n      Counter\n    ]\n\nWhen only the module name is given, it is equivalent to `{Counter, []}`,\nwhich in our case would be invalid, which is why we always pass the initial\ncounter explicitly.\n\nBy replacing the child specification with `{Counter, 0}`, we keep it\nencapsulated in the `Counter` module. We could now share our\n`Counter` implementation with other developers and they can add it directly\nto their supervision tree without worrying about the low-level details of\nthe counter.\n\nOverall, a child specification can be one of the following:\n\n  * a map representing the child specification itself - as outlined in the\n    \"Child specification\" section\n\n  * a tuple with a module as first element and the start argument as second -\n    such as `{Counter, 0}`. In this case, `Counter.child_spec(0)` is called\n    to retrieve the child specification\n\n  * a module - such as `Counter`. In this case, `Counter.child_spec([])`\n    would be called, which is invalid for the counter, but it is useful in\n    many other cases, especially when you want to pass a list of options\n    to the child process\n\nIf you need to convert a `{module, arg}` tuple or a module child specification to a\n[child specification](`t:child_spec/0`) or modify a child specification itself,\nyou can use the `Supervisor.child_spec/2` function.\nFor example, to run the counter with a different `:id` and a `:shutdown` value of\n10 seconds (10_000 milliseconds):\n\n    children = [\n      Supervisor.child_spec({Counter, 0}, id: MyCounter, shutdown: 10_000)\n    ]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Supervisor strategies and options\n\nSo far we have started the supervisor passing a single child as a tuple\nas well as a strategy called `:one_for_one`:\n\n    children = [\n      {Counter, 0}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe first argument given to `start_link/2` is a list of child\nspecifications as defined in the \"child_spec/1\" section above.\n\nThe second argument is a keyword list of options:\n\n  * `:strategy` - the supervision strategy option. It can be either\n    `:one_for_one`, `:rest_for_one` or `:one_for_all`. Required.\n    See the \"Strategies\" section.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:name` - a name to register the supervisor process. Supported values are\n    explained in the \"Name registration\" section in the documentation for\n    `GenServer`. Optional."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> # Strategies\n\nSupervisors support different supervision strategies (through the\n`:strategy` option, as seen above):\n\n  * `:one_for_one` - if a child process terminates, only that\n    process is restarted.\n\n  * `:one_for_all` - if a child process terminates, all other child\n    processes are terminated and then all child processes (including\n    the terminated one) are restarted.\n\n  * `:rest_for_one` - if a child process terminates, the terminated child\n    process and the rest of the children started after it, are terminated and\n    restarted.\n\nIn the above, process termination refers to unsuccessful termination, which\nis determined by the `:restart` option.\n\nTo efficiently supervise children started dynamically, see `DynamicSupervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> # Name registration\n\nA supervisor is bound to the same name registration rules as a `GenServer`.\nRead more about these rules in the documentation for `GenServer`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Module-based supervisors\n\nIn the example so far, the supervisor was started by passing the supervision\nstructure to `start_link/2`. However, supervisors can also be created by\nexplicitly defining a supervision module:\n\n    defmodule MyApp.Supervisor do\n      # Automatically defines child_spec/1\n      use Supervisor\n\n      def start_link(init_arg) do\n        Supervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      @impl true\n      def init(_init_arg) do\n        children = [\n          {Counter, 0}\n        ]\n\n        Supervisor.init(children, strategy: :one_for_one)\n      end\n    end\n\nThe difference between the two approaches is that a module-based\nsupervisor gives you more direct control over how the supervisor\nis initialized. Instead of calling `Supervisor.start_link/2` with\na list of child specifications that are automatically initialized, we manually\ninitialize the children by calling `Supervisor.init/2` inside its\n`c:init/1` callback. `Supervisor.init/2` accepts the same `:strategy`,\n`:max_restarts`, and `:max_seconds` options as `start_link/2`.\n\n`use Supervisor` also defines a `child_spec/1` function which allows\nus to run `MyApp.Supervisor` as a child of another supervisor or\nat the top of your supervision tree as:\n\n    children = [\n      MyApp.Supervisor\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nA general guideline is to use the supervisor without a callback\nmodule only at the top of your supervision tree, generally in the\n`c:Application.start/2` callback. We recommend using module-based\nsupervisors for any other supervisor in your application, so they\ncan run as a child of another supervisor in the tree. The `child_spec/1`\ngenerated automatically by `Supervisor` can be customized with the\nfollowing options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the supervisor should be restarted, defaults to `:permanent`\n\nThe `@doc` annotation immediately preceding `use Supervisor` will be\nattached to the generated `child_spec/1` function."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Start and shutdown\n\nWhen the supervisor starts, it traverses all child specifications and\nthen starts each child in the order they are defined. This is done by\ncalling the function defined under the `:start` key in the child\nspecification and typically defaults to `start_link/1`.\n\nThe `start_link/1` (or a custom) is then called for each child process.\nThe `start_link/1` function must return `{:ok, pid}` where `pid` is the\nprocess identifier of a new process that is linked to the supervisor.\nThe child process usually starts its work by executing the `c:init/1`\ncallback. Generally speaking, the `init` callback is where we initialize\nand configure the child process.\n\nThe shutdown process happens in reverse order.\n\nWhen a supervisor shuts down, it terminates all children in the opposite\norder they are listed. The termination happens by sending a shutdown exit\nsignal, via `Process.exit(child_pid, :shutdown)`, to the child process and\nthen awaiting for a time interval for the child process to terminate. This\ninterval defaults to 5000 milliseconds. If the child process does not\nterminate in this interval, the supervisor abruptly terminates the child\nwith reason `:kill`. The shutdown time can be configured in the child\nspecification which is fully detailed in the next section.\n\nIf the child process is not trapping exits, it will shutdown immediately\nwhen it receives the first exit signal. If the child process is trapping\nexits, then the `terminate` callback is invoked, and the child process\nmust terminate in a reasonable time interval before being abruptly\nterminated by the supervisor.\n\nIn other words, if it is important that a process cleans after itself\nwhen your application or the supervision tree is shutting down, then\nthis process must trap exits and its child specification should specify\nthe proper `:shutdown` value, ensuring it terminates within a reasonable\ninterval."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Supervisor.Elixir.Supervisor <response> Exit reasons and restarts\n\nA supervisor restarts a child process depending on its `:restart` configuration.\nFor example, when `:restart` is set to `:transient`, the supervisor does not\nrestart the child in case it exits with reason `:normal`, `:shutdown` or\n`{:shutdown, term}`.\n\nSo one may ask: which exit reason should I choose when exiting? There are\nthree options:\n\n  * `:normal` - in such cases, the exit won't be logged, there is no restart\n    in transient mode, and linked processes do not exit\n\n  * `:shutdown` or `{:shutdown, term}` - in such cases, the exit won't be\n    logged, there is no restart in transient mode, and linked processes exit\n    with the same reason unless they're trapping exits\n\n  * any other term - in such cases, the exit will be logged, there are\n    restarts in transient mode, and linked processes exit with the same\n    reason unless they're trapping exits\n\nNote that the supervisor that reaches maximum restart intensity will exit with\n`:shutdown` reason. In this case the supervisor will only be restarted if its\nchild specification was defined with the `:restart` option set to `:permanent`\n(the default)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.argv() <response> Lists command line arguments.\n\nReturns the list of command line arguments passed to the program."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.argv(args) <response> Modifies command line arguments.\n\nChanges the list of command line arguments. Use it with caution,\nas it destroys any previous argv information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.at_exit(fun) <response> Registers a program exit handler function.\n\nRegisters a function that will be invoked at the end of an Elixir script.\nA script is typically started via the command line via the `elixir` and\n`mix` executables.\n\nThe handler always executes in a different process from the one it was\nregistered in. As a consequence, any resources managed by the calling process\n(ETS tables, open files, and others) won't be available by the time the handler\nfunction is invoked.\n\nThe function must receive the exit status code as an argument.\n\nIf the VM terminates programmatically, via `System.stop/1`, `System.halt/1`,\nor exit signals, the `at_exit/1` callbacks are not executed."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.build_info() <response> Elixir build information.\n\nReturns a map with the Elixir version, the Erlang/OTP release it was compiled\nwith, a short Git revision hash and the date and time it was built.\n\nEvery value in the map is a string, and these are:\n\n  * `:build` - the Elixir version, short Git revision hash and\n    Erlang/OTP release it was compiled with\n  * `:date` - a string representation of the ISO8601 date and time it was built\n  * `:otp_release` - OTP release it was compiled with\n  * `:revision` - short Git revision hash. If Git was not available at building\n    time, it is set to `\"\"`\n  * `:version` - the Elixir version\n\nOne should not rely on the specific formats returned by each of those fields.\nInstead one should use specialized functions, such as `version/0` to retrieve\nthe Elixir version and `otp_release/0` to retrieve the Erlang/OTP release.\n\n## Examples\n\n    iex> System.build_info()\n    %{\n      build: \"1.9.0-dev (772a00a0c) (compiled with Erlang/OTP 21)\",\n      date: \"2018-12-24T01:09:21Z\",\n      otp_release: \"21\",\n      revision: \"772a00a0c\",\n      version: \"1.9.0-dev\"\n    }"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.cmd(command, args, opts \\\\ []) <response> Executes the given `command` with `args`.\n\n`command` is expected to be an executable available in PATH\nunless an absolute path is given.\n\n`args` must be a list of binaries which the executable will receive\nas its arguments as is. This means that:\n\n  * environment variables will not be interpolated\n  * wildcard expansion will not happen (unless `Path.wildcard/2` is used\n    explicitly)\n  * arguments do not need to be escaped or quoted for shell safety\n\nThis function returns a tuple containing the collected result\nand the command exit status.\n\nInternally, this function uses a `Port` for interacting with the\noutside world. However, if you plan to run a long-running program,\nports guarantee stdin/stdout devices will be closed but it does not\nautomatically terminate the program. The documentation for the\n`Port` module describes this problem and possible solutions under\nthe \"Zombie processes\" section.\n\n## Examples\n\n    iex> System.cmd(\"echo\", [\"hello\"])\n    {\"hello\\n\", 0}\n\n    iex> System.cmd(\"echo\", [\"hello\"], env: [{\"MIX_ENV\", \"test\"}])\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.cmd(\"echo\", [\"hello\"], into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}\n\n## Options\n\n  * `:into` - injects the result into the given collectable, defaults to `\"\"`\n  * `:cd` - the directory to run the command in\n  * `:env` - an enumerable of tuples containing environment key-value as\n    binary. The child process inherits all environment variables from its\n    parent process, the Elixir application, except those overwritten or\n    cleared using this option. Specify a value of `nil` to clear (unset) an\n    environment variable, which is useful for preventing credentials passed\n    to the application from leaking into child processes.\n  * `:arg0` - sets the command arg0\n  * `:stderr_to_stdout` - redirects stderr to stdout when `true`\n  * `:parallelism` - when `true`, the VM will schedule port tasks to improve\n    parallelism in the system. If set to `false`, the VM will try to perform\n    commands immediately, improving latency at the expense of parallelism.\n    The default can be set on system startup by passing the \"+spp\" argument\n    to `--erl`.\n\n## Error reasons\n\nIf invalid arguments are given, `ArgumentError` is raised by\n`System.cmd/3`. `System.cmd/3` also expects a strict set of\noptions and will raise if unknown or invalid options are given.\n\nFurthermore, `System.cmd/3` may fail with one of the POSIX reasons\ndetailed below:\n\n  * `:system_limit` - all available ports in the Erlang emulator are in use\n\n  * `:enomem` - there was not enough memory to create the port\n\n  * `:eagain` - there are no more available operating system processes\n\n  * `:enametoolong` - the external command given was too long\n\n  * `:emfile` - there are no more available file descriptors\n    (for the operating system process that the Erlang emulator runs in)\n\n  * `:enfile` - the file table is full (for the entire operating system)\n\n  * `:eacces` - the command does not point to an executable file\n\n  * `:enoent` - the command does not point to an existing file\n\n## Shell commands\n\nIf you desire to execute a trusted command inside a shell, with pipes,\nredirecting and so on, please check `shell/2`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.compiled_endianness() <response> Returns the endianness the system was compiled with."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.convert_time_unit(time, from_unit, to_unit) <response> Converts `time` from time unit `from_unit` to time unit `to_unit`.\n\nThe result is rounded via the floor function.\n\n`convert_time_unit/3` accepts an additional time unit (other than the\nones in the `t:time_unit/0` type) called `:native`. `:native` is the time\nunit used by the Erlang runtime system. It's determined when the runtime\nstarts and stays the same until the runtime is stopped, but could differ\nthe next time the runtime is started on the same machine. For this reason,\nyou should use this function to convert `:native` time units to a predictable\nunit before you display them to humans.\n\nTo determine how many seconds the `:native` unit represents in your current\nruntime, you can call this function to convert 1 second to the `:native`\ntime unit: `System.convert_time_unit(1, :second, :native)`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.cwd() <response> Current working directory.\n\nReturns the current working directory or `nil` if one\nis not available."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.cwd!() <response> Current working directory, exception on error.\n\nReturns the current working directory or raises `RuntimeError`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.delete_env(varname) <response> Deletes an environment variable.\n\nRemoves the variable `varname` from the environment."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.endianness() <response> Returns the endianness."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.fetch_env(varname) <response> Returns the value of the given environment variable or `:error` if not found.\n\nIf the environment variable `varname` is set, then `{:ok, value}` is returned\nwhere `value` is a string. If `varname` is not set, `:error` is returned.\n\n## Examples\n\n    iex> System.fetch_env(\"PORT\")\n    {:ok, \"4000\"}\n\n    iex> System.fetch_env(\"NOT_SET\")\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.fetch_env!(varname) <response> Returns the value of the given environment variable or raises if not found.\n\nSame as `get_env/1` but raises instead of returning `nil` when the variable is\nnot set.\n\n## Examples\n\n    iex> System.fetch_env!(\"PORT\")\n    \"4000\"\n\n    iex> System.fetch_env!(\"NOT_SET\")\n    ** (ArgumentError) could not fetch environment variable \"NOT_SET\" because it is not set"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.find_executable(program) <response> Locates an executable on the system.\n\nThis function looks up an executable program given\nits name using the environment variable PATH on Windows and Unix-like\noperating systems. It also considers the proper executable\nextension for each operating system, so for Windows it will try to\nlookup files with `.com`, `.cmd` or similar extensions."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.get_env() <response> Returns all system environment variables.\n\nThe returned value is a map containing name-value pairs.\nVariable names and their values are strings."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.get_env(varname, default \\\\ nil) <response> Returns the value of the given environment variable.\n\nThe returned value of the environment variable\n`varname` is a string. If the environment variable\nis not set, returns the string specified in `default` or\n`nil` if none is specified.\n\n## Examples\n\n    iex> System.get_env(\"PORT\")\n    \"4000\"\n\n    iex> System.get_env(\"NOT_SET\")\n    nil\n\n    iex> System.get_env(\"NOT_SET\", \"4001\")\n    \"4001\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.get_pid() <response> Erlang VM process identifier.\n\nReturns the process identifier of the current Erlang emulator\nin the format most commonly used by the operating system environment.\n\nFor more information, see `:os.getpid/0`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.halt(status \\\\ 0) <response> Immediately halts the Erlang runtime system.\n\nTerminates the Erlang runtime system without properly shutting down\napplications and ports. Please see `stop/1` for a careful shutdown of the\nsystem.\n\n`status` must be a non-negative integer, the atom `:abort` or a binary.\n\n  * If an integer, the runtime system exits with the integer value which\n    is returned to the operating system.\n\n  * If `:abort`, the runtime system aborts producing a core dump, if that is\n    enabled in the operating system.\n\n  * If a string, an Erlang crash dump is produced with status as slogan,\n    and then the runtime system exits with status code 1.\n\nNote that on many platforms, only the status codes 0-255 are supported\nby the operating system.\n\nFor more information, see `:erlang.halt/1`.\n\n## Examples\n\n    System.halt(0)\n    System.halt(1)\n    System.halt(:abort)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.monotonic_time() <response> Returns the current monotonic time in the `:native` time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.monotonic_time(unit) <response> Returns the current monotonic time in the given time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.no_halt() <response> Checks if the system will halt or not at the end of ARGV processing."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.no_halt(boolean) <response> Marks if the system should halt or not at the end of ARGV processing."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.os_time() <response> Returns the current operating system (OS) time.\n\nThe result is returned in the `:native` time unit.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.os_time(unit) <response> Returns the current operating system (OS) time in the given time `unit`.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.otp_release() <response> Returns the Erlang/OTP release number."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.pid() <response> Returns the operating system PID for the current Erlang runtime system instance.\n\nReturns a string containing the (usually) numerical identifier for a process.\nOn Unix-like operating systems, this is typically the return value of the `getpid()` system call.\nOn Windows, the process ID as returned by the `GetCurrentProcessId()` system\ncall is used.\n\n## Examples\n\n    System.pid()"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.put_env(enum) <response> Sets multiple environment variables.\n\nSets a new value for each environment variable corresponding\nto each `{key, value}` pair in `enum`. Keys are automatically\nconverted to strings, values are sent as is. `nil` values erase\nthe given keys."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.put_env(varname, value) <response> Sets an environment variable value.\n\nSets a new `value` for the environment variable `varname`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.restart() <response> Restarts all applications in the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system starts all applications once again.\n\n## Examples\n\n    System.restart()"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.schedulers() <response> Returns the number of schedulers in the VM."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.schedulers_online() <response> Returns the number of schedulers online in the VM."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.shell(command, opts \\\\ []) <response> Executes the given `command` in the OS shell.\n\nIt uses `sh` for Unix-like systems and `cmd` for Windows.\n\n> **Important:**: Use this function with care. In particular, **never\n> pass untrusted user input to this function**, as the user would be\n> able to perform \"command injection attacks\" by executing any code\n> directly on the machine. Generally speaking, prefer to use `cmd/3`\n> over this function.\n\n## Examples\n\n    iex> System.shell(\"echo hello\")\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.shell(\"echo hello\", into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}\n\n## Options\n\nIt accepts the same options as `cmd/3` (except for `arg0`).\nIt also accepts the following exclusive options:\n\n  * `:close_stdin` (since v1.14.1) - if the stdin should be closed\n    on Unix systems, forcing any command that waits on stdin to\n    immediately terminate. Defaults to false."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.stacktrace() <response> Deprecated mechanism to retrieve the last exception stacktrace.\n\nIt always return an empty list."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.stop(status \\\\ 0) <response> Carefully stops the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system terminates by calling `halt/1`.\n\n`status` must be a non-negative integer or a binary.\n\n  * If an integer, the runtime system exits with the integer value which is\n    returned to the operating system.\n\n  * If a binary, an Erlang crash dump is produced with status as slogan, and\n    then the runtime system exits with status code 1.\n\nNote that on many platforms, only the status codes 0-255 are supported\nby the operating system.\n\n## Examples\n\n    System.stop(0)\n    System.stop(1)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.system_time() <response> Returns the current system time in the `:native` time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.system_time(unit) <response> Returns the current system time in the given time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.time_offset() <response> Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the `:native` time unit.\n\nSee `time_offset/1` for more information.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.time_offset(unit) <response> Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the given time unit `unit`. The returned\noffset, added to an Erlang monotonic time (for instance, one obtained with\n`monotonic_time/1`), gives the Erlang system time that corresponds\nto that monotonic time."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.tmp_dir() <response> Writable temporary directory.\n\nReturns a writable temporary directory.\nSearches for directories in the following order:\n\n  1. the directory named by the TMPDIR environment variable\n  2. the directory named by the TEMP environment variable\n  3. the directory named by the TMP environment variable\n  4. `C:\\TMP` on Windows or `/tmp` on Unix-like operating systems\n  5. as a last resort, the current working directory\n\nReturns `nil` if none of the above are writable."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.tmp_dir!() <response> Writable temporary directory, exception on error.\n\nSame as `tmp_dir/0` but raises `RuntimeError`\ninstead of returning `nil` if no temp dir is set."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.trap_signal(signal, id \\\\ make_ref(), fun) <response> Traps the given `signal` to execute the `fun`.\n\n> **Important**: Trapping signals may have strong implications\n> on how a system shuts down and behave in production and\n> therefore it is extremely discouraged for libraries to\n> set their own traps. Instead, they should redirect users\n> to configure them themselves. The only cases where it is\n> acceptable for libraries to set their own traps is when\n> using Elixir in script mode, such as in `.exs` files and\n> via Mix tasks.\n\nAn optional `id` that uniquely identifies the function\ncan be given, otherwise a unique one is automatically\ngenerated. If a previously registered `id` is given,\nthis function returns an error tuple. The `id` can be\nused to remove a registered signal by calling\n`untrap_signal/2`.\n\nThe given `fun` receives no arguments and it must return\n`:ok`.\n\nIt returns `{:ok, id}` in case of success,\n`{:error, :already_registered}` in case the id has already\nbeen registered for the given signal, or `{:error, :not_sup}`\nin case trapping exists is not supported by the current OS.\n\nThe first time a signal is trapped, it will override the\ndefault behaviour from the operating system. If the same\nsignal is trapped multiple times, subsequent functions\ngiven to `trap_signal` will execute *first*. In other\nwords, you can consider each function is prepended to\nthe signal handler.\n\nBy default, the Erlang VM register traps to the three\nsignals:\n\n  * `:sigstop` - gracefully shuts down the VM with `stop/0`\n  * `:sigquit` - halts the VM via `halt/0`\n  * `:sigusr1` - halts the VM via status code of 1\n\nTherefore, if you add traps to the signals above, the\ndefault behaviour above will be executed after all user\nsignals.\n\n## Implementation notes\n\nAll signals run from a single process. Therefore, blocking the\n`fun` will block subsequent traps. It is also not possible to add\nor remove traps from within a trap itself.\n\nInternally, this functionality is built on top of `:os.set_signal/2`.\nWhen you register a trap, Elixir automatically sets it to `:handle`\nand it reverts it back to `:default` once all traps are removed\n(except for `:sigquit`, `:sigterm`, and `:sigusr1` which are always\nhandled). If you or a library call `:os.set_signal/2` directly,\nit may disable Elixir traps (or Elixir may override your configuration)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.unique_integer(modifiers \\\\ []) <response> Generates and returns an integer that is unique in the current runtime\ninstance.\n\n\"Unique\" means that this function, called with the same list of `modifiers`,\nwill never return the same integer more than once on the current runtime\ninstance.\n\nIf `modifiers` is `[]`, then a unique integer (that can be positive or negative) is returned.\nOther modifiers can be passed to change the properties of the returned integer:\n\n  * `:positive` - the returned integer is guaranteed to be positive.\n  * `:monotonic` - the returned integer is monotonically increasing. This\n    means that, on the same runtime instance (but even on different\n    processes), integers returned using the `:monotonic` modifier will always\n    be strictly less than integers returned by successive calls with the\n    `:monotonic` modifier.\n\nAll modifiers listed above can be combined; repeated modifiers in `modifiers`\nwill be ignored.\n\nInlined by the compiler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.untrap_signal(signal, id) <response> Removes a previously registered `signal` with `id`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.user_home() <response> User home directory.\n\nReturns the user home directory (platform independent)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.user_home!() <response> User home directory, exception on error.\n\nSame as `user_home/0` but raises `RuntimeError`\ninstead of returning `nil` if no user home is set."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.version() <response> Elixir version information.\n\nReturns Elixir's version as binary."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.Elixir.System <response> The `System` module provides functions that interact directly\nwith the VM or the host system."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.System.Elixir.System <response> Time\n\nThe `System` module also provides functions that work with time,\nreturning different times kept by the system with support for\ndifferent time units.\n\nOne of the complexities in relying on system times is that they\nmay be adjusted. For example, when you enter and leave daylight\nsaving time, the system clock will be adjusted, often adding\nor removing one hour. We call such changes \"time warps\". In\norder to understand how such changes may be harmful, imagine\nthe following code:\n\n    ## DO NOT DO THIS\n    prev = System.os_time()\n    # ... execute some code ...\n    next = System.os_time()\n    diff = next - prev\n\nIf, while the code is executing, the system clock changes,\nsome code that executed in 1 second may be reported as taking\nover 1 hour! To address such concerns, the VM provides a\nmonotonic time via `System.monotonic_time/0` which never\ndecreases and does not leap:\n\n    ## DO THIS\n    prev = System.monotonic_time()\n    # ... execute some code ...\n    next = System.monotonic_time()\n    diff = next - prev\n\nGenerally speaking, the VM provides three time measurements:\n\n  * `os_time/0` - the time reported by the operating system (OS). This time may be\n    adjusted forwards or backwards in time with no limitation;\n\n  * `system_time/0` - the VM view of the `os_time/0`. The system time and operating\n    system time may not match in case of time warps although the VM works towards\n    aligning them. This time is not monotonic (i.e., it may decrease)\n    as its behaviour is configured [by the VM time warp\n    mode](https://www.erlang.org/doc/apps/erts/time_correction.html#Time_Warp_Modes);\n\n  * `monotonic_time/0` - a monotonically increasing time provided\n    by the Erlang VM.\n\nThe time functions in this module work in the `:native` unit\n(unless specified otherwise), which is operating system dependent. Most of\nthe time, all calculations are done in the `:native` unit, to\navoid loss of precision, with `convert_time_unit/3` being\ninvoked at the end to convert to a specific time unit like\n`:millisecond` or `:microsecond`. See the `t:time_unit/0` type for\nmore information.\n\nFor a more complete rundown on the VM support for different\ntimes, see the [chapter on time and time\ncorrection](https://www.erlang.org/doc/apps/erts/time_correction.html)\nin the Erlang docs."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async(supervisor, fun, options \\\\ []) <response> Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/3` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async(supervisor, module, fun, args, options \\\\ []) <response> Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/3` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_nolink(supervisor, fun, options \\\\ []) <response> Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/3` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n\n## Compatibility with OTP behaviours\n\nIf you create a task using `async_nolink` inside an OTP behaviour\nlike `GenServer`, you should match on the message coming from the\ntask inside your `c:GenServer.handle_info/2` callback.\n\nThe reply sent by the task will be in the format `{ref, result}`,\nwhere `ref` is the monitor reference held by the task struct\nand `result` is the return value of the task function.\n\nKeep in mind that, regardless of how the task created with `async_nolink`\nterminates, the caller's process will always receive a `:DOWN` message\nwith the same `ref` value that is held by the task struct. If the task\nterminates normally, the reason in the `:DOWN` message will be `:normal`.\n\n## Examples\n\nTypically, you use `async_nolink/3` when there is a reasonable expectation that\nthe task may fail, and you don't want it to take down the caller. Let's see an\nexample where a `GenServer` is meant to run a single task and track its status:\n\n    defmodule MyApp.Server do\n      use GenServer\n\n      # ...\n\n      def start_task do\n        GenServer.call(__MODULE__, :start_task)\n      end\n\n      # In this case the task is already running, so we just return :ok.\n      def handle_call(:start_task, _from, %{ref: ref} = state) when is_reference(ref) do\n        {:reply, :ok, state}\n      end\n\n      # The task is not running yet, so let's start it.\n      def handle_call(:start_task, _from, %{ref: nil} = state) do\n        task =\n          Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn ->\n            ...\n          end)\n\n        # We return :ok and the server will continue running\n        {:reply, :ok, %{state | ref: task.ref}}\n      end\n\n      # The task completed successfully\n      def handle_info({ref, answer}, %{ref: ref} = state) do\n        # We don't care about the DOWN message now, so let's demonitor and flush it\n        Process.demonitor(ref, [:flush])\n        # Do something with the result and then return\n        {:noreply, %{state | ref: nil}}\n      end\n\n      # The task failed\n      def handle_info({:DOWN, ref, :process, _pid, _reason}, %{ref: ref} = state) do\n        # Log and possibly restart the task...\n        {:noreply, %{state | ref: nil}}\n      end\n    end"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_nolink(supervisor, module, fun, args, options \\\\ []) <response> Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/3` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\nNote this function requires the task supervisor to have `:temporary`\nas the `:restart` option (the default), as `async_nolink/5` keeps a\ndirect reference to the task which is lost if the task is restarted."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_stream(supervisor, enumerable, fun, options \\\\ []) <response> Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and linked to the caller process, similarly to `async/3`.\n\nSee `async_stream/6` for discussion, options, and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_stream(supervisor, enumerable, module, function, args, options \\\\ []) <response> Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element will be prepended to the given `args` and processed by its\nown task. The tasks will be spawned under the given `supervisor` and\nlinked to the caller process, similarly to `async/5`.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nThe order of results depends on the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nIf you find yourself trapping exits to handle exits inside\nthe async stream, consider using `async_stream_nolink/6` to start tasks\nthat are not linked to the calling process.\n\n## Options\n\n  * `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. This option is useful when you have large\n    streams and don't want to buffer results before they are delivered.\n    This is also useful when you're using the tasks for side effects.\n    Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time to wait (in milliseconds)\n    without receiving a task reply (across all running tasks).\n    Defaults to `5000`.\n\n  * `:on_timeout` - what do to when a task times out. The possible\n    values are:\n    * `:exit` (default) - the process that spawned the tasks exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value. Defaults to `5000` milliseconds.\n\n## Examples\n\nLet's build a stream and then enumerate it:\n\n    stream = Task.Supervisor.async_stream(MySupervisor, collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_stream_nolink(supervisor, enumerable, fun, options \\\\ []) <response> Returns a stream that runs the given `function` concurrently on each\nelement in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and will not be linked to the caller process, similarly\nto `async_nolink/3`.\n\nSee `async_stream/6` for discussion and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.async_stream_nolink(supervisor, enumerable, module, function, args, options \\\\ []) <response> Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element in `enumerable` will be prepended to the given `args` and processed\nby its own task. The tasks will be spawned under the given `supervisor` and\nwill not be linked to the caller process, similarly to `async_nolink/5`.\n\nSee `async_stream/6` for discussion, options, and examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.children(supervisor) <response> Returns all children PIDs except those that are restarting.\n\nNote that calling this function when supervising a large number\nof children under low memory conditions can cause an out of memory\nexception."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.start_child(supervisor, fun, options \\\\ []) <response> Starts a task as a child of the given `supervisor`.\n\n    Task.Supervisor.start_child(MyTaskSupervisor, fn ->\n      IO.puts \"I am running in a task\"\n    end)\n\nNote that the spawned process is not linked to the caller, but\nonly to the supervisor. This command is useful in case the\ntask needs to perform side-effects (like I/O) and you have no\ninterest in its results nor if it completes successfully.\n\n## Options\n\n  * `:restart` - the restart strategy, may be `:temporary` (the default),\n    `:transient` or `:permanent`. `:temporary` means the task is never\n    restarted, `:transient` means it is restarted if the exit is not\n    `:normal`, `:shutdown` or `{:shutdown, reason}`. A `:permanent` restart\n    strategy means it is always restarted.\n\n  * `:shutdown` - `:brutal_kill` if the task must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.start_child(supervisor, module, fun, args, options \\\\ []) <response> Starts a task as a child of the given `supervisor`.\n\nSimilar to `start_child/3` except the task is specified\nby the given `module`, `fun` and `args`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.start_link(options \\\\ []) <response> Starts a new supervisor.\n\n## Examples\n\nA task supervisor is typically started under a supervision tree using\nthe tuple format:\n\n    {Task.Supervisor, name: MyApp.TaskSupervisor}\n\nYou can also start it by calling `start_link/1` directly:\n\n    Task.Supervisor.start_link(name: MyApp.TaskSupervisor)\n\nBut this is recommended only for scripting and should be avoided in\nproduction code. Generally speaking, processes should always be started\ninside supervision trees.\n\n## Options\n\n  * `:name` - used to register a supervisor name, the supported values are\n    described under the `Name Registration` section in the `GenServer` module\n    docs;\n\n  * `:max_restarts`, `:max_seconds`, and `:max_children` - as specified in\n    `DynamicSupervisor`;\n\nThis function could also receive `:restart` and `:shutdown` as options\nbut those two options have been deprecated and it is now preferred to\ngive them directly to `start_child`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.terminate_child(supervisor, pid) <response> Terminates the child with the given `pid`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.Elixir.Task.Supervisor <response> A task supervisor.\n\nThis module defines a supervisor which can be used to dynamically\nsupervise tasks.\n\nA task supervisor is started with no children, often under a\nsupervisor and a name:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe options given in the child specification are documented in `start_link/1`.\n\nOnce started, you can start tasks directly under the supervisor, for example:\n\n    task = Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n      :do_some_work\n    end)\n\nSee the `Task` module for more examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.Elixir.Task.Supervisor <response> Scalability and partitioning\n\nThe `Task.Supervisor` is a single process responsible for starting\nother processes. In some applications, the `Task.Supervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `Task.Supervisor` and then pick a random instance to start\nthe task on.\n\nInstead of:\n\n    children = [\n      {Task.Supervisor, name: Task.Supervisor}\n    ]\n\nand:\n\n    Task.Supervisor.async(MyApp.TaskSupervisor, fn -> :do_some_work end)\n\nYou can do this:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: Task.Supervisor,\n       name: MyApp.TaskSupervisors}\n    ]\n\nand then:\n\n    Task.Supervisor.async(\n      {:via, PartitionSupervisor, {MyApp.TaskSupervisors, self()}},\n      fn -> :do_some_work end\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `Task.Supervisor` by name, you call it through the\npartition supervisor using the `{:via, PartitionSupervisor, {name, key}}`\nformat, where `name` is the name of the partition supervisor and `key`\nis the routing key. We picked `self()` as the routing key, which means\neach process will be assigned one of the existing task supervisors.\nRead the `PartitionSupervisor` docs for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Supervisor.Elixir.Task.Supervisor <response> Name registration\n\nA `Task.Supervisor` is bound to the same name registration rules as a\n`GenServer`. Read more about them in the `GenServer` docs."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.%Task{} <response> The Task struct.\n\nIt contains these fields:\n\n  * `:mfa` - a three-element tuple containing the module, function name,\n    and arity invoked to start the task in `async/1` and `async/3`\n\n  * `:owner` - the PID of the process that started the task\n\n  * `:pid` - the PID of the task process; `nil` if the task does\n    not use a task process\n\n  * `:ref` - the task monitor reference"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.async(fun) <response> Starts a task that must be awaited on.\n\n`fun` must be a zero-arity anonymous function. This function\nspawns a process that is linked to and monitored by the caller\nprocess. A `Task` struct is returned containing the relevant\ninformation. Developers must eventually call `Task.await/2` or\n`Task.yield/2` followed by `Task.shutdown/2` on the returned task.\n\nRead the `Task` module documentation for more information about\nthe general usage of async tasks.\n\n## Linking\n\nThis function spawns a process that is linked to and monitored\nby the caller process. The linking part is important because it\naborts the task if the parent process dies. It also guarantees\nthe code before async/await has the same properties after you\nadd the async call. For example, imagine you have this:\n\n    x = heavy_fun()\n    y = some_fun()\n    x + y\n\nNow you want to make the `heavy_fun()` async:\n\n    x = Task.async(&heavy_fun/0)\n    y = some_fun()\n    Task.await(x) + y\n\nAs before, if `heavy_fun/0` fails, the whole computation will\nfail, including the caller process. If you don't want the task\nto fail then you must change the `heavy_fun/0` code in the\nsame way you would achieve it if you didn't have the async call.\nFor example, to either return `{:ok, val} | :error` results or,\nin more extreme cases, by using `try/rescue`. In other words,\nan asynchronous task should be thought of as an extension of the\ncaller process rather than a mechanism to isolate it from all errors.\n\nIf you don't want to link the caller to the task, then you\nmust use a supervised task with `Task.Supervisor` and call\n`Task.Supervisor.async_nolink/2`.\n\nIn any case, avoid any of the following:\n\n  * Setting `:trap_exit` to `true` - trapping exits should be\n    used only in special circumstances as it would make your\n    process immune to not only exits from the task but from\n    any other processes.\n\n    Moreover, even when trapping exits, calling `await` will\n    still exit if the task has terminated without sending its\n    result back.\n\n  * Unlinking the task process started with `async`/`await`.\n    If you unlink the processes and the task does not belong\n    to any supervisor, you may leave dangling tasks in case\n    the caller process dies.\n\n## Metadata\n\nThe task created with this function stores `:erlang.apply/2` in\nits `:mfa` metadata field, which is used internally to apply\nthe anonymous function. Use `async/3` if you want another function\nto be used as metadata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.async(module, function_name, args) <response> Starts a task that must be awaited on.\n\nSimilar to `async/1` except the function to be started is\nspecified by the given `module`, `function_name`, and `args`.\nThe `module`, `function_name`, and its arity are stored as\na tuple in the `:mfa` field for reflection purposes."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.async_stream(enumerable, fun, options \\\\ []) <response> Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nWorks the same as `async_stream/5` but with an anonymous function instead of a\nmodule-function-arguments tuple. `fun` must be a one-arity anonymous function.\n\nEach `enumerable` element is passed as argument to the given function `fun` and\nprocessed by its own task. The tasks will be linked to the caller process, similarly\nto `async/1`.\n\n## Example\n\nCount the code points in each string asynchronously, then add the counts together using reduce.\n\n    iex> strings = [\"long string\", \"longer string\", \"there are many of these\"]\n    iex> stream = Task.async_stream(strings, fn text -> text |> String.codepoints() |> Enum.count() end)\n    iex> Enum.reduce(stream, 0, fn {:ok, num}, acc -> num + acc end)\n    47\n\nSee `async_stream/5` for discussion, options, and more examples."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.async_stream(enumerable, module, function_name, args, options \\\\ []) <response> Returns a stream where the given function (`module` and `function_name`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element of `enumerable` will be prepended to the given `args` and\nprocessed by its own task. Those tasks will be linked to an intermediate\nprocess that is then linked to the caller process. This means a failure\nin a task terminates the caller process and a failure in the caller\nprocess terminates all tasks.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nIt's possible to have `{:exit, {element, reason}}` for exits\nusing the `:zip_input_on_exit` option. The order of results depends\non the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nConsider using `Task.Supervisor.async_stream/6` to start tasks\nunder a supervisor. If you find yourself trapping exits to ensure\nerrors in the tasks do not terminate the caller process, consider\nusing `Task.Supervisor.async_stream_nolink/6` to start tasks that\nare not linked to the caller process.\n\n## Options\n\n  * `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. When the output is ordered, Elixir may need to\n    buffer results to emit them in the original order. Setting this option\n    to false disables the need to buffer at the cost of removing ordering.\n    This is also useful when you're using the tasks only for the side effects.\n    Note that regardless of what `:ordered` is set to, the tasks will\n    process asynchronously. If you need to process elements in order,\n    consider using `Enum.map/2` or `Enum.each/2` instead. Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time (in milliseconds or `:infinity`)\n    each task is allowed to execute for. Defaults to `5000`.\n\n  * `:on_timeout` - what to do when a task times out. The possible\n    values are:\n    * `:exit` (default) - the caller (the process that spawned the tasks) exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:zip_input_on_exit` - (since v1.14.0) adds the original\n    input to `:exit` tuples. The value emitted for that task is\n    `{:exit, {input, reason}}`, where `input` is the collection element\n    that caused an exited during processing. Defaults to `false`.\n\n## Example\n\nLet's build a stream and then enumerate it:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)\n\nThe concurrency can be increased or decreased using the `:max_concurrency`\noption. For example, if the tasks are IO heavy, the value can be increased:\n\n    max_concurrency = System.schedulers_online() * 2\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], max_concurrency: max_concurrency)\n    Enum.to_list(stream)\n\nIf you do not care about the results of the computation, you can run\nthe stream with `Stream.run/1`. Also set `ordered: false`, as you don't\ncare about the order of the results either:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], ordered: false)\n    Stream.run(stream)\n\n## First async tasks to complete\n\nYou can also use `async_stream/3` to execute M tasks and find the N tasks\nto complete. For example:\n\n    [\n      &heavy_call_1/0,\n      &heavy_call_2/0,\n      &heavy_call_3/0\n    ]\n    |> Task.async_stream(fn fun -> fun.() end, ordered: false, max_concurrency: 3)\n    |> Stream.filter(&match?({:ok, _}, &1))\n    |> Enum.take(2)\n\nIn the example above, we are executing three tasks and waiting for the\nfirst 2 to complete. We use `Stream.filter/2` to restrict ourselves only\nto successfully completed tasks, and then use `Enum.take/2` to retrieve\nN items. Note it is important to set both `ordered: false` and\n`max_concurrency: M`, where M is the number of tasks, to make sure all\ncalls execute concurrently.\n\n### Attention: unbound async + take\n\nIf you want to potentially process a high number of items and keep only\npart of the results, you may end-up processing more items than desired.\nLet's see an example:\n\n    1..100\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.take(10)\n\nRunning the example above in a machine with 8 cores will process 16 items,\neven though you want only 10 elements, since `async_stream/3` process items\nconcurrently. That's because it will process 8 elements at once. Then all 8\nelements complete at roughly the same time, causing 8 elements to be kicked\noff for processing. Out of these extra 8, only 2 will be used, and the rest\nwill be terminated.\n\nDepending on the problem, you can filter or limit the number of elements\nupfront:\n\n    1..100\n    |> Stream.take(10)\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.to_list()\n\nIn other cases, you likely want to tweak `:max_concurrency` to limit how\nmany elements may be over processed at the cost of reducing concurrency.\nYou can also set the number of elements to take to be a multiple of\n`:max_concurrency`. For instance, setting `max_concurrency: 5` in the\nexample above."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.await(task, timeout \\\\ 5000) <response> Awaits a task reply and returns it.\n\nIn case the task process dies, the caller process will exit with the same\nreason as the task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nIf the task process is linked to the caller process which is the case when\na task is started with `async`, then the task process will also exit. If the\ntask process is trapping exits or not linked to the caller process, then it\nwill continue to run.\n\nThis function assumes the task's monitor is still active or the monitor's\n`:DOWN` message is in the message queue. If it has been demonitored, or the\nmessage already received, this function will wait for the duration of the\ntimeout awaiting the message.\n\nThis function can only be called once for any given task. If you want\nto be able to check multiple times if a long-running task has finished\nits computation, use `yield/2` instead.\n\n## Examples\n\n    iex> task = Task.async(fn -> 1 + 1 end)\n    iex> Task.await(task)\n    2\n\n## Compatibility with OTP behaviours\n\nIt is not recommended to `await` a long-running task inside an OTP\nbehaviour such as `GenServer`. Instead, you should match on the message\ncoming from a task inside your `c:GenServer.handle_info/2` callback.\n\nA GenServer will receive two messages on `handle_info/2`:\n\n  * `{ref, result}` - the reply message where `ref` is the monitor\n    reference returned by the `task.ref` and `result` is the task\n    result\n\n  * `{:DOWN, ref, :process, pid, reason}` - since all tasks are also\n    monitored, you will also receive the `:DOWN` message delivered by\n    `Process.monitor/1`. If you receive the `:DOWN` message without a\n    a reply, it means the task crashed\n\nAnother consideration to have in mind is that tasks started by `Task.async/1`\nare always linked to their callers and you may not want the GenServer to\ncrash if the task crashes. Therefore, it is preferable to instead use\n`Task.Supervisor.async_nolink/3` inside OTP behaviours. For completeness, here\nis an example of a GenServer that start tasks and handles their results:\n\n    defmodule GenServerTaskExample do\n      use GenServer\n\n      def start_link(opts) do\n        GenServer.start_link(__MODULE__, :ok, opts)\n      end\n\n      def init(_opts) do\n        # We will keep all running tasks in a map\n        {:ok, %{tasks: %{}}}\n      end\n\n      # Imagine we invoke a task from the GenServer to access a URL...\n      def handle_call(:some_message, _from, state) do\n        url = ...\n        task = Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn -> fetch_url(url) end)\n\n        # After we start the task, we store its reference and the url it is fetching\n        state = put_in(state.tasks[task.ref], url)\n\n        {:reply, :ok, state}\n      end\n\n      # If the task succeeds...\n      def handle_info({ref, result}, state) do\n        # The task succeed so we can cancel the monitoring and discard the DOWN message\n        Process.demonitor(ref, [:flush])\n\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"Got #{inspect(result)} for URL #{inspect url}\"\n        {:noreply, state}\n      end\n\n      # If the task fails...\n      def handle_info({:DOWN, ref, _, _, reason}, state) do\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"URL #{inspect url} failed with reason #{inspect(reason)}\"\n        {:noreply, state}\n      end\n    end\n\nWith the server defined, you will want to start the task supervisor\nabove and the GenServer in your supervision tree:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor},\n      {GenServerTaskExample, name: MyApp.GenServerTaskExample}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.await_many(tasks, timeout \\\\ 5000) <response> Awaits replies from multiple tasks and returns them.\n\nThis function receives a list of tasks and waits for their replies in the\ngiven time interval. It returns a list of the results, in the same order as\nthe tasks supplied in the `tasks` input argument.\n\nIf any of the task processes dies, the caller process will exit with the same\nreason as that task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nAny task processes that are linked to the caller process (which is the case\nwhen a task is started with `async`) will also exit. Any task processes that\nare trapping exits or not linked to the caller process will continue to run.\n\nThis function assumes the tasks' monitors are still active or the monitor's\n`:DOWN` message is in the message queue. If any tasks have been demonitored,\nor the message already received, this function will wait for the duration of\nthe timeout.\n\nThis function can only be called once for any given task. If you want to be\nable to check multiple times if a long-running task has finished its\ncomputation, use `yield_many/2` instead.\n\n## Compatibility with OTP behaviours\n\nIt is not recommended to `await` long-running tasks inside an OTP behaviour\nsuch as `GenServer`. See `await/2` for more information.\n\n## Examples\n\n    iex> tasks = [\n    ...>   Task.async(fn -> 1 + 1 end),\n    ...>   Task.async(fn -> 2 + 3 end)\n    ...> ]\n    iex> Task.await_many(tasks)\n    [2, 5]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.child_spec(arg) <response> Returns a specification to start a task under a supervisor.\n\n`arg` is passed as the argument to `Task.start_link/1` in the `:start` field\nof the spec.\n\nFor more information, see the `Supervisor` module,\nthe `Supervisor.child_spec/2` function and the `t:Supervisor.child_spec/0` type."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.completed(result) <response> Starts a task that immediately completes with the given `result`.\n\nUnlike `async/1`, this task does not spawn a linked process. It can\nbe awaited or yielded like any other task.\n\n## Usage\n\nIn some cases, it is useful to create a \"completed\" task that represents\na task that has already run and generated a result. For example, when\nprocessing data you may be able to determine that certain inputs are\ninvalid before dispatching them for further processing:\n\n    def process(data) do\n      tasks =\n        for entry <- data do\n          if invalid_input?(entry) do\n            Task.completed({:error, :invalid_input})\n          else\n            Task.async(fn -> further_process(entry) end)\n          end\n        end\n\n      Task.await_many(tasks)\n    end\n\nIn many cases, `Task.completed/1` may be avoided in favor of returning the\nresult directly.  You should generally only require this variant when working\nwith mixed asynchrony, when a group of inputs will be handled partially\nsynchronously and partially asynchronously."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.ignore(task) <response> Ignores an existing task.\n\nThis means the task will continue running, but it will be unlinked\nand you can no longer yield, await or shut it down.\n\nReturns `{:ok, reply}` if the reply is received before ignoring the task,\n`{:exit, reason}` if the task died before ignoring it, otherwise `nil`.\n\nImportant: avoid using [`Task.async/1,3`](`async/1`) and then immediately ignoring\nthe task. If you want to start tasks you don't care about their\nresults, use `Task.Supervisor.start_child/2` instead.\n\nRequires Erlang/OTP 24+."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.shutdown(task, shutdown \\\\ 5000) <response> Unlinks and shuts down the task, and then checks for a reply.\n\nReturns `{:ok, reply}` if the reply is received while shutting down the task,\n`{:exit, reason}` if the task died, otherwise `nil`. Once shut down,\nyou can no longer await or yield it.\n\nThe second argument is either a timeout or `:brutal_kill`. In case\nof a timeout, a `:shutdown` exit signal is sent to the task process\nand if it does not exit within the timeout, it is killed. With `:brutal_kill`\nthe task is killed straight away. In case the task terminates abnormally\n(possibly killed by another process), this function will exit with the same reason.\n\nIt is not required to call this function when terminating the caller, unless\nexiting with reason `:normal` or if the task is trapping exits. If the caller is\nexiting with a reason other than `:normal` and the task is not trapping exits, the\ncaller's exit signal will stop the task. The caller can exit with reason\n`:shutdown` to shut down all of its linked processes, including tasks, that\nare not trapping exits without generating any log messages.\n\nIf a task's monitor has already been demonitored or received and there is not\na response waiting in the message queue this function will return\n`{:exit, :noproc}` as the result or exit reason can not be determined."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.start(fun) <response> Starts a task.\n\n`fun` must be a zero-arity anonymous function.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.start(module, function_name, args) <response> Starts a task.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.start_link(fun) <response> Starts a task as part of a supervision tree with the given `fun`.\n\n`fun` must be a zero-arity anonymous function.\n\nThis is used to start a statically supervised task under a supervision tree."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.start_link(module, function, args) <response> Starts a task as part of a supervision tree with the given\n`module`, `function`, and `args`.\n\nThis is used to start a statically supervised task under a supervision tree."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.yield(task, timeout \\\\ 5000) <response> Temporarily blocks the caller process waiting for a task reply.\n\nReturns `{:ok, reply}` if the reply is received, `nil` if\nno reply has arrived, or `{:exit, reason}` if the task has already\nexited. Keep in mind that normally a task failure also causes\nthe process owning the task to exit. Therefore this function can\nreturn `{:exit, reason}` if at least one of the conditions below apply:\n\n  * the task process exited with the reason `:normal`\n  * the task isn't linked to the caller (the task was started\n    with `Task.Supervisor.async_nolink/2` or `Task.Supervisor.async_nolink/4`)\n  * the caller is trapping exits\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the time runs out before a message from the task is received,\nthis function will return `nil` and the monitor will remain active. Therefore\n`yield/2` can be called multiple times on the same task.\n\nThis function assumes the task's monitor is still active or the\nmonitor's `:DOWN` message is in the message queue. If it has been\ndemonitored or the message already received, this function will wait\nfor the duration of the timeout awaiting the message.\n\nIf you intend to shut the task down if it has not responded within `timeout`\nmilliseconds, you should chain this together with `shutdown/1`, like so:\n\n    case Task.yield(task, timeout) || Task.shutdown(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warn(\"Failed to get a result in #{timeout}ms\")\n        nil\n    end\n\nIf you intend to check on the task but leave it running after the timeout,\nyou can chain this together with `ignore/1`, like so:\n\n    case Task.yield(task, timeout) || Task.ignore(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warn(\"Failed to get a result in #{timeout}ms\")\n        nil\n    end\n\nThat ensures that if the task completes after the `timeout` but before `shutdown/1`\nhas been called, you will still get the result, since `shutdown/1` is designed to\nhandle this case and return the result."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.yield_many(tasks, timeout \\\\ 5000) <response> Yields to multiple tasks in the given time interval.\n\nThis function receives a list of tasks and waits for their\nreplies in the given time interval. It returns a list\nof two-element tuples, with the task as the first element\nand the yielded result as the second. The tasks in the returned\nlist will be in the same order as the tasks supplied in the `tasks`\ninput argument.\n\nSimilarly to `yield/2`, each task's result will be\n\n  * `{:ok, term}` if the task has successfully reported its\n    result back in the given time interval\n  * `{:exit, reason}` if the task has died\n  * `nil` if the task keeps running past the timeout\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`.\n\nCheck `yield/2` for more information.\n\n## Example\n\n`Task.yield_many/2` allows developers to spawn multiple tasks\nand retrieve the results received in a given timeframe.\nIf we combine it with `Task.shutdown/2` (or `Task.ignore/1`),\nit allows us to gather those results and cancel (or ignore)\nthe tasks that have not replied in time.\n\nLet's see an example.\n\n    tasks =\n      for i <- 1..10 do\n        Task.async(fn ->\n          Process.sleep(i * 1000)\n          i\n        end)\n      end\n\n    tasks_with_results = Task.yield_many(tasks, 5000)\n\n    results =\n      Enum.map(tasks_with_results, fn {task, res} ->\n        # Shut down the tasks that did not reply nor exit\n        res || Task.shutdown(task, :brutal_kill)\n      end)\n\n    # Here we are matching only on {:ok, value} and\n    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n    for {:ok, value} <- results do\n      IO.inspect(value)\n    end\n\nIn the example above, we create tasks that sleep from 1\nup to 10 seconds and return the number of seconds they slept for.\nIf you execute the code all at once, you should see 1 up to 5\nprinted, as those were the tasks that have replied in the\ngiven time. All other tasks will have been shut down using\nthe `Task.shutdown/2` call."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> Conveniences for spawning and awaiting tasks.\n\nTasks are processes meant to execute one particular\naction throughout their lifetime, often with little or no\ncommunication with other processes. The most common use case\nfor tasks is to convert sequential code into concurrent code\nby computing a value asynchronously:\n\n    task = Task.async(fn -> do_some_work() end)\n    res = do_some_other_work()\n    res + Task.await(task)\n\nTasks spawned with `async` can be awaited on by their caller\nprocess (and only their caller) as shown in the example above.\nThey are implemented by spawning a process that sends a message\nto the caller once the given computation is performed.\n\nBesides `async/1` and `await/2`, tasks can also be\nstarted as part of a supervision tree and dynamically spawned\non remote nodes. We will explore these scenarios next."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> async and await\n\nOne of the common uses of tasks is to convert sequential code\ninto concurrent code with `Task.async/1` while keeping its semantics.\nWhen invoked, a new process will be created, linked and monitored\nby the caller. Once the task action finishes, a message will be sent\nto the caller with the result.\n\n`Task.await/2` is used to read the message sent by the task.\n\nThere are two important things to consider when using `async`:\n\n  1. If you are using async tasks, you **must await** a reply\n     as they are *always* sent. If you are not expecting a reply,\n     consider using `Task.start_link/1` as detailed below.\n\n  2. async tasks link the caller and the spawned process. This\n     means that, if the caller crashes, the task will crash\n     too and vice-versa. This is on purpose: if the process\n     meant to receive the result no longer exists, there is\n     no purpose in completing the computation.\n\n     If this is not desired, you will want to use supervised\n     tasks, described next."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> Dynamically supervised tasks\n\nThe `Task.Supervisor` module allows developers to dynamically\ncreate multiple supervised tasks.\n\nA short example is:\n\n    {:ok, pid} = Task.Supervisor.start_link()\n\n    task =\n      Task.Supervisor.async(pid, fn ->\n        # Do something\n      end)\n\n    Task.await(task)\n\nHowever, in the majority of cases, you want to add the task supervisor\nto your supervision tree:\n\n    Supervisor.start_link([\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ], strategy: :one_for_one)\n\nAnd now you can use async/await by passing the name of\nthe supervisor instead of the pid:\n\n    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n      # Do something\n    end)\n    |> Task.await()\n\nWe encourage developers to rely on supervised tasks as much as possible.\nSupervised tasks improves the visibility of how many tasks are running\nat a given moment and enable a huge variety of patterns that gives you\nexplicit control on how to handle the results, errors, and timeouts.\nHere is a summary:\n\n  * Using `Task.Supervisor.start_child/2` allows you to start a fire-and-forget\n    task that you don't care about its results or if it completes successfully or not.\n\n  * Using `Task.Supervisor.async/2` + `Task.await/2` allows you to execute\n    tasks concurrently and retrieve its result. If the task fails,\n    the caller will also fail.\n\n  * Using `Task.Supervisor.async_nolink/2` + `Task.yield/2` + `Task.shutdown/2`\n    allows you to execute tasks concurrently and retrieve their results\n    or the reason they failed within a given time frame. If the task fails,\n    the caller won't fail. You will receive the error reason either on\n    `yield` or `shutdown`.\n\nFurthermore, the supervisor guarantee all tasks first terminate, within a\nconfigurable shutdown period, when your application shuts down. See the\n`Task.Supervisor` module for details on the supported operations."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> # Distributed tasks\n\nWith `Task.Supervisor`, it is easy to dynamically start tasks across nodes:\n\n    # On the remote node named :remote@local\n    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n\n    # On the client\n    supervisor = {MyApp.DistSupervisor, :remote@local}\n    Task.Supervisor.async(supervisor, MyMod, :my_fun, [arg1, arg2, arg3])\n\nNote that, when working with distributed tasks, one should use the\n`Task.Supervisor.async/5` function that expects explicit module, function,\nand arguments, instead of `Task.Supervisor.async/3` that works with anonymous\nfunctions. That's because anonymous functions expect the same module version\nto exist on all involved nodes. Check the `Agent` module documentation for\nmore information on distributed processes as the limitations described there\napply to the whole ecosystem."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> Statically supervised tasks\n\nThe `Task` module implements the `child_spec/1` function, which\nallows it to be started directly under a regular `Supervisor` -\ninstead of a `Task.Supervisor` - by passing a tuple with a function\nto run:\n\n    Supervisor.start_link([\n      {Task, fn -> :some_work end}\n    ], strategy: :one_for_one)\n\nThis is often useful when you need to execute some steps while\nsetting up your supervision tree. For example: to warm up caches,\nlog the initialization status, and such.\n\nIf you don't want to put the Task code directly under the `Supervisor`,\nyou can wrap the `Task` in its own module, similar to how you would\ndo with a `GenServer` or an `Agent`:\n\n    defmodule MyTask do\n      use Task\n\n      def start_link(arg) do\n        Task.start_link(__MODULE__, :run, [arg])\n      end\n\n      def run(arg) do\n        # ...\n      end\n    end\n\nAnd then passing it to the supervisor:\n\n    Supervisor.start_link([\n      {MyTask, arg}\n    ], strategy: :one_for_one)\n\nSince these tasks are supervised and not directly linked to the caller,\nthey cannot be awaited on. By default, the functions `Task.start/1`\nand `Task.start_link/1` are for fire-and-forget tasks, where you don't\ncare about the results or if it completes successfully or not.\n\n`use Task` defines a `child_spec/1` function, allowing the\ndefined module to be put under a supervision tree. The generated\n`child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:temporary`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nOpposite to `GenServer`, `Agent` and `Supervisor`, a Task has\na default `:restart` of `:temporary`. This means the task will\nnot be restarted even if it crashes. If you desire the task to\nbe restarted for non-successful exits, do:\n\n    use Task, restart: :transient\n\nIf you want the task to always be restarted:\n\n    use Task, restart: :permanent\n\nSee the \"Child specification\" section in the `Supervisor` module\nfor more detailed information. The `@doc` annotation immediately\npreceding `use Task` will be attached to the generated `child_spec/1`\nfunction."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Task.Elixir.Task <response> Ancestor and Caller Tracking\n\nWhenever you start a new process, Elixir annotates the parent of that process\nthrough the `$ancestors` key in the process dictionary. This is often used to\ntrack the hierarchy inside a supervision tree.\n\nFor example, we recommend developers to always start tasks under a supervisor.\nThis provides more visibility and allows you to control how those tasks are\nterminated when a node shuts down. That might look something like\n`Task.Supervisor.start_child(MySupervisor, task_function)`. This means\nthat, although your code is the one invoking the task, the actual ancestor of\nthe task is the supervisor, as the supervisor is the one effectively starting it.\n\nTo track the relationship between your code and the task, we use the `$callers`\nkey in the process dictionary. Therefore, assuming the `Task.Supervisor` call\nabove, we have:\n\n    [your code] -- calls --> [supervisor] ---- spawns --> [task]\n\nWhich means we store the following relationships:\n\n    [your code]              [supervisor] <-- ancestor -- [task]\n        ^                                                  |\n        |--------------------- caller ---------------------|\n\nThe list of callers of the current process can be retrieved from the Process\ndictionary with `Process.get(:\"$callers\")`. This will return either `nil` or\na list `[pid_n, ..., pid2, pid1]` with at least one entry Where `pid_n` is\nthe PID that called the current process, `pid2` called `pid_n`, and `pid2` was\ncalled by `pid1`.\n\nIf a task crashes, the callers field is included as part of the log message\nmetadata under the `:callers` key."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.add(time, amount_to_add, unit \\\\ :second) <response> Adds the `amount_to_add` of `unit`s to the given `time`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\nNote the result value represents the time of day, meaning that it is cyclic,\nfor instance, it will never go over 24 hours for the ISO calendar.\n\n## Examples\n\n    iex> Time.add(~T[10:00:00], 27000)\n    ~T[17:30:00]\n    iex> Time.add(~T[11:00:00.005], 2400)\n    ~T[11:40:00.005]\n    iex> Time.add(~T[00:00:00.000], 86_399_999, :millisecond)\n    ~T[23:59:59.999]\n\nNegative values are allowed:\n\n    iex> Time.add(~T[23:00:00], -60)\n    ~T[22:59:00]\n\nNote that the time is cyclic:\n\n    iex> Time.add(~T[17:10:05], 86400)\n    ~T[17:10:05]\n\nHours and minutes are also supported:\n\n    iex> Time.add(~T[17:10:05], 2, :hour)\n    ~T[19:10:05]\n    iex> Time.add(~T[17:10:05], 30, :minute)\n    ~T[17:40:05]\n\nThis operation merges the precision of the time with the given unit:\n\n    iex> result = Time.add(~T[00:29:10], 21, :millisecond)\n    ~T[00:29:10.021]\n    iex> result.microsecond\n    {21000, 3}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.compare(time1, time2) <response> Compares two time structs.\n\nReturns `:gt` if first time is later than the second\nand `:lt` for vice versa. If the two times are equal\n`:eq` is returned.\n\n## Examples\n\n    iex> Time.compare(~T[16:04:16], ~T[16:04:28])\n    :lt\n    iex> Time.compare(~T[16:04:16], ~T[16:04:16])\n    :eq\n    iex> Time.compare(~T[16:04:16.01], ~T[16:04:16.001])\n    :gt\n\nThis function can also be used to compare across more\ncomplex calendar types by considering only the time fields:\n\n    iex> Time.compare(~N[1900-01-01 16:04:16], ~N[2015-01-01 16:04:16])\n    :eq\n    iex> Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])\n    :lt\n    iex> Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 16:04:16.001])\n    :gt"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.convert(time, calendar) <response> Converts given `time` to a different calendar.\n\nReturns `{:ok, time}` if the conversion was successful,\nor `{:error, reason}` if it was not, for some reason.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert(~T[13:30:15], Calendar.Holocene)\n    {:ok, %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.convert!(time, calendar) <response> Similar to `Time.convert/2`, but raises an `ArgumentError`\nif the conversion between the two calendars is not possible.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert!(~T[13:30:15], Calendar.Holocene)\n    %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.diff(time1, time2, unit \\\\ :second) <response> Returns the difference between two times, considering only the hour, minute,\nsecond and microsecond.\n\nAs with the `compare/2` function both `Time` structs and other structures\ncontaining time can be used. If for instance a `NaiveDateTime` or `DateTime`\nis passed, only the hour, minute, second, and microsecond is considered. Any\nadditional information about a date or time zone is ignored when calculating\nthe difference.\n\nThe answer can be returned in any `:hour`, `:minute`, `:second` or any\nsubsecond `unit` available from `t:System.time_unit/0`. If the first time\nvalue is earlier than the second, a negative number is returned.\n\nThe unit is measured according to `Calendar.ISO` and defaults to `:second`.\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> Time.diff(~T[00:29:12], ~T[00:29:10])\n    2\n\n    # When passing a `NaiveDateTime` the date part is ignored.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~T[00:29:10])\n    2\n\n    # Two `NaiveDateTime` structs could have big differences in the date\n    # but only the time part is considered.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~N[1900-02-03 00:29:10])\n    2\n\n    iex> Time.diff(~T[00:29:12], ~T[00:29:10], :microsecond)\n    2_000_000\n    iex> Time.diff(~T[00:29:10], ~T[00:29:12], :microsecond)\n    -2_000_000\n\n    iex> Time.diff(~T[02:29:10], ~T[00:29:10], :hour)\n    2\n    iex> Time.diff(~T[02:29:10], ~T[00:29:11], :hour)\n    1"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.from_erl(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Converts an Erlang time tuple to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_erl({23, 30, 15}, {5000, 3})\n    {:ok, ~T[23:30:15.005]}\n    iex> Time.from_erl({24, 30, 15})\n    {:error, :invalid_time}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.from_erl!(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Converts an Erlang time tuple to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_erl!({23, 30, 15})\n    ~T[23:30:15]\n    iex> Time.from_erl!({23, 30, 15}, {5000, 3})\n    ~T[23:30:15.005]\n    iex> Time.from_erl!({24, 30, 15})\n    ** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.from_iso8601(string, calendar \\\\ Calendar.ISO) <response> Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nTime zone offset may be included in the string but they will be\nsimply discarded as such information is not included in times.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\n## Examples\n\n    iex> Time.from_iso8601(\"23:50:07\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"T23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n\n    iex> Time.from_iso8601(\"23:50:07,0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.123Z\")\n    {:ok, ~T[23:50:07.123]}\n\n    iex> Time.from_iso8601(\"2015:01:23 23-50-07\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07A\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07.\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:61\")\n    {:error, :invalid_time}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.from_iso8601!(string, calendar \\\\ Calendar.ISO) <response> Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> Time.from_iso8601!(\"23:50:07,123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"23:50:07.123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"2015:01:23 23-50-07\")\n    ** (ArgumentError) cannot parse \"2015:01:23 23-50-07\" as time, reason: :invalid_format"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.from_seconds_after_midnight(seconds, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Converts a number of seconds after midnight to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_seconds_after_midnight(10_000)\n    ~T[02:46:40]\n    iex> Time.from_seconds_after_midnight(30_000, {5000, 3})\n    ~T[08:20:00.005]\n    iex> Time.from_seconds_after_midnight(-1)\n    ~T[23:59:59]\n    iex> Time.from_seconds_after_midnight(100_000)\n    ~T[03:46:40]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.new(hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Builds a new time.\n\nExpects all values to be integers. Returns `{:ok, time}` if each\nentry fits its appropriate range, returns `{:error, reason}` otherwise.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.\n\n## Examples\n\n    iex> Time.new(0, 0, 0, 0)\n    {:ok, ~T[00:00:00.000000]}\n    iex> Time.new(23, 59, 59, 999_999)\n    {:ok, ~T[23:59:59.999999]}\n\n    iex> Time.new(24, 59, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 60, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 60, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 59, 1_000_000)\n    {:error, :invalid_time}\n\n    # Invalid precision\n    Time.new(23, 59, 59, {999_999, 10})\n    {:error, :invalid_time}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.new!(hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO) <response> Builds a new time.\n\nExpects all values to be integers. Returns `time` if each\nentry fits its appropriate range, raises if the time is invalid.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.\n\n## Examples\n\n    iex> Time.new!(0, 0, 0, 0)\n    ~T[00:00:00.000000]\n    iex> Time.new!(23, 59, 59, 999_999)\n    ~T[23:59:59.999999]\n    iex> Time.new!(24, 59, 59, 999_999)\n    ** (ArgumentError) cannot build time, reason: :invalid_time"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.to_erl(time) <response> Converts given `time` to an Erlang time tuple.\n\nWARNING: Loss of precision may occur, as Erlang time tuples\nonly contain hours/minutes/seconds.\n\n## Examples\n\n    iex> Time.to_erl(~T[23:30:15.999])\n    {23, 30, 15}\n\n    iex> Time.to_erl(~N[2010-04-17 23:30:15.999])\n    {23, 30, 15}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.to_iso8601(time, format \\\\ :extended) <response> Converts the given time to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `Time.to_iso8601/2` returns times formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through\npassing the `:basic` option.\n\n### Examples\n\n    iex> Time.to_iso8601(~T[23:00:13])\n    \"23:00:13\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001])\n    \"23:00:13.001\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001], :basic)\n    \"230013.001\"\n\n    iex> Time.to_iso8601(~N[2010-04-17 23:00:13])\n    \"23:00:13\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.to_seconds_after_midnight(time) <response> Converts a `Time` struct to a number of seconds after midnight.\n\nThe returned value is a two-element tuple with the number of seconds and microseconds.\n\n## Examples\n\n    iex> Time.to_seconds_after_midnight(~T[23:30:15])\n    {84615, 0}\n    iex> Time.to_seconds_after_midnight(~N[2010-04-17 23:30:15.999])\n    {84615, 999000}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.to_string(time) <response> Converts the given `time` to a string.\n\n### Examples\n\n    iex> Time.to_string(~T[23:00:00])\n    \"23:00:00\"\n    iex> Time.to_string(~T[23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~T[23:00:00.123456])\n    \"23:00:00.123456\"\n\n    iex> Time.to_string(~N[2015-01-01 23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~N[2015-01-01 23:00:00.123456])\n    \"23:00:00.123456\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.truncate(time, precision) <response> Returns the given time with the microsecond field truncated to the given\nprecision (`:microsecond`, `millisecond` or `:second`).\n\nThe given time is returned unchanged if it already has lower precision than\nthe given precision.\n\n## Examples\n\n    iex> Time.truncate(~T[01:01:01.123456], :microsecond)\n    ~T[01:01:01.123456]\n\n    iex> Time.truncate(~T[01:01:01.123456], :millisecond)\n    ~T[01:01:01.123]\n\n    iex> Time.truncate(~T[01:01:01.123456], :second)\n    ~T[01:01:01]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.utc_now(calendar \\\\ Calendar.ISO) <response> Returns the current time in UTC.\n\n## Examples\n\n    iex> time = Time.utc_now()\n    iex> time.hour >= 0\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.Elixir.Time <response> A Time struct and functions.\n\nThe Time struct contains the fields hour, minute, second and microseconds.\nNew times can be built with the `new/4` function or using the\n`~T` (see `sigil_T/2`) sigil:\n\n    iex> ~T[23:00:07.001]\n    ~T[23:00:07.001]\n\nBoth `new/4` and sigil return a struct where the time fields can\nbe accessed directly:\n\n    iex> time = ~T[23:00:07.001]\n    iex> time.hour\n    23\n    iex> time.microsecond\n    {1000, 3}\n\nThe functions on this module work with the `Time` struct as well\nas any struct that contains the same fields as the `Time` struct,\nsuch as `NaiveDateTime` and `DateTime`. Such functions expect\n`t:Calendar.time/0` in their typespecs (instead of `t:t/0`).\n\nDevelopers should avoid creating the Time structs directly\nand instead rely on the functions provided by this module as well\nas the ones in third-party calendar libraries."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Time.Elixir.Time <response> Comparing times\n\nComparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `Time` struct fields. For proper comparison between\ntimes, use the `compare/2` function. The existence of the `compare/2`\nfunction in this module also allows using `Enum.min/2` and `Enum.max/2`\nfunctions to get the minimum and maximum time of an `Enum`. For example:\n\n    iex> Enum.min([~T[23:00:07.001], ~T[10:00:07.001]], Time)\n    ~T[10:00:07.001]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.append(tuple, value) <response> Inserts an element at the end of a tuple.\n\nReturns a new tuple with the element appended at the end, and contains\nthe elements in `tuple` followed by `value` as the last element.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar}\n    iex> Tuple.append(tuple, :baz)\n    {:foo, :bar, :baz}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.delete_at(tuple, index) <response> Removes an element from a tuple.\n\nDeletes the element at the given `index` from `tuple`.\nRaises an `ArgumentError` if `index` is negative or greater than\nor equal to the length of `tuple`. Index is zero-based.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.delete_at(tuple, 0)\n    {:bar, :baz}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.duplicate(data, size) <response> Creates a new tuple.\n\nCreates a tuple of `size` containing the\ngiven `data` at every position.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Tuple.duplicate(:hello, 3)\n    {:hello, :hello, :hello}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.insert_at(tuple, index, value) <response> Inserts an element into a tuple.\n\nInserts `value` into `tuple` at the given `index`.\nRaises an `ArgumentError` if `index` is negative or greater than the\nlength of `tuple`. Index is zero-based.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:bar, :baz}\n    iex> Tuple.insert_at(tuple, 0, :foo)\n    {:foo, :bar, :baz}\n    iex> Tuple.insert_at(tuple, 2, :bong)\n    {:bar, :baz, :bong}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.product(tuple) <response> Computes a product of tuple elements.\n\n## Examples\n\n    iex> Tuple.product({255, 255})\n    65025\n    iex> Tuple.product({255, 1.0})\n    255.0\n    iex> Tuple.product({})\n    1"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.sum(tuple) <response> Computes a sum of tuple elements.\n\n## Examples\n\n    iex> Tuple.sum({255, 255})\n    510\n    iex> Tuple.sum({255, 0.0})\n    255.0\n    iex> Tuple.sum({})\n    0"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.to_list(tuple) <response> Converts a tuple to a list.\n\nReturns a new list with all the tuple elements.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.to_list(tuple)\n    [:foo, :bar, :baz]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Tuple.Elixir.Tuple <response> Functions for working with tuples.\n\nPlease note the following functions for tuples are found in `Kernel`:\n\n  * `elem/2` - accesses a tuple by index\n  * `put_elem/3` - inserts a value into a tuple by index\n  * `tuple_size/1` - gets the number of elements in a tuple\n\nTuples are intended as fixed-size containers for multiple elements.\nTo manipulate a collection of elements, use a list instead. `Enum`\nfunctions do not work on tuples.\n\nTuples are denoted with curly braces:\n\n    iex> {}\n    {}\n    iex> {1, :two, \"three\"}\n    {1, :two, \"three\"}\n\nA tuple may contain elements of different types, which are stored\ncontiguously in memory. Accessing any element takes constant time,\nbut modifying a tuple, which produces a shallow copy, takes linear time.\nTuples are good for reading data while lists are better for traversals.\n\nTuples are typically used either when a function has multiple return values\nor for error handling. `File.read/1` returns `{:ok, contents}` if reading\nthe given file is successful, or else `{:error, reason}` such as when\nthe file does not exist.\n\nThe functions in this module that add and remove elements from tuples are\nrarely used in practice, as they typically imply tuples are being used as\ncollections. To append to a tuple, it is preferable to extract the elements\nfrom the old tuple with pattern matching, and then create a new tuple:\n\n    tuple = {:ok, :example}\n\n    # Avoid\n    result = Tuple.insert_at(tuple, 2, %{})\n\n    # Prefer\n    {:ok, atom} = tuple\n    result = {:ok, atom, %{}}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.%URI{} <response> The URI struct.\n\nThe fields are defined to match the following URI representation\n(with field names between brackets):\n\n    [scheme]://[userinfo]@[host]:[port][path]?[query]#[fragment]\n\n\nNote the `authority` field is deprecated. `parse/1` will still\npopulate it for backwards compatibility but you should generally\navoid setting or getting it."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.append_query(uri, query) <response> Appends `query` to the given `uri`.\n\nThe given `query` is not automatically encoded, use `encode/2` or `encode_www_form/1`.\n\n## Examples\n\n    iex> URI.append_query(URI.parse(\"http://example.com/\"), \"x=1\") |> URI.to_string()\n    \"http://example.com/?x=1\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"y=2\") |> URI.to_string()\n    \"http://example.com/?x=1&y=2\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"x=2\") |> URI.to_string()\n    \"http://example.com/?x=1&x=2\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.char_reserved?(character) <response> Checks if `character` is a reserved one in a URI.\n\nAs specified in [RFC 3986, section 2.2](https://tools.ietf.org/html/rfc3986#section-2.2),\nthe following characters are reserved: `:`, `/`, `?`, `#`, `[`, `]`, `@`, `!`, `$`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `;`, `=`\n\n## Examples\n\n    iex> URI.char_reserved?(?+)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.char_unescaped?(character) <response> Checks if `character` is allowed unescaped in a URI.\n\nThis is the default used by `URI.encode/2` where both\n[reserved](`char_reserved?/1`) and [unreserved characters](`char_unreserved?/1`)\nare kept unescaped.\n\n## Examples\n\n    iex> URI.char_unescaped?(?{)\n    false"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.char_unreserved?(character) <response> Checks if `character` is an unreserved one in a URI.\n\nAs specified in [RFC 3986, section 2.3](https://tools.ietf.org/html/rfc3986#section-2.3),\nthe following characters are unreserved:\n\n  * Alphanumeric characters: `A-Z`, `a-z`, `0-9`\n  * `~`, `_`, `-`, `.`\n\n## Examples\n\n    iex> URI.char_unreserved?(?_)\n    true"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.decode(uri) <response> Percent-unescapes a URI.\n\n## Examples\n\n    iex> URI.decode(\"https%3A%2F%2Felixir-lang.org\")\n    \"https://elixir-lang.org\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.decode_query(query, map \\\\ %{}, encoding \\\\ :www_form) <response> Decodes `query` into a map.\n\nGiven a query string in the form of `key1=value1&key2=value2...`, this\nfunction inserts each key-value pair in the query string as one entry in the\ngiven `map`. Keys and values in the resulting map will be binaries. Keys and\nvalues will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.\n\nUse `query_decoder/1` if you want to iterate over each value manually.\n\n## Examples\n\n    iex> URI.decode_query(\"foo=1&bar=2\")\n    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{\"starting\" => \"map\"})\n    %{\"percent\" => \"oh yes!\", \"starting\" => \"map\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{}, :rfc3986)\n    %{\"percent\" => \"oh+yes!\"}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.decode_www_form(string) <response> Decodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.\n\n## Examples\n\n    iex> URI.decode_www_form(\"%3Call+in%2F\")\n    \"<all in/\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.default_port(scheme) <response> Returns the default port for a given `scheme`.\n\nIf the scheme is unknown to the `URI` module, this function returns\n`nil`. The default port for any scheme can be configured globally\nvia `default_port/2`.\n\n## Examples\n\n    iex> URI.default_port(\"ftp\")\n    21\n\n    iex> URI.default_port(\"ponzi\")\n    nil"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.default_port(scheme, port) <response> Registers the default `port` for the given `scheme`.\n\nAfter this function is called, `port` will be returned by\n`default_port/1` for the given scheme `scheme`. Note that this function\nchanges the default port for the given `scheme` *globally*, meaning for\nevery application.\n\nIt is recommended for this function to be invoked in your\napplication's start callback in case you want to register\nnew URIs."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.encode(string, predicate \\\\ &char_unescaped?/1) <response> Percent-escapes all characters that require escaping in `string`.\n\nThis means reserved characters, such as `:` and `/`, and the\nso-called unreserved characters, which have the same meaning both\nescaped and unescaped, won't be escaped by default.\n\nSee `encode_www_form/1` if you are interested in escaping reserved\ncharacters too.\n\nThis function also accepts a `predicate` function as an optional\nargument. If passed, this function will be called with each byte\nin `string` as its argument and should return a truthy value (anything other\nthan `false` or `nil`) if the given byte should be left as is, or return a\nfalsy value (`false` or `nil`) if the character should be escaped. Defaults\nto `URI.char_unescaped?/1`.\n\n## Examples\n\n    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+Ð¹\")\n    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n\n    iex> URI.encode(\"a string\", &(&1 != ?i))\n    \"a str%69ng\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.encode_query(enumerable, encoding \\\\ :www_form) <response> Encodes `enumerable` into a query string using `encoding`.\n\nTakes an enumerable that enumerates as a list of two-element\ntuples (for instance, a map or a keyword list) and returns a string\nin the form of `key1=value1&key2=value2...`.\n\nKeys and values can be any term that implements the `String.Chars`\nprotocol with the exception of lists, which are explicitly forbidden.\n\nYou can specify one of the following `encoding` strategies:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are URL encoded as\n    per `encode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It encodes \" \" as \"+\".\n\n  * `:rfc3986` - (since v1.12.0) the same as `:www_form` except it encodes\n    \" \" as \"%20\" according [RFC 3986](https://tools.ietf.org/html/rfc3986).\n    This is the best option if you are encoding in a non-browser situation,\n    since encoding spaces as \"+\" can be ambiguous to URI parsers. This can\n    inadvertently lead to spaces being interpreted as literal plus signs.\n\nEncoding defaults to `:www_form` for backward compatibility.\n\n## Examples\n\n    iex> query = %{\"foo\" => 1, \"bar\" => 2}\n    iex> URI.encode_query(query)\n    \"bar=2&foo=1\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query)\n    \"key=value+with+spaces\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query, :rfc3986)\n    \"key=value%20with%20spaces\"\n\n    iex> URI.encode_query(%{key: [:a, :list]})\n    ** (ArgumentError) encode_query/2 values cannot be lists, got: [:a, :list]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.encode_www_form(string) <response> Encodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.\n\n## Example\n\n    iex> URI.encode_www_form(\"put: it+Ð¹\")\n    \"put%3A+it%2B%D0%B9\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.merge(uri, rel) <response> Merges two URIs.\n\nThis function merges two URIs as per\n[RFC 3986, section 5.2](https://tools.ietf.org/html/rfc3986#section-5.2).\n\n## Examples\n\n    iex> URI.merge(URI.parse(\"http://google.com\"), \"/query\") |> to_string()\n    \"http://google.com/query\"\n\n    iex> URI.merge(\"http://example.com\", \"http://google.com\") |> to_string()\n    \"http://google.com\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.new(uri) <response> Creates a new URI struct from a URI or a string.\n\nIf a `%URI{}` struct is given, it returns `{:ok, uri}`. If a string is\ngiven, it will parse and validate it. If the string is valid, it returns\n`{:ok, uri}`, otherwise it returns `{:error, part}` with the invalid part\nof the URI. For parsing URIs without further validation, see `parse/1`.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\n`nil` or not.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.\n\n## Examples\n\n    iex> URI.new(\"https://elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//[fe80::]/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"fe80::\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"https:?query\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: nil,\n      port: 443,\n      query: \"query\",\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/invalid_greater_than_in_path/>\")\n    {:error, \">\"}\n\nGiving an existing URI simply returns it wrapped in a tuple:\n\n    iex> {:ok, uri} = URI.new(\"https://elixir-lang.org/\")\n    iex> URI.new(uri)\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.new!(uri) <response> Similar to `new/1` but raises `URI.Error` if an invalid string is given.\n\n## Examples\n\n    iex> URI.new!(\"https://elixir-lang.org/\")\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.new!(\"/invalid_greater_than_in_path/>\")\n    ** (URI.Error) cannot parse due to reason invalid_uri: \">\"\n\nGiving an existing URI simply returns it:\n\n    iex> uri = URI.new!(\"https://elixir-lang.org/\")\n    iex> URI.new!(uri)\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.parse(uri) <response> Parses a URI into its components, without further validation.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\nnil or not. Furthermore, this function expects both absolute and\nrelative URIs to be well-formed and does not perform any validation.\nSee the \"Examples\" section below. Use `new/1` if you want to validate\nthe URI fields after parsing.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.\n\nIf a `%URI{}` struct is given to this function, this function returns it\nunmodified.\n\n> Note: this function sets the field :authority for backwards\n> compatibility reasons but it is deprecated.\n\n## Examples\n\n    iex> URI.parse(\"https://elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"//elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"/foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nIn contrast to `URI.new/1`, this function will parse poorly-formed\nURIs, for example:\n\n    iex> URI.parse(\"/invalid_greater_than_in_path/>\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/invalid_greater_than_in_path/>\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nAnother example is a URI with brackets in query strings. It is accepted\nby `parse/1`, it is commonly accepted by browsers, but it will be refused\nby `new/1`:\n\n    iex> URI.parse(\"/?foo[bar]=baz\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/\",\n      port: nil,\n      query: \"foo[bar]=baz\",\n      scheme: nil,\n      userinfo: nil\n    }"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.query_decoder(query, encoding \\\\ :www_form) <response> Returns a stream of two-element tuples representing key-value pairs in the\ngiven `query`.\n\nKey and value in each tuple will be binaries and will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.\n\n## Examples\n\n    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.to_list()\n    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\") |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water please\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\", :rfc3986) |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water+please\"}]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.to_string(uri) <response> Returns the string representation of the given [URI struct](`t:t/0`).\n\n## Examples\n\n    iex> uri = URI.parse(\"http://google.com\")\n    iex> URI.to_string(uri)\n    \"http://google.com\"\n\n    iex> uri = URI.parse(\"foo://bar.baz\")\n    iex> URI.to_string(uri)\n    \"foo://bar.baz\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.URI.Elixir.URI <response> Utilities for working with URIs.\n\nThis module provides functions for working with URIs (for example, parsing\nURIs or encoding query strings). The functions in this module are implemented\naccording to [RFC 3986](https://tools.ietf.org/html/rfc3986)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.Requirement.Elixir.Version.Requirement <response> A struct that holds version requirement information.\n\nThe struct fields are private and should not be accessed.\n\nSee the \"Requirements\" section in the `Version` module\nfor more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.%Version{} <response> The Version struct.\n\nIt contains the fields `:major`, `:minor`, `:patch`, `:pre`, and\n`:build` according to SemVer 2.0, where `:pre` is a list.\n\nYou can read those fields but you should not create a new `Version`\ndirectly via the struct syntax. Instead use the functions in this\nmodule."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.compare(version1, version2) <response> Compares two versions.\n\nReturns `:gt` if the first version is greater than the second one, and `:lt`\nfor vice versa. If the two versions are equal, `:eq` is returned.\n\nPre-releases are strictly less than their corresponding release versions.\n\nPatch segments are compared lexicographically if they are alphanumeric, and\nnumerically otherwise.\n\nBuild segments are ignored: if two versions differ only in their build segment\nthey are considered to be equal.\n\nRaises a `Version.InvalidVersionError` exception if any of the two given\nversions are not parsable. If given an already parsed version this function\nwon't raise.\n\n## Examples\n\n    iex> Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n    :gt\n\n    iex> Version.compare(\"1.0.0-beta\", \"1.0.0-rc1\")\n    :lt\n\n    iex> Version.compare(\"1.0.0-10\", \"1.0.0-2\")\n    :gt\n\n    iex> Version.compare(\"2.0.1+build0\", \"2.0.1\")\n    :eq\n\n    iex> Version.compare(\"invalid\", \"2.0.1\")\n    ** (Version.InvalidVersionError) invalid version: \"invalid\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.compile_requirement(requirement) <response> Compiles a requirement to an internal representation that may optimize matching.\n\nThe internal representation is opaque."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.match?(version, requirement, opts \\\\ []) <response> Checks if the given version matches the specification.\n\nReturns `true` if `version` satisfies `requirement`, `false` otherwise.\nRaises a `Version.InvalidRequirementError` exception if `requirement` is not\nparsable, or a `Version.InvalidVersionError` exception if `version` is not parsable.\nIf given an already parsed version and requirement this function won't\nraise.\n\n## Options\n\n  * `:allow_pre` (boolean) - when `false`, pre-release versions will not match\n    unless the operand is a pre-release version. Defaults to `true`.\n    For examples, please refer to the table above under the \"Requirements\" section.\n\n## Examples\n\n    iex> Version.match?(\"2.0.0\", \"> 1.0.0\")\n    true\n\n    iex> Version.match?(\"2.0.0\", \"== 1.0.0\")\n    false\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\")\n    true\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\", allow_pre: false)\n    false\n\n    iex> Version.match?(\"foo\", \"== 1.0.0\")\n    ** (Version.InvalidVersionError) invalid version: \"foo\"\n\n    iex> Version.match?(\"2.0.0\", \"== == 1.0.0\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 1.0.0\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.parse(string) <response> Parses a version string into a `Version` struct.\n\n## Examples\n\n    iex> Version.parse(\"2.0.1-alpha1\")\n    {:ok, %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}}\n\n    iex> Version.parse(\"2.0-alpha1\")\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.parse!(string) <response> Parses a version string into a `Version`.\n\nIf `string` is an invalid version, a `Version.InvalidVersionError` is raised.\n\n## Examples\n\n    iex> Version.parse!(\"2.0.1-alpha1\")\n    %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}\n\n    iex> Version.parse!(\"2.0-alpha1\")\n    ** (Version.InvalidVersionError) invalid version: \"2.0-alpha1\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.parse_requirement(string) <response> Parses a version requirement string into a `Version.Requirement` struct.\n\n## Examples\n\n    iex> {:ok, requirement} = Version.parse_requirement(\"== 2.0.1\")\n    iex> requirement\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement(\"== == 2.0.1\")\n    :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.parse_requirement!(string) <response> Parses a version requirement string into a `Version.Requirement` struct.\n\nIf `string` is an invalid requirement, a `Version.InvalidRequirementError` is raised.\n\n# Examples\n\n    iex> Version.parse_requirement!(\"== 2.0.1\")\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement!(\"== == 2.0.1\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 2.0.1\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.to_string(version) <response> Converts the given version to a string.\n\n### Examples\n\n    iex> Version.to_string(%Version{major: 1, minor: 2, patch: 3})\n    \"1.2.3\"\n    iex> Version.to_string(Version.parse!(\"1.14.0-rc.0+build0\"))\n    \"1.14.0-rc.0+build0\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.Elixir.Version <response> Functions for parsing and matching versions against requirements.\n\nA version is a string in a specific format or a `Version`\ngenerated after parsing via `Version.parse/1`.\n\nAlthough Elixir projects are not required to follow SemVer,\nthey must follow the format outlined on [SemVer 2.0 schema](https://semver.org/)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.Elixir.Version <response> Versions\n\nIn a nutshell, a version is represented by three numbers:\n\n    MAJOR.MINOR.PATCH\n\nPre-releases are supported by optionally appending a hyphen and a series of\nperiod-separated identifiers immediately following the patch version.\nIdentifiers consist of only ASCII alphanumeric characters and hyphens (`[0-9A-Za-z-]`):\n\n    \"1.0.0-alpha.3\"\n\nBuild information can be added by appending a plus sign and a series of\ndot-separated identifiers immediately following the patch or pre-release version.\nIdentifiers consist of only ASCII alphanumeric characters and hyphens (`[0-9A-Za-z-]`):\n\n    \"1.0.0-alpha.3+20130417140000.amd64\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Version.Elixir.Version <response> Requirements\n\nRequirements allow you to specify which versions of a given\ndependency you are willing to work against. Requirements support the common\ncomparison operators such as `>`, `>=`, `<`, `<=`, and `==` that work as one\nwould expect, and additionally the special operator `~>` described in detail\nfurther below.\n\n    # Only version 2.0.0\n    \"== 2.0.0\"\n\n    # Anything later than 2.0.0\n    \"> 2.0.0\"\n\nRequirements also support `and` and `or` for complex conditions:\n\n    # 2.0.0 and later until 2.1.0\n    \">= 2.0.0 and < 2.1.0\"\n\nSince the example above is such a common requirement, it can\nbe expressed as:\n\n    \"~> 2.0.0\"\n\n`~>` will never include pre-release versions of its upper bound,\nregardless of the usage of the `:allow_pre` option, or whether the operand\nis a pre-release version. It can also be used to set an upper bound on only the major\nversion part. See the table below for `~>` requirements and\ntheir corresponding translations.\n\n`~>`           | Translation\n:------------- | :---------------------\n`~> 2.0.0`     | `>= 2.0.0 and < 2.1.0`\n`~> 2.1.2`     | `>= 2.1.2 and < 2.2.0`\n`~> 2.1.3-dev` | `>= 2.1.3-dev and < 2.2.0`\n`~> 2.0`       | `>= 2.0.0 and < 3.0.0`\n`~> 2.1`       | `>= 2.1.0 and < 3.0.0`\n\nThe requirement operand after the `~>` is allowed to omit the patch version,\nallowing us to express `~> 2.1` or `~> 2.1-dev`, something that wouldn't be allowed\nwhen using the common comparison operators.\n\nWhen the `:allow_pre` option is set `false` in `Version.match?/3`, the requirement\nwill not match a pre-release version unless the operand is a pre-release version.\nThe default is to always allow pre-releases but note that in\nHex `:allow_pre` is set to `false`. See the table below for examples.\n\nRequirement    | Version     | `:allow_pre`      | Matches\n:------------- | :---------- | :---------------- | :------\n`~> 2.0`       | `2.1.0`     | `true` or `false` | `true`\n`~> 2.0`       | `3.0.0`     | `true` or `false` | `false`\n`~> 2.0.0`     | `2.0.5`     | `true` or `false` | `true`\n`~> 2.0.0`     | `2.1.0`     | `true` or `false` | `false`\n`~> 2.1.2`     | `2.1.6-dev` | `true`            | `true`\n`~> 2.1.2`     | `2.1.6-dev` | `false`           | `false`\n`~> 2.1-dev`   | `2.2.0-dev` | `true` or `false` | `true`\n`~> 2.1.2-dev` | `2.1.6-dev` | `true` or `false` | `true`\n`>= 2.1.0`     | `2.2.0-dev` | `true`            | `true`\n`>= 2.1.0`     | `2.2.0-dev` | `false`           | `false`\n`>= 2.1.0-dev` | `2.2.6-dev` | `true` or `false` | `true`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.add_backend(backend, opts \\\\ []) <response> Adds a new backend.\n\nAdding a backend calls the `init/1` function in that backend\nwith the name of the backend as its argument. For example,\ncalling\n\n    Logger.add_backend(MyBackend)\n\nwill call `MyBackend.init(MyBackend)` to initialize the new\nbackend. If the backend's `init/1` callback returns `{:ok, _}`,\nthen this function returns `{:ok, pid}`. If the handler returns\n`{:error, :ignore}` from `init/1`, this function still returns\n`{:ok, pid}` but the handler is not started. If the handler\nreturns `{:error, reason}` from `init/1`, this function returns\n`{:error, {reason, info}}` where `info` is more information on\nthe backend that failed to start.\n\nBackends added by this function are not persisted. Therefore\nif the Logger application or supervision tree is restarted,\nthe backend won't be available. If you need this guarantee,\nthen configure the backend via the application environment:\n\n    config :logger, :backends, [MyBackend]\n\n## Options\n\n  * `:flush` - when `true`, guarantees all messages currently sent\n    to `Logger` are processed before the backend is added\n\n## Examples\n\n    {:ok, _pid} = Logger.add_backend(MyBackend, flush: true)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.add_translator(translator) <response> Adds a new translator."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.bare_log(level, message_or_fun, metadata \\\\ []) <response> Logs a message dynamically.\n\nOpposite to `log/3`, `debug/2`, `info/2`, and friends, the arguments\ngiven to `bare_log/3` are always evaluated. However, you can pass\nanonymous functions to `bare_log/3` and they will only be evaluated\nif there is something to be logged."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.compare_levels(left, right) <response> Compares log levels.\n\nReceives two log levels and compares the `left` level\nagainst the `right` level and returns:\n\n  * `:lt` if `left` is less than `right`\n  * `:eq` if `left` and `right` are equal\n  * `:gt` if `left` is greater than `right`\n\n## Examples\n\n    iex> Logger.compare_levels(:debug, :warning)\n    :lt\n    iex> Logger.compare_levels(:error, :info)\n    :gt"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.configure(options) <response> Configures the logger.\n\nSee the \"Runtime Configuration\" section in the `Logger` module\ndocumentation for the available options. The changes done here\nare automatically persisted to the `:logger` application\nenvironment."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.configure_backend(backend, options) <response> Configures the given backend.\n\nThe backend needs to be started and running in order to\nbe configured at runtime."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_all_module_levels() <response> Resets the logging level for all modules to the primary level."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_application_level(appname) <response> Resets logging level for all modules in the given application to the primary level.\n\nEquivalent of:\n\n    appname |> Application.spec(:modules) |> Logger.delete_module_level()"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_module_level(module) <response> Resets the logging level for a given module to the primary level."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.delete_process_level(pid) <response> Resets logging level for the current process to the primary level.\n\nCurrently the only accepted PID is `self()`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.disable(pid) <response> Disables logging for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nEquivalent of:\n\n    put_process_level(pid, :none)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.enable(pid) <response> Enables logging for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nEquivalent of:\n\n    delete_process_level(pid)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.enabled?(pid) <response> Returns whether the logging is enabled for a given process.\n\nCurrently the only accepted PID is `self()`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.flush() <response> Flushes the logger.\n\nThis guarantees all messages sent to `Logger` prior to this call will\nbe processed. This is useful for testing and it should not be called\nin production code."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.get_module_level(mod) <response> Gets logging level for given module.\n\nThe returned value will be the effective value used. If no value\nwas set for a given module, then it will not be present in\nthe returned list."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.get_process_level(pid) <response> Gets logging level for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nThe returned value will be the effective value used. If no value\nwas set for a given process, then `nil` is returned."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.level() <response> Retrieves the `Logger` level.\n\nThe `Logger` level can be changed via `configure/1`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.metadata() <response> Reads the current process metadata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.metadata(keyword) <response> Alters the current process metadata according to the given keyword list.\n\nThis function will merge the given keyword list into the existing metadata,\nwith the exception of setting a key to `nil`, which will remove that key\nfrom the metadata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.put_application_level(appname, level) <response> Puts logging level for modules in a given application.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the project.\n\nEquivalent of:\n\n    appname |> Application.spec(:modules) |> Logger.put_module_level(level)"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.put_module_level(mod, level) <response> Puts logging level for given module.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the project.\n\n## Example\n\n    defmodule Foo do\n      require Logger\n\n      def log, do: Logger.debug(\"foo\")\n    end\n\n    Logger.configure(level: :error)\n    Logger.put_module_level(Foo, :all)\n\n    Foo.log()\n    # This will print the message even if global level is :error"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.put_process_level(pid, level) <response> Puts logging level for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the running system."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.remove_backend(backend, opts \\\\ []) <response> Removes a backend.\n\n## Options\n\n  * `:flush` - when `true`, guarantees all messages currently sent\n    to `Logger` are processed before the backend is removed"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.remove_translator(translator) <response> Removes a translator."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.reset_metadata(keyword \\\\ []) <response> Resets the current process metadata to the given keyword list."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> A logger for Elixir applications.\n\nIt includes many features:\n\n  * Provides debug, info, warn, and error levels.\n\n  * Supports multiple backends which are automatically\n    supervised when plugged into `Logger`.\n\n  * Formats and truncates messages on the client\n    to avoid clogging `Logger` backends.\n\n  * Alternates between sync and async modes to remain\n    performant when required but also apply backpressure\n    when under stress.\n\n  * Integrates with Erlang's [`:logger`](`:logger`)\n    to convert terms to Elixir syntax.\n\n  * Allows overriding the logging level for a specific module,\n    application or process.\n\nLogging is useful for tracking when an event of interest happens in your\nsystem. For example, it may be helpful to log whenever a user is deleted.\n\n    def delete_user(user) do\n      Logger.info(\"Deleting user from the system: #{inspect(user)}\")\n      # ...\n    end\n\nThe `Logger.info/2` macro emits the provided message at the `:info`\nlevel. Note the arguments given to `info/2` will only be evaluated\nif a message is logged. For instance, if the Logger level is\nset to `:warning`, `:info` messages are never logged and therefore\nthe arguments given above won't even be executed.\n\nThere are additional macros for other levels.\n\nLogger also allows log commands to be removed altogether via the\n`:compile_time_purge_matching` option (see below).\n\nFor dynamically logging messages, see `bare_log/3`. But note that\n`bare_log/3` always evaluates its arguments (unless the argument\nis an anonymous function)."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Levels\n\nThe supported levels, ordered by importance, are:\n\n  * `:emergency` - when system is unusable, panics\n  * `:alert` - for alerts, actions that must be taken immediately,\n    ex. corrupted database\n  * `:critical` - for critical conditions\n  * `:error` - for errors\n  * `:warning` - for warnings\n  * `:notice` - for normal, but significant, messages\n  * `:info` - for information of any kind\n  * `:debug` - for debug-related messages\n\nFor example, `:info` takes precedence over `:debug`. If your log\nlevel is set to `:info`, then all `:info`, `:notice` and above will\nbe passed to backends. If your log level is set to `:alert`, only\n`:alert` and `:emergency` will be printed."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Message\n\nLogger can be used for logging both unstructured and structured data.\n\nUnstructured data is a string or a list of strings:\n\n    Logger.info(\"hello world!\")\n    Logger.info([\"hello \", \"world!\"])\n\nStructured data, also known as reports, are keyword lists and maps:\n\n    Logger.info([new_user: user.id, account_type: :admin])\n    Logger.info(%{new_user: user.id, account_type: :admin})\n\nLog functions also accept a zero-arity anonymous function as a message:\n\n    Logger.info(fn -> \"hello world!\" end)\n\nThe anonymous function can return a message or a tuple containing\nthe message and additional metadata (to be described in the next\nsection).\n\nIn all cases, the arguments given to the `Logger` macros are only\nevaluated if required by the current log level. The exception is\nthe `bare_log/3` function, which is the raw mechanism for logging."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Metadata\n\nWhenever a message is logged, additional information can be given\nvia metadata. Each log operation, such as `Logger.info/2`, allows\nmetadata to be given as an argument.\n\nFurthermore, metadata can be set per process with `Logger.metadata/1`.\n\nSome metadata, however, is always added automatically by Logger\nwhenever possible. Those are:\n\n  * `:application` - the current application\n\n  * `:mfa` - the current module, function and arity\n\n  * `:file` - the current file\n\n  * `:line` - the current line\n\n  * `:pid` - the current process identifier\n\n  * `:initial_call` - the initial call that started the process\n\n  * `:registered_name` - the process registered name as an atom\n\n  * `:domain` - a list of domains for the logged message. For example,\n    all Elixir reports default to `[:elixir]`. Erlang reports may start\n    with `[:otp]` or `[:sasl]`\n\n  * `:crash_reason` - a two-element tuple with the throw/error/exit reason\n    as first argument and the stacktrace as second. A throw will always be\n    `{:nocatch, term}`. An error is always an `Exception` struct. All other\n    entries are exits. The console backend ignores this metadata by default\n    but it can be useful to other backends, such as the ones that report\n    errors to third-party services\n\nNote that all metadata is optional and may not always be available.\nThe `:mfa`, `:file`, `:line`, and similar metadata are automatically\nincluded when using `Logger` macros. `Logger.bare_log/3` does not include\nany metadata beyond the `:pid` by default. Other metadata, such as\n`:crash_reason`, `:initial_call`, and `:registered_name` are available\nonly inside behaviours such as GenServer, Supervisor, and others.\n\nFor example, you might wish to include a custom `:error_code` metadata in\nyour logs:\n\n    Logger.error(\"We have a problem\", [error_code: :pc_load_letter])\n\nIn your app's logger configuration, you would need to include the\n`:error_code` key and you would need to include `$metadata` as part of\nyour log format template:\n\n    config :logger, :console,\n     format: \"[$level] $message $metadata\\n\",\n     metadata: [:error_code, :file]\n\nYour logs might then receive lines like this:\n\n    [error] We have a problem error_code=pc_load_letter file=lib/app.ex"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Configuration\n\n`Logger` supports a wide range of configurations.\n\nThis configuration is split in three categories:\n\n  * Application configuration - must be set before the `:logger`\n    application is started\n\n  * Runtime configuration - can be set before the `:logger`\n    application is started, but may be changed during runtime\n\n  * Erlang configuration - options that handle integration with\n    Erlang's logging facilities"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Application configuration\n\nThe following configuration must be set via config files (such as\n`config/config.exs`) before the `:logger` application is started.\n\n  * `:backends` - the backends to be used. Defaults to `[:console]`.\n    See the \"Backends\" section for more information.\n\n  * `:compile_time_application` - sets the `:application` metadata value\n    to the configured value at compilation time. This configuration is\n    automatically set by Mix and made available as metadata when logging.\n\n  * `:compile_time_purge_matching` - purges *at compilation time* all calls\n    that match the given conditions. This means that `Logger` calls with\n    level lower than this option will be completely removed at compile time,\n    accruing no overhead at runtime. This configuration expects a list of\n    keyword lists. Each keyword list contains a metadata key and the matching\n    value that should be purged. Some special keys are supported:\n\n      * `:level_lower_than` - purges all messages with a lower logger level\n      * `:module` - purges all messages with the matching module\n      * `:function` - purges all messages with the \"function/arity\"\n\n    Remember that if you want to purge log calls from a dependency, the\n    dependency must be recompiled.\n\n  * `:start_options` - passes start options to Logger's main process, such\n    as `:spawn_opt` and `:hibernate_after`. All options in `t:GenServer.option/0`\n    are accepted, except `:name`.\n\nFor example, to configure the `:backends` and purge all calls that happen\nat compile time with level lower than `:info` in a `config/config.exs` file:\n\n    config :logger,\n      backends: [:console],\n      compile_time_purge_matching: [\n        [level_lower_than: :info]\n      ]\n\nIf you want to purge all log calls from an application named `:foo` and only\nkeep errors from `Bar.foo/3`, you can set up two different matches:\n\n    config :logger,\n      compile_time_purge_matching: [\n        [application: :foo],\n        [module: Bar, function: \"foo/3\", level_lower_than: :error]\n      ]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Runtime Configuration\n\nAll configuration below can be set via config files (such as\n`config/config.exs`) but also changed dynamically during runtime via\n`Logger.configure/1`.\n\n  * `:level` - the logging level. Attempting to log any message\n    with severity less than the configured level will simply\n    cause the message to be ignored. Keep in mind that each backend\n    may have its specific level, too. In addition to levels mentioned\n    above it also supports 2 \"meta-levels\":\n\n      - `:all` - all messages will be logged, conceptually identical to\n        `:debug`\n      - `:none` - no messages will be logged at all\n\n  * `:utc_log` - when `true`, uses UTC in logs. By default it uses\n    local time (i.e., it defaults to `false`).\n\n  * `:truncate` - the maximum message size to be logged (in bytes).\n    Defaults to 8192 bytes. Note this configuration is approximate.\n    Truncated messages will have `\" (truncated)\"` at the end.\n    The atom `:infinity` can be passed to disable this behavior.\n\n  * `:sync_threshold` - if the `Logger` manager has more than\n    `:sync_threshold` messages in its queue, `Logger` will change\n    to *sync mode*, to apply backpressure to the clients.\n    `Logger` will return to *async mode* once the number of messages\n    in the queue is reduced to one below the `sync_threshold`.\n    Defaults to 20 messages. `:sync_threshold` can be set to `0` to\n    force *sync mode*.\n\n  * `:discard_threshold` - if the `Logger` manager has more than\n    `:discard_threshold` messages in its queue, `Logger` will change\n    to *discard mode* and messages will be discarded directly in the\n    clients. `Logger` will return to *sync mode* once the number of\n    messages in the queue is reduced to one below the `discard_threshold`.\n    Defaults to 500 messages.\n\n  * `:discard_threshold_periodic_check` - a periodic check that\n    checks and reports if logger is discarding messages. It logs a warning\n    message whenever the system is (or continues) in discard mode and\n    it logs a warning message whenever if the system was discarding messages\n    but stopped doing so after the previous check. By default it runs\n    every `30_000` milliseconds.\n\n  * `:translator_inspect_opts` - when translating OTP reports and\n    errors, the last message and state must be inspected in the\n    error reports. This configuration allow developers to change\n    how much and how the data should be inspected.\n\nFor example, to configure the `:level` and `:truncate` options in a\n`config/config.exs` file:\n\n    config :logger,\n      level: :warning,\n      truncate: 4096"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Erlang/OTP integration\n\nFrom Elixir v1.10, Elixir's Logger is fully integrated with Erlang's\nlogger. They share the same `Logger.level/0`, any metadata set with\n`Logger.metadata/1` applies to both, and so on.\n\nElixir also supports formatting Erlang reports using Elixir syntax.\nThis can be controlled with two configurations:\n\n  * `:handle_otp_reports` - redirects OTP reports to `Logger` so\n    they are formatted in Elixir terms. This effectively disables\n    Erlang standard logger. Defaults to `true`.\n\n  * `:handle_sasl_reports` - redirects supervisor, crash and\n    progress reports to `Logger` so they are formatted in Elixir\n    terms. Your application must guarantee `:sasl` is started before\n    `:logger`. This means you may see some initial reports written\n    in Erlang syntax until the Logger application kicks in.\n    Defaults to `false`. This option only has an effect if\n    `:handle_otp_reports` is true.\n\nFor example, to configure `Logger` to redirect all Erlang messages using a\n`config/config.exs` file:\n\n    config :logger,\n      handle_otp_reports: true,\n      handle_sasl_reports: true\n\nFurthermore, `Logger` allows messages sent by Erlang to be translated\ninto an Elixir format via translators. Translators can be added at any\ntime with the `add_translator/1` and `remove_translator/1` APIs. Check\n`Logger.Translator` for more information."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> Backends\n\n`Logger` supports different backends where log messages are written to.\n\nThe available backends by default are:\n\n  * `:console` - logs messages to the console (enabled by default).\n    `:console` is simply a shortcut for `Logger.Backends.Console`\n    (see its documentation for more information)\n\nDevelopers may also implement their own backends, an option that\nis explored in more detail below.\n\nThe initial backends are loaded via the `:backends` configuration,\nwhich must be set before the `:logger` application is started.\nHowever, by the time the Logger application starts, the code for your\nown and third-party backends may not yet be available. For this reason,\nit is preferred to add and remove backends via `add_backend/2` and\n`remove_backend/2` functions. This is often done in your\n`c:Application.start/2` callback:\n\n    @impl true\n    def start(_type, _args) do\n      Logger.add_backend(MyCustomBackend)\n\nThe backend can be configured either on the `add_backend/2` call:\n\n    @impl true\n    def start(_type, _args) do\n      Logger.add_backend(MyCustomBackend, some_config: ...)\n\nOr in your config files:\n\n    config :logger, MyCustomBackend,\n      some_config: ..."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Elixir custom backends\n\nAny developer can create their own `Logger` backend. Since `Logger`\nis an event manager powered by `:gen_event`, writing a new backend\nis a matter of creating an event handler, as described in the\n[`:gen_event`](`:gen_event`) documentation.\n\nFrom now on, we will be using the term \"event handler\" to refer\nto your custom backend, as we head into implementation details.\n\nOnce the `:logger` application starts, it installs all event handlers\nlisted under the `:backends` configuration into the `Logger` event\nmanager. The event manager and all added event handlers are automatically\nsupervised by `Logger`.\n\nNote that if a backend fails to start by returning `{:error, :ignore}`\nfrom its `init/1` callback, then it's not added to the backends but\nnothing fails. If a backend fails to start by returning `{:error, reason}`\nfrom its `init/1` callback, the `:logger` application will fail to start.\n\nOnce initialized, the handler should be designed to handle the\nfollowing events:\n\n  * `{level, group_leader, {Logger, message, timestamp, metadata}}` where:\n    * `level` is one of `:debug`, `:info`, `:warn`, or `:error`, as previously\n      described (for compatibility with pre 1.10 backends the `:notice` will\n      be translated to `:info` and all messages above `:error` will be translated\n      to `:error`)\n    * `group_leader` is the group leader of the process which logged the message\n    * `{Logger, message, timestamp, metadata}` is a tuple containing information\n      about the logged message:\n      * the first element is always the atom `Logger`\n      * `message` is the actual message (as chardata)\n      * `timestamp` is the timestamp for when the message was logged, as a\n        `{{year, month, day}, {hour, minute, second, millisecond}}` tuple\n      * `metadata` is a keyword list of metadata used when logging the message\n\n  * `:flush`\n\nIt is recommended that handlers ignore messages where the group\nleader is in a different node than the one where the handler is\ninstalled. For example:\n\n    def handle_event({_level, gl, {Logger, _, _, _}}, state)\n        when node(gl) != node() do\n      {:ok, state}\n    end\n\nIn the case of the event `:flush` handlers should flush any pending\ndata. This event is triggered by `Logger.flush/0`.\n\nFurthermore, backends can be configured via the `configure_backend/2`\nfunction which requires event handlers to handle calls of the\nfollowing format:\n\n    {:configure, options}\n\nwhere `options` is a keyword list. The result of the call is the result\nreturned by `configure_backend/2`. The recommended return value for\nsuccessful configuration is `:ok`. For example:\n\n    def handle_call({:configure, options}, state) do\n      new_state = reconfigure_state(state, options)\n      {:ok, :ok, new_state}\n    end\n\nIt is recommended that backends support at least the following configuration\noptions:\n\n  * `:level` - the logging level for that backend\n  * `:format` - the logging format for that backend\n  * `:metadata` - the metadata to include in that backend\n\nCheck the `Logger.Backends.Console` implementation in Elixir's codebase\nfor examples on how to handle the recommendations in this section and\nhow to process the existing options."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Elixir.Logger <response> # Erlang/OTP handlers\n\nWhile Elixir Logger provides backends, Erlang/OTP logger provides handlers.\nThey represent the same concept: the ability to integrate into the logging\nsystem to handle each logged message/event.\n\nHowever, implementation-wise, they have the following differences:\n\n  * Elixir backends run in a separate process which comes with overload\n    protection. However, because this process is a single GenEvent, any\n    long running action should be avoided, as it can lead to bottlenecks\n    in the system\n\n  * Erlang handlers run in the same process as the process logging the\n    message/event. This gives developers more flexibility but they should\n    avoid performing any long running action in such handlers, as it may\n    slow down the action being executed considerably. At the moment, there\n    is no built-in overload protection for Erlang handlers, so it is your\n    responsibility to implement it\n\nThe good news is that developers can use third-party implementations of\nboth Elixir backends and Erlang handlers. We have already covered Elixir\nbackends, so let's see how to add Erlang/OTP handlers.\n\nErlang/OTP handlers must be listed under your own application:\n\n    config :my_app, :logger, [\n      {:handler, :name_of_the_handler, ACustomHandler, configuration = %{}}\n    ]\n\nAnd then, explicitly attached in your `c:Application.start/2` callback:\n\n    :logger.add_handlers(:my_app)\n\nNote we do not recommend configuring Erlang/OTP's logger directly under\nthe `:kernel` application in your `config/config.exs`, like this:\n\n    # Not recommended:\n    config :kernel, :logger, ...\n\nThis is because by the time Elixir starts, Erlang's kernel has already\nbeen started, which means the configuration above would have no effect."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.App.stop() <response> Stops the application without sending messages to error logger."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.child_spec(init_arg) <response> Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.start_link(_) <response> Starts the backend supervisor."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.translate_backend(other) <response> Translates the shortcut backend name into its handler."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.unwatch(backend) <response> Removes the given `backend`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.BackendSupervisor.watch(backend) <response> Watches the given `backend`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Backends.Console.Elixir.Logger.Backends.Console <response> A logger backend that logs messages by printing them to the console."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Backends.Console.Elixir.Logger.Backends.Console <response> Options\n\n  * `:level` - the level to be logged by this backend.\n    Note that messages are filtered by the general\n    `:level` configuration for the `:logger` application first.\n\n  * `:format` - the format message used to print logs.\n    Defaults to: `\"\\n$time $metadata[$level] $message\\n\"`.\n    It may also be a `{module, function}` tuple that is invoked\n    with the log level, the message, the current timestamp and\n    the metadata and must return `t:IO.chardata/0`. See\n    `Logger.Formatter`.\n\n  * `:metadata` - the metadata to be printed by `$metadata`.\n    Defaults to an empty list (no metadata).\n    Setting `:metadata` to `:all` prints all metadata. See\n    the \"Metadata\" section for more information.\n\n  * `:colors` - a keyword list of coloring options.\n\n  * `:device` - the device to log error messages to. Defaults to\n    `:user` but can be changed to something else such as `:standard_error`.\n\n  * `:max_buffer` - maximum events to buffer while waiting\n    for a confirmation from the IO device (default: 32).\n    Once the buffer is full, the backend will block until\n    a confirmation is received.\n\nThe supported keys in the `:colors` keyword list are:\n\n  * `:enabled` - boolean value that allows for switching the\n    coloring on and off. Defaults to: `IO.ANSI.enabled?/0`\n\n  * `:debug` - color for debug messages. Defaults to: `:cyan`\n\n  * `:info` - color for info and notice messages. Defaults to: `:normal`\n\n  * `:warning` - color for warning messages. Defaults to: `:yellow`\n\n  * `:error` - color for error and higher messages. Defaults to: `:red`\n\nSee the `IO.ANSI` module for a list of colors and attributes.\n\nHere is an example of how to configure the `:console` backend in a\n`config/config.exs` file:\n\n    config :logger, :console,\n      format: \"\\n$time $metadata[$level] $message\\n\",\n      metadata: [:user_id]"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Filter.filter_elixir_domain(map, extra) <response> Filter messages logged via `Logger` module when not logging OTP reports."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Filter.process_level(map, extra) <response> Filter out logs if current process opted out of certain levels."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Filter.silence_logger_exit(arg1, extra) <response> A filter that waits until Logger exits and then removes itself."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.compile(pattern) <response> Compiles a format string into a data structure that `format/5` can handle.\n\nCheck the module doc for documentation on the valid parameters that\nwill be interpolated in the pattern. If you pass `nil` as the pattern,\nthe pattern defaults to:\n\n    \"\\n$time $metadata[$level] $message\\n\"\n\nIf you want to customize formatting through a custom formatter, you can\npass a `{module, function}` tuple as the `pattern`.\n\n    iex> Logger.Formatter.compile(\"$time $metadata [$level] $message\\n\")\n    [:time, \" \", :metadata, \" [\", :level, \"] \", :message, \"\\n\"]\n\n    iex> Logger.Formatter.compile({MyLoggerFormatter, :format})\n    {MyLoggerFormatter, :format}"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.format(pattern_or_function, level, message, timestamp, metadata) <response> Takes a compiled format and injects the level, timestamp, message, and\nmetadata keyword list and returns a properly formatted string.\n\nIf `pattern_or_function` is a `{module, function_name}` tuple,\nthen `module.function_name(level, message, timestamp, metadata)` is\ninvoked to get the message. See `Logger.Backends.Console` for more\ninformation on this.\n\n## Examples\n\n    iex> pattern = Logger.Formatter.compile(\"[$level] $message\")\n    iex> timestamp = {{1977, 01, 28}, {13, 29, 00, 000}}\n    iex> formatted = Logger.Formatter.format(pattern, :info, \"hello\", timestamp, [])\n    iex> IO.chardata_to_string(formatted)\n    \"[info] hello\""}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.format_date(arg) <response> Formats date as chardata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.format_time(arg) <response> Formats time as chardata."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.prune(binary) <response> Prunes invalid Unicode code points from lists and invalid UTF-8 bytes.\n\nTypically called after formatting when the data cannot be printed."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Conveniences for formatting data for logs.\n\nThis module allows developers to specify a `{module, function}`\nor a string that serves as template for log messages."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Formatting string\n\nThe log messages can be controlled by a formatting string.\nHere is an example of how to configure the `:console` backend\nin a `config/config.exs` file:\n\nFor example:\n\n    config :logger, :console,\n      format: \"$time $metadata[$level] $message\\n\"\n\nThe above will print error messages as:\n\n    18:43:12.439 user_id=13 [error] Hello\\n\n\nThe valid parameters you can use are:\n\n  * `$time`     - the time the log message was sent\n  * `$date`     - the date the log message was sent\n  * `$message`  - the log message\n  * `$level`    - the log level\n  * `$node`     - the node that prints the message\n  * `$metadata` - user controlled data presented in `\"key=val key2=val2 \"` format\n\nBackends typically allow developers to supply such control\nstrings via configuration files. This module provides `compile/1`,\nwhich compiles the string into a format for fast operations at\nruntime and `format/5` to format the compiled pattern into an\nactual IO data."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Formatting function\n\nYou can also customize the format of your log messages to a\n`{module, function}` tuple if you wish to provide your own\nformat function. Here is an example of how to configure the\n`:console` backend in a `config/config.exs` file:\n\n    config :logger, :console,\n      format: {MyConsoleLogger, :format}\n\nAnd here is an example of how you can define `MyConsoleLogger.format/4`\nfrom the above configuration:\n\n    defmodule MyConsoleLogger do\n      @spec format(atom, term, Logger.Formatter.time(), keyword()) :: IO.chardata()\n      def format(level, message, timestamp, metadata) do\n        # Custom formatting logic that must return chardata.\n        # ...\n      end\n    end\n\n**The `format/4` function must not fail**. If it does, it will bring\nthat particular logger instance down, causing your system to temporarily\nlose log messages. If necessary, wrap the function in a `rescue` and\nlog a default message instead:\n\n    defmodule MyConsoleLogger do\n      def format(level, message, timestamp, metadata) do\n        # Custom formatting logic\n      rescue\n        _ -> \"could not format: #{inspect({level, message, metadata})}\"\n      end\n    end\n\nThe `{module, function}` will be invoked with four arguments:\n\n  * the log level: an atom (`t:atom/0`)\n  * the message: this is usually `t:IO.chardata/0`, but in some cases it\n    may contain invalid data. Since the formatting function must\n    *never* fail, you need to prepare for the message being anything\n  * the current timestamp: a term of type `t:Logger.Formatter.time/0`\n  * the metadata: a keyword list (`t:keyword/0`)\n\nThe `{module, function}` must return a term of type `t:IO.chardata/0`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Formatter.Elixir.Logger.Formatter <response> Metadata\n\nMetadata to be sent to the logger can be read and written with\nthe `Logger.metadata/0` and `Logger.metadata/1` functions. For example,\nyou can set `Logger.metadata([user_id: 13])` to add user_id metadata\nto the current process. The user can configure the backend to choose\nwhich metadata it wants to print and it will replace the `$metadata`\nvalue."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Translator.translate(min_level, level, kind, message) <response> Built-in translation function."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Translator.Elixir.Logger.Translator <response> Default translation for Erlang log messages.\n\nLogger allows developers to rewrite log messages provided by\nOTP applications into a format more compatible with Elixir\nlog messages by providing a translator.\n\nA translator is simply a tuple containing a module and a function\nthat can be added and removed via the `Logger.add_translator/1` and\n`Logger.remove_translator/1` functions and is invoked for every Erlang\nmessage above the minimum log level with four arguments:\n\n  * `min_level` - the current Logger level\n  * `level` - the level of the message being translated\n  * `kind` - if the message is a `:report` or `:format`\n  * `message` - the message to format. If it is `:report`, it is a tuple\n    with `{report_type, report_data}`, if it is `:format`, it is a\n    tuple with `{format_message, format_args}`.\n\nThe function must return:\n\n  * `{:ok, chardata, metadata}` - if the message translation with its metadata\n  * `{:ok, chardata}` - the translated message\n  * `:skip` - if the message is not meant to be translated nor logged\n  * `:none` - if there is no translation, which triggers the next translator\n\nSee the function `translate/4` in this module for an example implementation\nand the default messages translated by Logger."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.scan_inspect(format, args, truncate, opts \\\\ %Inspect.Opts{}) <response> Receives a format string and arguments, scans them, and then replace `~p`,\n`~P`, `~w` and `~W` by its inspected variants.\n\nFor information about format scanning and how to consume them,\ncheck `:io_lib.scan_format/2`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.timestamp(timestamp \\\\ :os.system_time(:microsecond), utc_log?) <response> Returns a timestamp that includes milliseconds."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.truncate(chardata, n) <response> Truncates a `chardata` into `n` bytes.\n\nThere is a chance we truncate in the middle of a grapheme\ncluster but we never truncate in the middle of a binary\ncode point. For this reason, truncation is not exact."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Watcher.child_spec(init_arg) <response> Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Watcher.start_link(tuple) <response> Starts a watcher server.\n\nThis is useful when there is a need to start a handler\noutside of the handler supervision tree."}

{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Translator.Elixir.Logger.Translator <response> Default translation for Erlang log messages.\n\nLogger allows developers to rewrite log messages provided by\nOTP applications into a format more compatible with Elixir\nlog messages by providing a translator.\n\nA translator is simply a tuple containing a module and a function\nthat can be added and removed via the `Logger.add_translator/1` and\n`Logger.remove_translator/1` functions and is invoked for every Erlang\nmessage above the minimum log level with four arguments:\n\n  * `min_level` - the current Logger level\n  * `level` - the level of the message being translated\n  * `kind` - if the message is a `:report` or `:format`\n  * `message` - the message to format. If it is `:report`, it is a tuple\n    with `{report_type, report_data}`, if it is `:format`, it is a\n    tuple with `{format_message, format_args}`.\n\nThe function must return:\n\n  * `{:ok, chardata, metadata}` - if the message translation with its metadata\n  * `{:ok, chardata}` - the translated message\n  * `:skip` - if the message is not meant to be translated nor logged\n  * `:none` - if there is no translation, which triggers the next translator\n\nSee the function `translate/4` in this module for an example implementation\nand the default messages translated by Logger."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.scan_inspect(format, args, truncate, opts \\\\ %Inspect.Opts{}) <response> Receives a format string and arguments, scans them, and then replace `~p`,\n`~P`, `~w` and `~W` by its inspected variants.\n\nFor information about format scanning and how to consume them,\ncheck `:io_lib.scan_format/2`"}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.timestamp(timestamp \\\\ :os.system_time(:microsecond), utc_log?) <response> Returns a timestamp that includes milliseconds."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Utils.truncate(chardata, n) <response> Truncates a `chardata` into `n` bytes.\n\nThere is a chance we truncate in the middle of a grapheme\ncluster but we never truncate in the middle of a binary\ncode point. For this reason, truncation is not exact."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Watcher.child_spec(init_arg) <response> Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`."}
{"text":"Can you write a docstring for this Elixir function name? Elixir.Logger.Watcher.start_link(tuple) <response> Starts a watcher server.\n\nThis is useful when there is a need to start a handler\noutside of the handler supervision tree."}
